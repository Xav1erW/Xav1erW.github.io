---
title: 计算机组成原理复习
date: 2022.6.20
author: Xav1er
categories:	
  - Review
tags:
  - 计算机组成原理
  - 课内
  - 复习
---

# 计算机系统概论

## 数字计算机与模拟计算机

| 比较内容     | 电子数字计算机 | 电子模拟计算机   |
| ------------ | -------------- | ---------------- |
| 数据表示方式 | 0，1           | 电压             |
| 计算方式     | 数字技术       | 电压组合或测量值 |
| 控制方式     | 程序控制       | 盘上连线         |
| 精度         | 高             | 低               |
| 数据存储量   | 大             | 小               |
| 逻辑判断能力 | 强             | 无               |

## 冯诺依曼机

* 由运算器、存储器、控制器、输入设备和输出设备五个部分组成；

* 存储器以二进制形式存储指令和数据；
* 指令和数据放在同一个存储器；
* 指令由操作码和地址码组成；
* 存储程序并按地址顺序执行；
* 冯·诺依曼机的核心设计思想，机器自动化工作 的关键；
* 以运算器为中心。

### 控制器

工作周期：取指周期，执行周期

* 数据字：该字代表要处理的数据；
* 指令字：该字为一条指令；
* 指令流：取指周期中，从内存读出的信息流；
* 数据流：执行周期中，从内存读出的信息流。

**区分数据和指令**：取指周期拿出来的是指令，执行周期拿出来的是数据。

# 运算方法和运算器

## 定点数

假设用n+1位保存一个定点数

纯小数：

* 有符号：$x = x_sx_{-1}\cdots x_{-n}$ 范围 $0 \leq |x| \leq 1-2^{-n}$
* 无符号：$x = x_{-1}x_{-2}\cdots x_{-n-1}$ 范围 $0\leq x \leq 1-2^{-n-1}$

纯整数：

* 有符号：范围 $|x|\leq 2^{n}-1$
* 无符号：范围 $0 \leq x \leq 2^{n+1}-1$

### 原码

#### 定点小数

$$
[x]_原 = \left\{
\begin{align}
&x \quad &1 > x \geq 0\\
&1-x = 1+|x| \quad &0 \geq x >-1
\end{align}
\right.
$$

#### 定点整数

$$
[x]_原 = \left\{
\begin{align}
&x \quad &2^n > x \geq 0\\
&2^n-x = 2^n+|x| \quad &0 \geq x >-2^n
\end{align}
\right.
$$

**特点**：0有两种表示方法

**整体范围**： 

* 小数： $-1 < x < 1$
* 整数： $-2^n < x < 2^n$

### 补码

#### 定点小数

$$
[x]_补 = \left\{
\begin{align}
&x \quad &1 > x \geq 0\\
&2+x = 2-|x| \quad &0 \geq x \geq-1
\end{align}
\right.
$$

#### 定点整数

$$
[x]_补 = \left\{
\begin{align}
&x \quad &2^n > x \geq 0\\
&2^{n+1}+x = 2^{n+1}-|x| \quad &0 \geq x \geq -2^n
\end{align}
\right.
$$

0有唯一表示方法

补码的补码就是原码

除2可以直接通过右移

最小值是 $100000\cdots$

#### 原码求补码

> * 方法1：除符号位各位取反加一
> * 方法2：从最低位开始，遇到的第一个1以前的各位保持不变，之后各位取反。

#### 相反数的补码

已知 [x]~补~求[-x]~补~

> 连符号位一起各位求反，末位加1。

## 移码

把真值平移$2^n$ 个单位
$$
[x]_移 = 2^n+x
$$
与补码符号位相反

* 可以比较直观地判断两个数据的大小
* 表示浮点数阶码时，容易判断是否下溢；

| 真值 x(十进制)                                               | 真值 x(二进制)   | [x]原 | [x]反 | [x]补 | [x]移 |
| ------------------------------------------------------------ | ---------------- | ----- | ----- | ----- | ----- |
| –127 | –0 1 1 1 1 1 1 1 | **1** 1 1 1 1 1 1 1 |**1** 0 0 0 0 0 0 0|**1** 0 0 0 0 0 0 1|**0** 0 0 0 0 0 0 1 |
|–1|–0 0 0 0 0 0 0 1|**1** 0 0 0 0 0 0 1|**1** 1 1 1 1 1 1 0|**1** 1 1 1 1 1 1 1|**0** 1 1 1 1 1 1 1|
|0|0 0 0 0 0 0 0 0|**1** 0 0 0 0 0 0 0|**0** 0 0 0 0 0 0 0|**1** 1 1 1 1 1 1 1|**0** 0 0 0 0 0 0 0|
|+1|+ 0 0 0 0 0 0 0 1|**0** 0 0 0 0 0 0 1|**0** 0 0 0 0 0 0 1|**0** 0 0 0 0 0 0 1|**1** 0 0 0 0 0 0 1|
|+127|+ 0 1 1 1 1 1 1 1|**0** 1 1 1 1 1 1 1|**0** 1 1 1 1 1 1 1|**0** 1 1 1 1 1 1 1|**1** 1 1 1 1 1 1 1|

## 浮点数

$$
N = R^e \times M
$$

* M尾数，纯小数
* R基数，默认是2
* e阶码，指定小数点位置

### 规格化

保证表示唯一

**要求**： $1/R \leq M < 1$

* 尾数向左移n位(小数点右移)，同时阶码减n；
* 尾数向右移n位(小数点左移)，同时阶码加n。

尾数用原码表示时：尾数数值最高数值位为1； 尾数用补码表示时：尾数最高数值位和尾数符号位相反；

### IEEE754

32位：1位数符，8位阶码（包括符号），23位尾数

64位：1位数符，11位阶码（包括符号），52位尾数

尾数原码表示，由于规格化最高位为1，因此隐藏最高位的1.

**32位**阶码为移127码：$E = e+127$ ，真值为
$$
N = (-1)^S \times (1.M) \times 2^{E-127}
$$
**64位**
$$
N = (-1)^S \times (1.M) \times 2^{E-1023}
$$
**特殊值：**

正负零：$E = 0;\ M=0$ 正负由符号决定

正负无穷： $E = 1111\cdots; \  M = 0$ 正负由符号决定

真正指数的范围：-126~+127

| 符号位S | 阶码E | 尾数M | 数值N |
| ------- | ----- | ----- | ----- |
|0/1| 0| =0| 0|
|0/1 |0| ≠0 |$(-1)^S\times(0.M)×2^{-126}$|
|0/1| 1~254| ≠0 |$(-1)^S\times(1.M)×2^{E-127}$|
|0/1| 255| ≠0 |NaN（非数值）|
|0/1 |255| =0| $(-1)^S\times \infty$|

## 运算

### 补码加法

整数 $[x+y] = [x]+[y] (\mod 2^{n+1})$

小数 $[x+y] = [x]+[y] (\mod 2)$

### 补码减法

整数 $[x-y] = [x]-[y] = [x]+[-y] (\mod 2^{n+1})$

小数 $[x-y] = [x]-[y] = [x]+[-y] (\mod 2)$

> $[-y]$ 等于 $[y]$ 按位取反（包括符号位）再+1

### 溢出问题

#### 直接判别法

* 同号补码相加，结果符号位与被加数相反；溢出

* 异号补码相减，结果符号位与被减数相反；溢出

> 硬件实现复杂

#### 变形补码判别法

**变形补码**：也叫模4补码：采用双符号位表示补码

| 双符号位 | 结果 |
| -------- | ---- |
| 00       | 正   |
| 01       | 上溢 |
| 10       | 下溢 |
| 11       | 负   |

> 硬件实现简单，只需对结果符号位进行异或

#### 进位判别法

判别方法：最高数值位的进位与符号位的进位是否相同；

溢出标志
$$
V = C_f \oplus C_{n-1}
$$
其中 $C_f$ 为符号位进位；$C_{n-1}$ 为数值最高位进位。

![image-20220620153117043](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201531458.png)

加减法电路统一：

加入控制信号M，M和输入B的每一位为异或关系，当M为1的时候，$B' = \neg B$ ；同时M作为进位输入，完成求-B的补码操作。

![image-20220620153801436](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201538497.png)

多位加法器延迟时间
$$
t_a = n\cdot 2T+9T = (2n+9)T
$$
如果不考虑溢出就为
$$
t_a= [2(n-1)+9]T
$$

## 定点乘法

分析手算乘法步骤

![image-20220620154257830](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201542880.png)

> 乘法 = 加法+位移

### 原码并行乘法

$$
a = \sum_{i=1}^{m-1} a_i 2^i \qquad b = \sum_{j=0}^{n-1}b_j2^j
$$

相乘得到
$$
p = ab =\left(\sum_{i=1}^{m-1} a_i 2^i\right) \left(\sum_{j=0}^{n-1}b_j2^j\right) = \sum_{i=1}^{m-1}\sum_{j=0}^{n-1}(a_ib_j)2^{i+j}
$$
$A_i\cdot b_j$部分乘积项（位积）叫做一个被加数。$M\times N$个被加数用与门并行产生(a AND b)

时间
$$
t_m = (8n-4)T
$$


#### 阵列乘法器

![image-20220620155108703](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201551771.png)

#### 有符号乘法

$$
A \cdot B = (a_n \oplus b_n) (a_{n-1}\cdots a_0 \times b_{n-1}\cdots b_0)
$$

使用3个求补器，分别用对应的符号位控制： 

* 2个算前求补器：将两个操作数真值绝对值送入运算器；
* 1个算后求补器：乘积为负时把结果变成带符号数；

两相反数的补码特征： 自右向左，第一个“1”的右侧所有数据位，均相同； 左侧所有数据位，均相反。

对2求补器电路逻辑：采用按位扫描技术来执行求补操作；E为控制信号线，可由数据a的符号位来控制；

![image-20220620155610968](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201556033.png)

乘法器结构：

![image-20220620155745544](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201557607.png)

## 定点除法

可控加法/减法(CAS)单元：用于加减交替法的除法器中；由控制端P选择运算类型：P=0，作加法运算；P=1，作减法运算

四个输入：

* 被加/减数Ai
* 减数Bi
* 低 位进/借位Ci 
* 控制端P

四个输出：

* 加/减数Bi
* 当位和/差Si
* 向高位的进/借位Ci+1
* 控制端P

除法器结构：（被除数6位，除数3位）

![image-20220620160215240](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201602310.png)

执行时间
$$
t_d = 3(n+1)^2T
$$

> 在加减交替的除法阵列中，每一行所执行的操作究竟是加法还是减法，取决于前一行输出的符号与被除数的符号是否一致。当出现不够减时，部分余数相对于被除数来说要改变符号。这时应该产生一个商位“0”，除数首先沿对角线右移，然后加到下一行的部分余数上。当部分余数不改变它的符号时，即产生商位“1”，下一行的操作应该是减法。

![image-20220620160943308](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201609372.png)

## 浮点数加减运算

步骤：

* 零操作数检查    *一个操作数为0，则不必运算，节省运算时间*
* 两操作数对阶   *使小数点位置对齐，为加减运算做准备*
* 尾数相加减    *以双符号位的补码形式进行加减法操作*
* 结果的规格化
* 结果的舍入处理
* 结果的溢出判断

### 对阶

以较大的阶码为标准，调整阶码较小的数据；

* 求阶差$\Delta E ＝ E_X－E_Y$
* 调整阶码较小的数据
  * 若$\Delta E >0$，则MY右移$\Delta E$位，结果的阶码为$E_X$
  * 若$\Delta E <0$，则MX右移$|\Delta E|$位，结果的阶码为$E_Y$

### 结果的规格化处理

两尾数加减的结果有两种情况:

* 尾数溢出：两符号位为01或10，则**右规** ；尾数右移1位，阶码加1
* 尾数为非规格化数据，则**左规** ；尾数左移1位，阶码减１，直至数值位最高位与符号位相反。

### 结果的舍入处理

在对阶或右规操作时，会使加数或结果的尾数低若干位移出， 影响精度，常用两种舍入处理方法：

* 方法1：0舍1入法

  > 保留右移时的移出位，若最高位为１，则尾数加１；否则舍去；
  >
  > 特点：精度较高，但需要记录所有的移出位。

* 方法2：恒置1法

  > 若之前步骤有右移操作，则直接将结果的最低位置1;
  >
  > 特点：精度较0舍1入法较低，但应用简单。

### 结果的溢出判断

* 尾数溢出
  * 在规格化处理时，通过完成右规完成；
* 阶码溢出
  * 上溢(结果绝对值太大)——置上溢标志，结束；
  * 下溢(结果绝对值太小)——置机器零；
  * 正常——运算结束；

## 浮点乘除法运算

浮点数乘除运算的步骤

* 0操作数检查；
* 阶码加/减操作；
* 尾数乘/除操作；
* 结果规格化、舍入和溢出处理；

# 内部存储器

* 存储容量：存储单元个数×存储字长

* 存储速度：
  * 存取时间(访问时间)：从启动一次访问操作到完成该操作为止所经历的时间；以ns为单位，存取时间又分读出时间、写入时间两种。
  * 存取周期：存储器**连续启动两次独立的访问操作**所需的最小间隔时间。以ns为单位，**存取周期=存取时间+复原时间**
  * 存储器带宽：每秒从存储器进出信息的最大数量；单位为位/秒或者字节/秒。

>  只读存储器又分为掩膜 ROM、一次可编程 ROM(PROM)和可擦除PROM(EPROM)，后者又分为紫外线擦除EPROM(UV-EPROM)、电擦除EPROM(EEPROM或 E2PROM)和闪速(Flash)只读存储器。

>  当一个存储字的字长高于八位时，就存在一个存储字内部的多字节的排列顺序问题，其排列方式称为**端模式**。**大端**(big-endian)模式将一个字的高有效字节放在内存的低地址端，低有效字节放在内存的高地址端，而**小端**(little-endian)模式则将一个字的低有效字节放在内存的低地址端，高有效字节放在内存的高地址端。

## SRAM

静态RAM（SRAM）：由MOS电路构成的双稳触发器保存二进制信息；

* 优点：访问速度快，只要不掉电可以永久保存信息；
* 缺点：集成度低，功耗大，价格高；

动态RAM（DRAM）：由MOS电路中的栅极电容保存二进制信息；

* 优点：集成度高，功耗约为SRAM的1/6，价格低；
* 缺点：访问速度慢，电容的放电作用会使信息丢失，要长期保存数据必须定期刷新存储单元；主要种类有：SDRAM、DDR SDRAM

### 基本的静态存储元阵列

芯片封装后，3种外部信号线：

* 地址线：2n个单元，对应有n根地址线； 地址信号经过译码电路，产生每个单元的字线选通信号；
* 数据线：每个单元m位，对应有m根数据线；
* 控制线：读写控制信号：R/W =1，为读操作； R/W=0，为写操作；

地址：单译码和双译码

![image-20220620170725756](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201707854.png)

## DRAM

存储的信息 1 或 0 则是由电容器上的电荷量来体现——当电容器充满电荷时，代表存储了 1，当电容器放电没有电荷时，代表存储了 0。

![image-20220620170816151](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201708216.png)

1M×4 位 DRAM 芯片的外部引脚图。

与 SRAM 不同的是，图中增加了行地址锁存器和列地址锁存器。由于 DRAM 容量很大，地址线的数目相当多，为减少芯片引脚的数量，将地址分为行、列两部分**分时传送**。存储容量为 1M 字，共需 20 位地址线。此芯片地址引脚的数量为 10 位，先传送行地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器；然后传送列地址码 A10～A19，由列选通信号CAS 打入到列地址锁存器。片选信号的功能也由增加的 RAS 和 CAS 信号实现。

![image-20220620170905183](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201709257.png)

### 与SRAM对比

* 外部地址引脚比SRAM减少一半：送地址信息时，分行地址和列地址分别传送；
* 内部结构：比SRAM复杂
  * 刷新电路：用于存储元的信息刷新；
  * 行、列地址锁存器：用于保存完整的地址信息：行选通信号 （Row Address Strobe）、列选通信号 （Columns Address Strobe）
* DRAM的读写周期：与SRAM的读写周期相似，只是地址总线上的信号有所不同；在同一个读写周期内发生变化，分别为行地址、列地址；

### 刷新

DRAM 存储位元是基于电容器上的电荷量存储信息的，DRAM 的读操作是破坏性的，读操作会使电容器上的电荷流失，因而读出后必须刷新。而未读写的存储元也要定期刷新，因为电荷量会逐渐泄漏而减少。

在固定时间内对所有存储单元，通过“读出(不输出)—写入” 的方式恢复信息的操作过程；

当前主流的 DRAM 器件的刷新间隔时间(**刷新周期**)为 64ms

自动刷新：刷新计数器的宽度等于行地址锁存器的宽度。由于自动刷新不需要给出列地址，而行地址由片内刷新计数器自动生成，故可利用 CAS 信号先于 RAS 信号有效来启动一次刷新操作，此时地址线上的地址无效。

> 刷新过程中存储 器不能进行正常的读写访问

**集中式刷新策略**中，每一个刷新周期中集中一段时间对 DRAM 的所有行进行刷新。由于刷新操作的优先级高，刷新操作时正常的读/写操作被暂停，数据线输出被封锁。等所有行刷新结束后，又开始正常的读/写周期。由于在刷新的过程中不允许读/写操作，集中式刷新策略存在“死时间”。

**分散式刷新策略**中，每一行的刷新操作被均匀地分配到刷新周期时间内。将每个系统工作周期分为两部分，前半部分用于DRAM读/写/ 保持，后半部分用于刷新存储器的一行；

## 存储扩展

### 位扩展

例如：由1K×4的存储芯片构成1K×8的存储器

存储芯片与CPU的引脚连接方法：

* 地址线：各芯片的地址线**直接**与CPU地址线连接；
* 数据线：各芯片的数据线**分别与CPU数据线的不同位连接**；
* 片选及读写线：各芯片的片选及读写信号**直接**与CPU的访存及读写信号连接；

### 字扩展

字扩展：每个单元位数不变，总的单元个数增加。例如：用1K×8的存储芯片构成2K×8的存储器

存储芯片与CPU的引脚连接方法：

* 地址线：各芯片的地址线与CPU的**低位地址线直接连接**；
* 数据线：各芯片的数据线**直接**与CPU数据线连接；
* 读写线：各芯片的读写信号直接与CPU的读写信号连接；
* 片选信号：各芯片的片选信号**由CPU的高位地址和访存信号产生**；

### 计算字位扩展所需的存储芯片的数目

用L×K的芯片构成M×N的存储系统：所需芯片总数为
$$
M/L \times N/K
$$
扩展的时候可以使用74LS138等选择器

## ROM

其访问速度比 RAM 稍低，可以按地址随机访问并在线执行程序，因而在计算机中用于储存固件、引导加载程序、监控程序及不变或很少改变的数据。“只读”的意思是在其工作时只能读出，不能写入。

* 掩模式ROM
  * 定义：数据在芯片制造过程中写入，不能更改；
  * 优点：可靠性、集成度高，价格便宜；
  * 缺点：通用性差，不能改写内容；
* 一次编程ROM（PROM）
  * 定义：用户第一次使用时写入确定内容；
  * 优点：用户可根据需要对ROM编程；
  * 缺点：只能写入一次，不能更改；
* 多次编程ROM
  * 定义：可用紫外光照射（EPROM）或电擦除（E2PROM） 多次改写其中内容；
  * 优点：通用性较好，可反复使用；
* 闪速存储器（Flash Memory）
  * 定义：一种高密度、非易失性的读/写半导体存储器，它突破了 传统的存储器体系，改善了现有存储器的特性。
  * 在EPROM功能基础上，增加了电路的电擦除 和重新编程能力；也叫快擦型存储器。

### 有关存储器选择

系统程序区默认为写死的，因此使用ROM，用户程序需要修改因此使用RAM。

### 存储器设计的连接要点

参考[存储扩展](#存储扩展) 

* 片选线的连接
  * 一般使用CPU的高位地址线的和CPU的访存允许控制信号 线/MREQ，经译码器译码后产生各芯片的片选信号。
  * 关键点，也是最容易出错的地方。

## 并行存储器

### 双端口存储器

双端口存储器采用空间并行技术：同一个存储体使用两组相互独立的读写控制线路，可并行操作。

显卡上的存储器一般都是双端口存储器。

读写特点

* 无冲突读写：访问的存储单元不同，可并行读写存储体；
* 有冲突读写：访问同一存储单元，可使用/BUSY信号控制读写优先顺序；

### 多模块交叉存储器

#### 顺序方式

访问地址按顺序分配给一个模块后，接着又按顺序为下一个模块分配访问地址。这样，存储器的 32个字可由 5 位地址寄存器指示，其中高 2 位选择 4 个模块中的一个，低 3 位选择每个模块中的 8 个字。

在顺序方式中某个模块进行存取时，其他模块不工作。而某一模块出现故障时，其他模块可以照常工作。另外通过增添模块来扩充存储器容量也比较方便。但顺序方式的缺点是各模块一个接一个**串行工作**，因此存储器的带宽受到了限制。

#### 交叉方式

每个模块的单元地址是 不连续的；连续地址分 布在相邻的不同模块内。

> 对于数据的成块传送， 各模块可以实现多模块 流水式并行存取；

当存储器寻址时，用地址寄存器的低 2 位选择 4 个模块中的一个，而用高 3 位选择模块中的 8 个字。

![image-20220620175154754](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201751840.png)

#### 二者带宽计算

模块数为m，存储周期为T，总线周期 $\tau$ 

连续传送m个字：

**顺序**： $m*T$

**交叉**：$T+(m-1)*\tau$

## Cache

Cache的作用：

* 在CPU和主存之间加一块高速的SRAM（Cache）；
* 主存中将要被访问的数据提前送到Cache中；
* CPU访存时，先访问Cache，若没有再进行数据调度。

使用Cache的依据：在一段时间内，CPU所执行的程序和访问的数据大部分都在 某一段地址范围内，而该段范围外的地址访问很少；（程序访问的局部性原理）

CPU 与 cache 之间的数据交换是以字为单位，而 cache 与主存之间的数据交换是以块为单位。一个块由若干字组成，是定长的。

![image-20220620180201780](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201802839.png)

当 CPU 读取内存中一个字时，便发出此字的内存地址到 cache 和主存。此时 cache 控制逻辑依据地址判断此字当前是否在 cache 中：若是，则 **cache 命中**，此字立即传送给 CPU；若非，则 **cache 缺失(未命中)**，用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到cache 中。

### 读操作

CPU发出有效的主存地址：

1. 经地址变换机构，变换为可能的Cache地址；
2. 查找块表，判断所要访问的信息是否在Cache中； 
   1. 若在，则CPU直接读取Cache获取数据；
   2. 若不在，则CPU访问主存，并判断Cache是否已满；
      1. 若Cache未满，将该数据所在块从主存中调入Cache；
      2. 若Cache已满，使用某种替换机制，使用当前数据块替换 掉Cache中的某些块。

### 写操作

CPU发出有效的主存地址： 

1. 经地址变换机构，变换为可能的Cache地址；
2. 找对应的相联存储器，判断所要访问的信息是否在Cache中；
   1. 若不在，则使CPU直接写主存数据；
   2. 若在，则使用某种写策略将数据写入Cache。

### cache的命中率

命中率 = 访问信息在Cache中的次数 / 访问总次数

影响命中率的主要因素

* Cache 容量：
  * 过小时，局部信息装不完，命中率低。 
  * 过大时，对提高效率不明显，且成本高。
* Cache中块的大小： 一般用一个主存周期所能调出的单元数（字或字节）作 为一个块大小。

Cache/主存系统的平均访问时间$t_a$为
$$
t_a = ht_c + (1-h)t_m
$$

* tc ——命中时的cache访问时间

* tm ——未命中时的主存访问时间
* h ——命中率

设 $r = t_m/t_c$ 访问效率为
$$
e = \frac{t_c}{t_a} = \frac{t_c}{ht_c + (1-h)t_m} = \frac{1}{h + (1-h)r} = \frac{1}{r + (1-r)h}
$$
平均访问时间同样也可以计算为
$$
t_a = t_c/e
$$

### 地址映射

cache 与主存的数据交换是以块为单位。为了把主存块放到 cache 中，必须应用某种方法把主存地址定位到 cache 中，称为**地址映射**。“映射”一词的物理含义是确定位置的对应关系，并用硬件来实现。这样当 CPU 访问存储器时，它所给出的一个字的内存地址会自动变换成 cache 的地址，即 **cache 地址变换**。

#### 全相联映射方式

cache 的数据块大小称为行，用 $L_i$ 表示，其中 $i=0,1,2,…,m–1$，共有 $m=2^r $行。主存的数据块大小称为块，用 $B_j $ 表示，其中 $ j=0,1,2,…,n–1$ ，共有 $n=2^s $块。行与块是等长的，每个块(行)由 $k=2^w$ 个连续的字组成，字是 CPU 每次访问存储器时可存取的最小单位。

主存中的任意字块可调进cache的任一行中；

当主存的数据块调入Cache中时，该块的块号（主存标记） 保存于调入Cache行的对应标记位（即块表中）

> 块表的大小应为$2^c×m$位，c为行地址长度，m为块地址长度

在全相联映射中，将主存中一个块的地址(块号)与块的内容(字)一起存于 cache 的行
中，其中块地址存于 cache 行的标记(tag)部分中。这种带全部块地址一起保存的方法，可使主存的一个块直接复制到 cache 中的任意一行上，非常灵活。

![image-20220620181718030](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201817114.png)

特点：

* 优点：
  * 灵活性好(最理想)，Cache中只要有空行，就可以调入所需要的主存数据块；
* 缺点：
  * 成本高：标记位为m位，使cache标记容量变大；
  * 速度太慢：访问cache时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在cache中；
* 一般较少使用。

#### 直接映射

主存中的每一块数据只能调入Cache的特定行中；

地址映射函数为
$$
i = j\mod 2^c
$$
![image-20220620184431080](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201844159.png)

地址格式：

* 主存共$2^n$个单元，分成$2^m$个块，每块单元数为$2^b$个：主存地址为m+b位；
* Cache空间分成$2^c$行，每行大小也应为$2^b$单元：Cache地址为c+b位；
* 直接映射中主存块与Cache行的关系：
  * 主存的$(2^m/ 2^c)= 2^{m-c}$个块映射于Cache的同一行；
  * 主存地址中的c位决定该主存块对应的Cache行，m-c位为 主存标记；
  * 块表的大小应为$2^c×(m-c)$位；
  * 主存的地址格式为：![image-20220620184925945](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201849021.png)

**特点**：

* 一个主存块只能调入cache的一个特定行中 。
* 优点：该映射函数实现简单，查找速度快；
  * 主存地址的中间c位即为Cache的行地址；
  * 在对应的块表中使用高t位地址进行比较，决定是否命中；
* 缺点：灵活性差；
  * 主存的2t个字块只能对应唯一的Cache字块，即使Cache 中别的字块空着也不能占用。

![image-20220620185701996](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201857079.png)

若CPU发出的主存地址为0000 01 001；

1. 先取高4位地址（主存标记0000）送往比较器的一端；
2. 再用中间的2位地址（Cache行号01），在块表中取出该单 元中保存的主存标记送往比较器的另一端；
3. 若二者相等，则为命中，直接访问Cache的第01行中地址 为001的单元，读取数据；
4. 若二者不相等，则为未命中；

#### 组相联映射

组相联映射是直接映射和全相联映射的一种折中方案。

映射关系：将Cache中的行等分为若干组，主存中的每一块只能映射 到Cache的特定组中，但是可调入到该组的任一行中；

组间为直接映射，组内为全相联映射。

设Cache共u组，每组v行，则映射函数如下
$$
q = j \mod u
$$
当Cache的一组包含r行时，通常称为**r路组相联映射**。

![image-20220620195000670](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201950729.png)

特点：

* 灵活性：比直接映射灵活（主存可映射到组内任一块）；
* 快速性：比全相联比较次数少，只需组内全部比较；

![image-20220620195959199](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201959278.png)

### 替换策略：

#### 最不经常使用(LFU)算法

* 替换原则：将**一段时间内**被访问次数最少的那行数据替换出去；
* 使用方法
  * 每行设置一个计数器，从0开始计数;
  * **每访问一次， 被访行的计数器增1;**
  * 当需要替换时，将计数值最小的行换出，同时将这些行的计数器都清零。
* 特点：这种算法将计数周期限定在对这些特定行两次替换之间的间 隔时间内，**不能严格反映近期访问情况。**

#### 近期最少使用(LRU)算法

* 替换原则：将近期内长久未被访问过的行替换出去。
* 使用方法
  * 每行也设置一个计数器;
  * 每访问一次，被访行的计数器清零，其它各行计数值1；
  * 当需要替换时，将计数值最大的行换出。
* 特点：这种算法保护了刚拷贝到cache中的新数据行，使Cache的使用率较高。

#### 随机替换算法

* 替换原则：从特定的行位置中随机地选取一行换出。
* 特点：在硬件上容易实现，且速度也比前两种策略快。但降低了命中率和cache工作效率。

### 写策略

#### 写回式

* 写入策略：只修改cache的内容，而不立即写入主存；只有当此行被换出时才写回主存。
* 优点：减少了访问主存的次数
* 缺点：存在Cache与主存不一致性的隐患。

> 实现该方法时，cache行必须配置一个修改位，以反映此行是否被CPU修改过。

#### 全写式

>  这种策略又称写透式

* 写入策略：cache与主存同时发生写修改，因而较好地维护了cache与主存的内容的一致性。cache中每行无需设置一个修改位以及相应的判断逻辑。
* 缺点：降低了cache的功效。

#### 写一次法

* 写入策略：
  * 基于写回法，并结合全写法的写策略;
  * 写命中与写未命中的处理方法与写回法基本相同， 只是第一次写命中时要同时写入主存。

>  第一次写命中时，启动一个主存的写周期，其目的是 使其它Cache可以及时更新或废止该块内容，这便于 维护系统全部cache的一致性

# 指令系统

## 操作码

两地址指令的分类：

* SS（存储器-存储器）
* RR  这种指令结构常用于**算术逻辑运算**类指令
* RS

### 操作码扩展

![image-20220620210635102](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202106203.png)

### 指令字长度

**机器字长**：运算器一次能处理的二进制数的位数。机器指令的长度直接决定着CPU运算的精度和直接寻址能 力的大小；

**指令字长**：一个指令字中包含二进制代码的位数； ¡指令字长由操作码长度、操作数长度和个数共同决定。指令有半**字长、单字长、双字长、多字长**等不同的长度类型；指令系统可分为等长指令字结构、变长指令字结构两种。

## 寻址方式

### 指令寻址

* 顺序寻址方式：当程序按顺序执行时的指令寻址方式；
  * 必须用程序计数器记录所要执行指令的存放单元地址；
  * 一般做顺序加1的操作；
  * 程序计数器又称指令指针寄存器；
* 跳跃寻址方式：当程序转移执行时的指令寻址方式；程序计数器的内容由本条指令给出，而不是顺序改变。

### 操作数的寻址方式

* 隐含寻址
* 立即寻址
* 直接寻址
* 间接寻址
* 寄存器寻址
* 寄存器间接寻址
* 偏移寻址
* 堆栈寻址；

![image-20220620211148581](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202111661.png)

#### 偏移寻址

**相对寻址**： 隐含引用的专用寄存器是程序计数器(PC)，即 EA=A+(PC)，它是当前 PC
的内容加上指令地址字段中 A 的值。一般来说，地址字段的值在这种操作下被看成 2 的补码数的值。因此有效地址是对当前指令地址的一个上下范围的偏移，它基于程序的局部性原理。使用相对寻址可节省指令中的地址位数，也便于程序在内存中成块搬动。
**基址寻址** ：被引用的专用寄存器含有一个存储器地址，地址字段含有一个相对于该地
址的偏移量(通常是无符号整数)。寄存器的引用可以是显式的，也可以是隐式的。基址寻址也利用了存储器访问的局部性原理。后面讲到的段寻址方式中，就采用了段基址寄存器，它提供了一个范围很大的存储空间。

**变址寻址** ：地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，**与基址寻址刚好相反**。但是二者有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如，主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时值 A 存入指令地址字段，再用一个变址寄存器(初始化为 0)。每次操作之后，变址寄存器内容增 1。此时，EA=A+(R)，R←(R+1)。

> 基址寻址把 **寄存器**中的作为基础，指令中给出偏移量
>
> 变址寻址把 **指令中的地址**作为基础，寄存器给出偏移量

#### 段寻址

微型机中采用了段寻址方式，例如，它们可以给定一个20 位的地址，从而有 220=1MB 存储空间的直接寻址能力。为此将整个 1MB 空间存储器按照最大长度 64KB 划分成若干段。在寻址一个内存具体单元时，由一个基地址再加上某些寄存器提供的 16 位偏移量来形成实际的 20 位物理地址。这个基地址就是 CPU 中的段寄存器。在形成 20 位物理地址时，段寄存器中的 16 位数会自动左移 4 位，然后与 16 位偏移量相加，即可形成所需的内存地址。**这种寻址方式的实质还是基址寻址。**

![image-20220620211746817](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202117888.png)

# 中央处理器

## CPU的功能

CPU（中央处理器）：控制程序按设定方式执行；

CPU的主要功能： 

* 指令控制：控制程序的执行顺序；*顺序寻址、跳跃寻址*
* 操作控制：产生和发送各操作信号；*对指令操作码译码后产生控制信号*
* 时间控制：控制指令、或操作的实施时间；*维持各类操作的时序关系*
* 数据加工：对数据进行算术逻辑运算；*由ALU完成具体的运算*

![image-20220620212327176](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202123291.png)

## 指令周期

* 指令周期：CPU从内存中取出一条指令，并执行的时间总和
* CPU周期：又称机器周期，一般为从内存读取一条指令字的最短时间；一个CPU周期可以完成CPU的一个基本操作。
* 时钟周期：也叫节拍脉冲或T周期，是计算机处理操作的基本时间单位。

![image-20220620212637023](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202126098.png)

> 不同指令的指令周期所包含的 时钟周期个数不一定相同。

### MOV R1, R2

<img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202130085.png" alt="image-20220620212746096" style="zoom:100%" align="center"/>

### LAD R1, ADDR

从数据存储器单元取出数据装入通用寄存器R

三个CPU周期： 

1. 取指周期 

2. 间址周期：从IR的地址码字段获 取操作数地址；（或 者通过计算获得EA） 
3. 执行周期：访存获取操作数送入 通用寄存器R1；

![image-20220620213324658](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202133732.png)

### ADD R1 , R2

取指周期（略） 

执行周期

* 从寄存器R1、R2中取出数据，作为源操作数； 
* 将两数据送往ALU，并使ALU进行加运算；
* 结果保存到R1中

### STO R2 , (R3)

STO指令是RS型指令，需要3个CPU周期。存数指令 R2 -> [R3]

取指周期（略）

间址周期：根据R3中的地址寻址所要访问的存储单元；

执行周期：将寄存器R2中的数据送入指定的存储单元；

### JMP

两个周期：

取指

执行：直接给PC赋值

## 微指令和微程序

* 控制存储器（CM）：存放实现全部指令系统的微指令；由只读存储器构成，要求速度快，读出周期短。

* 微指令寄存器：存放由控制存储器读出的一条微指令信息；
  * 微地址寄存器：决定将要访问的下一条微指令的地址；
  * 微命令寄存器：保存一条微指令的操作控制字段和判别测试字 段的信息。

* 地址转移逻辑

顺序控制部分的P1、P2为判别测试标志；

* 若为00，则顺序寻址微指令；
* 若为01、10，则跳跃寻址微指令。

微操作在执行部件中是最基本的操作。由于数据通路的结构关系，微操作可分为相容
性和相斥性两种。所谓**相容性的微操作**，是指在同时或同一个 CPU 周期内可以并行执行的微操作。所谓**相斥性的微操作**，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。

### CPU周期与微指令周期关系

**微指令周期**：读出微指令的时间加上执行该条微指令的时间；串行方式的微程序控制器中的概念；

一般来讲，一个微指令周期时间设计得**恰好和CPU 周期时间相等**。

![image-20220620222820709](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202228777.png)

### 机器指令与微指令的关系

一条机器指令对应一个微程序，一个微程序由若干条微指 令序列组成的；一条机器指令所完成的操作划分成若干条微指令来完成， 由微指令进行解释和执行。

从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者与内存有关，后者与控制存储器有关。

每一个CPU周期对应一条微指令。

### 微程序设计技术

#### 微命令编码

**直接表示法**：操作控制字段中的每一位代表一个微命令；

* 优点：简单直观，其输出可直接用于控制，执行速度快；

* 缺点：微指令字较长，因而使控制存储器容量较大。

**编码表示法**：将微指令操作控制字段划分为若干个子字段；每个子字段的所有微命令进行统一编码；每个子字段的不同编码表示不同的微命令；

![image-20220620223233590](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202232668.png)

* 遵循原则：
  * 把**相斥的微命令**划分在同一个字段中，相容的微命令划分 在不同字段；
  * 字段的划分应与数据通路结构相适应；
  * 每个子字段应留出一个**空操作**状态；
  * 每个子字段所定义的微命令不宜太多；
* 优点：可大大缩短微指令字长；
* 缺点：需要微命令译码，故微程序的执行速度稍稍减慢。

#### 微地址的形成方法

**计数器方式**：同CPU中程序计数器产生机器指令地址的方法相类似。

* 优点：微指令的顺序控制字段较短，微地址产生机构简单。
* 缺点：多路并行转移功能较弱，速度较慢，灵活性较差。

**多路转移方式**：可根据“判别测试”标志和“状态条件”信息选定某 一个候选微地址的方法。

* 特点：能以较短的顺序控制字段配合，实现多路并行转移， 灵活性好，速度较快；
* 但转移地址逻辑需要用组合逻辑方法设计

#### 微指令格式

**水平型微指令**：一次能定义并执行多个并行操作微命令的微指令；一般由操作控制字段、判别测试字段、下地址字段三部分构成；根据控制字段编码方式的不同，可分为全水平型、字段译码法水平型、直接和译码相混合的水平型三种微指令。

**垂直型微指令**：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能；垂直型微指令的结构类似于机器指令的结构。在一条微指令中只有 1～2 个微操作命令，每条微指令的功能简单，因此，实现一条机器指令的微程序要比水平型微指令编写的微程序长得多。它是采用较长的微程序结构去换取较短的微指令结构。

1. 水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。

2. 水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。

3. 由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反，微指令字较短而微程序长。

4. 水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。



## 流水CPU

![image-20220620224644452](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202246529.png)

### 数据相关

在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是数据相关的。

* 写后读(RAW)相关；应当前一个指令写入数据再读数据，流水线导致未写入就读出。
* 读后写(WAR)相关；需要先读出内容并写入，之后再修改之前读出的内容，流水线导致先修改再读。
* 写后写(WAW)相关。两个都要写入，但之后的先完成，先写入，发生错误。

# 总线系统

构成计算机系统的互联机构，是系统内各功能部件之间进行 信息传送的公共通路。

**总线宽度**：一次总线操作中，最多可传送的数据位数。

**总线周期**：一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T=1/f

**总线带宽**：单位时间内通过总线的数据位数，总线的数据传输率；单位一般为MB/s。

**单总线结构**：系统内的所有部件均由系统总线连接；

**双总线结构**：系统内的所有部件均由系统总线连接；在CPU和主存之间再 专门设置了一组高速的存储总线。

**三总线结构**：系统总线负责连接CPU、主存、I/O通道；存储总线负责连接 CPU与主存；I/O总线负责连接各I/O适配器。

## 总线的仲裁

* 集中式：由中央仲裁器决定总线使用权的归属。

* 分布式：多个仲裁器竞争使用总线。

### 集中式

![image-20220620224812519](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202248599.png)

> 计数器定时查询方式：设备的优先权由计数值决定，计数值为0时同链式查询方式；
>
> 每次计数可以从“0”开始，也可以从中止点开始。如果从“0”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。计数器的初值也可用程序来设置，这就可以方便地改变优先次序，显然这种灵活性是以增加线数为代价的。

![image-20220620225551800](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202255904.png)

### 分布式

分布式仲裁不需要中央仲裁器，由分布在各部件中的多个仲裁 器竞争使用总线。

每个潜在的主模块都有自己的仲裁器和唯一的仲裁号，通过仲 裁总线上仲裁号的比较，决定可占用总线的部件。

1. 某部件有总线请求时，将其仲裁号发送到共享仲裁总线上；
2. 每个仲裁器将仲裁总线上得到的号与自己的号进行比较；
3. 如果仲裁总线上的号大，则它的总线请求不予响应，并撤 消它的仲裁号；
4. 最后，获胜者的仲裁号保留在仲裁总线上。

分布式仲裁是以**优先级仲裁策略**为基础。

![image-20220620225243489](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202252578.png)

.

# 外围设备

## 磁盘存储设备

在磁表面存储器中，信息的读写是利用磁头来进行的；

* 磁头：由软磁材料做铁芯，绕有读写线圈的电磁铁。
* 写操作：原理：电-磁变换；利用磁头写线圈中的脉冲电流，在磁表面每个存储元上形 成不同的磁化状态；
* 读操作：原理：磁-电变换；利用磁头读线圈， 将磁表面每个存储 元上的不同剩磁状 态转换成电信号读出；

> 硬磁盘按盘片结构，分成可换盘片式与固定盘片式两种；磁头也分为可移动磁头和固定磁头两种。

**可移动磁头固定盘片的磁盘机** 特点是一片或一组盘片固定在主轴上，盘片不可更换。盘片每面只有一个磁头，存取数据时磁头沿盘面径向移动。

**固定磁头磁盘机** 特点是磁头位置固定，磁盘的每一个磁道对应一个磁头，盘片不可更换。优点是存取速度快，省去磁头找道时间，缺点是结构复杂。

**可移动磁头可换盘片的磁盘机** 盘片可以更换，磁头可沿盘面径向移动。优点是盘片可以脱机保存，同种型号的盘片具有互换性。

**温彻斯特磁盘机** 温彻斯特磁盘简称**温盘**，是一种采用先进技术研制的可移动磁头固定盘片的磁盘机。它是一种密封组合式的硬磁盘，即磁头、盘片、电机等驱动部件乃至读写电路等组装成一个不可随意拆卸的整体。工作时，高速旋转在盘面上形成的气垫将磁头平稳浮起。优点是防尘性能好，可靠性高，对使用环境要求不高，成为最有代表性的硬磁盘存储器。而普通的硬磁盘要求具有超净环境，只能用于大型计算机中。

### 磁盘上信息的分布

* 记录面：磁盘片表面；一个盘片有上下两个记录面。
* 磁道：记录面上一系列同心圆；
  * 最外圈为0磁道 ，依次为1、2、……、N磁道；
  * 每个磁道的存储容量均相同；
  * 不同盘片的相同磁道构成一个柱面；
* 扇区：同心圆上的一段磁道区域；每个扇区的存储容量也相同。

![image-20220621090432994](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210904391.png)

### 技术指标

* 存储密度

  * 道密度：沿磁盘半径方向单位长度上的磁道数；单位：道/英寸。

  * 位密度：磁道单位长度上能记录的二进制代码位数；单位：位/英寸。注意：每个磁道的位密度均不相同，有最高、最低位密度。

    > 0磁道的位密度为最低位密度；

  * 面密度：位密度和道密度的乘积；单位：位/平方英寸。

* 存储容量：一个磁盘存储器所能存储的字节总数；

  > 存储容量=记录面数×每面磁道数×磁道容量

  * 非格式化容量：磁记录表面可以利用的磁化单元总数。
  * 格式化容量：按照某种特定的记录格式所能存储信息的总量，也就是用户可以真正使用的容量。格式化容量一般是非格式化容量的60%—70%。

* 平均存取时间：从读/写指令发出到开始第一笔数据读/写时所用的平均时间

  * 平均访问时间近似等于平均寻道时间+平均等待时间，即平均寻址时间。

  * 平均等待时间：与磁盘转速有关，是磁盘旋转一周时间的一半。

  * $$
    T_a = T_s + \frac{1}{2r} + \frac{b}{rN}
    $$

    Ts平均寻道时间，b传送字节数，N每磁道字节数，r转速。

    1/2r 平均等待时间；b/rN 数据**传输时间**

* 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数；

  * 设磁盘旋转速度为每秒n转，磁道容量为N个字节：数据传输率Dr= n × N（字节/秒）
  * 设某磁道位密度为D字节/英寸，磁盘转速为v英寸/秒，则数据传输率Dr= D × v （字节/秒）


有关描述

* 内外径说的都是 **直径**

编址例子：

![image-20220621092504834](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210925911.png)

# 输入输出系统

## 程序查询方式

**工作过程**：CPU传送数据之前先检查外设的状态，若没有准备好，则继续查询等待，直至外设就绪即进行数据传送。

**硬件要求**：只需接口电路的状态、数据口，不需增加其他控制电路。

**特点**：CPU主动查询，程序控制数据传送过程，简单易行；每次查询之后只能传送一个字或一个字节的数据，数据传输率不高，CPU时间浪费较多。

**适用场合**：CPU不太忙且对传送速度要求不高的系统。

### 统一编址方式

将I/O系统与主存系统作为一个整体进行编址

**优点**：访问I/O端口可使用访存指令，操作类型多样使用灵活；I/O端口有较大的编址空间；

**缺点**：占用主存空间，使实际主存容量减小；I/O访问的指令字长较长，执行速度慢。

### 独立编址方式

将/O系统与主存系统分别编址；

**特点**：I/O端口地址不占用主存空间；使用专用的I/O指令，指令字长短，执行速度快；与主存空间区分容易。

![image-20220621093936528](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210939620.png)

> 可通过改变查询顺序修改设 备的优先权；CPU工作效率低；

## 程序中断

**工作过程**：CPU有传送要求时，启动外设后可处理其他事件，当外设准就绪后，通过中断的方式和CPU完成数据传送工作。

**硬件要求**：需要附加的中断控制电路。

**特点**：一定程度上实现了CPU和外设的并行工作；中断操作过程增加了软硬件的开销，且每次数据传送只能传送一个字或一个字节的数据，数据传送效率低

**适用场合**：CPU与慢速外设之间的数据传送。

> 机器内部原因导致出错引起的中断叫内中断，也叫**异常**。外部设备请求服务的中断叫**外中断**。

### 流程

1. 中断请求：CPU在结束一个指令周期后，检测中断请求信号； 
2. 中断响应
   1. 关中断； 
   2. 保护断点现场； 
   3. 判断中断源，获取中断向量；
   4. 根据中断向量转入中断服务程序执行；
3. 中断服务
   1. 保护CPU现场；
   2. 执行中断服务程序；
   3. 开中断；
   4. 恢复CPU现场；
4. 中断返回：恢复断点现场，返回主程序继续执

### 中断服务程序入口地址的获取

**向量中断 **：中断机构自动将相应中断源的中断向量地址送入 CPU，包括段地址和段内偏移地址， 共4个字节的内容

CPU响应中断时，将中断源对应的中断向量送入CS（段地 址）、IP（段内偏移地址）寄存器中，以跟踪中断服务程序 的执行。

一般而言，系统中所有的中断向量都按顺序存放在内存指定位置的一张**中断向量表**中，当 CPU 识别出某中断源时，由硬件直接产生一个与该中断源对应的中断向量地址，以便能快速在中断向量表中找到并转入中断服务程序入口。

![image-20220621094643232](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210946334.png)

> 上图可知，中断类型号(n) × 4 ＝ 中断向量在表中的偏移地址

![image-20220621094754589](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210947669.png)

### 程序中断方式的基本 I/O 接口

![image-20220621094845232](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210948331.png)

### 单级中断系统

所有的中断源都属于同一个级别，不允许有中断嵌套；

![image-20220621095013634](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210950724.png)

1. 向量中断：由硬件直接产生一个与该中断源对应的向量地址；

   向量地址——中断源的中断服务程序入口地址；

   要求：在硬件设计时考虑所有中断源的向量地址。

2. 位移量中断：由硬件直接产生一个位移量，该位移量加上CPU中某寄存器中的基地址，得到中断处理程序的入口地址。

3. 向量地址转移：由硬件直接产生一个该中断源对应的固定地址码，该地址码中存放可转入中断服务程序的入口地址。

### 多级中断

根据各中断事件的轻重缓急程度不同而分成若干级别，每一中断级分配给一个优先权。一般说来，优先权高的中断级可以打断优先权低的中断服务程序，以程序嵌套方式进行工作。

> 多级中断中需要进行优先权的控制和判断。

![image-20220621095303010](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953108.png)

改变优先级的方法：**修改屏蔽字**

欲使第2级中断的优先权高于第3级：则可设置第3级中的屏蔽字设为：00001011第2级中的屏蔽字设为：00001111

![image-20220621095351474](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953558.png)

### 不可屏蔽中断NMI

由CPU的NMI引脚引入该中断请求，CPU得到该中断请求立即响应，不需要CPU发响应信号；

中断类型号固定为2；

中断优先权高于可屏蔽中断INTR，一般用于系统对紧急情况的处理，用户不能使用；

常见的NMI中断：

* 系统RAM奇偶校验错、
* I/O通道校验错、
* 协处理器出错等。

### 可屏蔽中断INTR

由CPU的INTR引脚引入该中断请求；

* 该中断请求只有在CPU的中断允许标志位IF=1时，CPU才会通过发回响应信号的方式响应；
* CPU对INTR中断的响应控制可由STI（允许响应INTR中断）、CLI（禁止响应INTR中断）两条指令完成。

此类中断的中断类型号由**中断源**提供；

常见的INTR中断：

* 外部设备的中断请求，如I/O设备的数据传送请求，用户可自行设计；

### 指令中断INTN

由CPU执行在程序中预先安排好的中断指令引起的；该中断是可预期的、且不可屏蔽的；

处理该中断时，**CPU不需要发响应信号**；

指令的操作数字段（n）即为中断类型号；

* 中断类型号的范围为5≤n≤255；

这类中断包括BIOS中断、DOS中断以及一些未定义的自由中断（可由系统扩充或根据应用需要自定义）。

### 异常中断

由CPU内部的突发事件引起的中断，是不可屏蔽中断；

其中断类型号固定；

* 除法错中断一一类型号为0；执行除法指令时，除数为0，或除得的商大于规定位数；
* 单步中断——类型号为1；
* 断点中断——类型号为3；
* 溢出中断——类型号为4；

该类中断的实质：由CPU运行过程中的突发事件引起系统在适当位置**自动添加一条中断指令**，然后由CPU执行该指令引起的中断；

同指令中断一样，处理该中断时，**CPU不需要发响应信号**。

![image-20220621100318360](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211003449.png)

## 直接内存访问

**工作过程**：CPU分配总线使用权之后，在硬件DMA控制器（DMAC）的控制下完成存储器与高速外设之间的大量数据的传送。

**硬件要求**：需要相应的DMA控制器及数据通路，电路结构复杂，硬件开销大。

**特点**：数据传送不需要经过CPU，直接由硬件控制；外设与存储器之间的数据传送量大。

**适用场合**：：包含有高速外设的系统中。

DMA（直接内存访问）方式磁盘与主存之间的数据传送，完全由硬件控制执行I/O交换的工作方式；DMAC完全接管系统总线的控制权，利用总线控制数据在主存和外设之间的直接传送，所交换的数据不经过CPU。

**特点**：速度快，但硬件复杂度高。

DMA方式中，DMAC的工作：接受外设的DMA请求，并提交给CPU；接管总线的控制权，控制主存和外设之间的数据传送；完成数据传送后，交还总线使用权。

DMA传送时，**CPU不能使用总线**，会影响CPU的工作效率； 当CPU需要访存，或者访问外设时，程序会阻塞； 可使DMAC与CPU**分时复用总线**；

### 停止CPU访问方式

工作过程：DMA传送期间，由DMAC长期占用总线，CPU不能访存，只有DMA传送结束时才将总线归还给CPU使用；

特点：控制简单，适于高速外设的数据成组传送；内存使用效率不高。（一般外设的读写周期远大于主存的存取周期）

### 周期挪用方式

工作过程：每次DMA传送，都是通过外设挪用一个或几个主存周期， 分别完成数据的成块传送。

特点：主存使用效率较高，常用；

I/O 设备要求 DMA 传送时可能遇到两种情况：一种是此时 CPU 不需要访内，如 CPU
正在执行乘法指令。由于乘法指令执行时间较长，此时 I/O 访内与 CPU 访内没有冲突，即I/O 设备挪用一两个内存周期对 CPU 执行程序没有任何影响。另一种是 I/O 设备要求访内时CPU 也要求访内，这就产生了访内冲突，在这种情况下 I/O 设备访内优先，因为 I/O 访内有时间要求，前一个 I/O 数据必须在下一个访内请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一两个内存周期，意味着 CPU 延缓了对指令的执行，或者更明确地说，在 CPU执行访内指令的过程中插入 DMA 请求，挪用了一两个内存周期。

### DMA与CPU交替访存方式

如果 CPU 的工作周期比内存存取周期长很多，则采用交替访内的方法可以使 DMA 传
送和 CPU 同时发挥最高的效率；

假设 CPU 工作周期为1.2μs，内存存取周期小于 0.6μs，那么一个 CPU 周期可分为 C1 和 C2 两个分周期，其中 C1专供 DMA 控制器访内，C2 专供 CPU 访内。这种方式**不需要总线使用权的申请、建立和归还过程**，总线使用权是通过 C1 和 C2 分时控制的。

> CPU 和 DMA 控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控
> 制寄存器。

工作过程：将CPU的工作周期一分为二，分别用于DMA和CPU访存；

特点：对主存的访问时间不会发生冲突，也不需要总线控制权的申请建立和归还过程；

也称为“透明DMA方式”；DMA传送不影响CPU的工作；

![image-20220621101304899](https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211013972.png)

### DMA数据传送过程

1. DMA请求
   DMAC向CPU请求总线使用权；

2. DMA响应
   CPU给DMAC分配总线使用权；

3. DMA传送
   DMAC寻址外设和存储器；

   DMAC控制外设与主存之间的数据传送，并检测是否传送结束；

4. DMA结束
   ODMAC归还总线使用权。

### 和中断控制方式的区别

* 数据传送的实现方式
  中断——程序传送；DMA——硬件实现；
* CPU响应请求的时间
  中断——一个指令周期结束；DMA——一个总线周期结束；
* 请求的目的
  中断——CPU的服务；DMA——总线的使用权；
* 是否需要保护现场
  中断——需要；DMA——不需要（CPU不参与数据传送）；
* DMA的优先权高于中断的优先权。

## 通道方式

**工作过程**：CPU将IO控制的权利下放给通道，由通道统一管理所有的输入输出操作。

**硬件要求**：需要IO通道（也称IO处理器，IOP）；通道是一个具有特殊功能的处理器。

**特点**：硬件代价较高；lO传送的效率高，并且减轻了CPU的工作负担。

**适用场合**：高性能要求的系统中。
