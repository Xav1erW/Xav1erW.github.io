{"meta":{"title":"Xav1er Blog","subtitle":"","description":"","author":"Xav1er","url":"https://xav1erw.github.io","root":"/"},"pages":[{"title":"","date":"2022-06-18T08:31:37.828Z","updated":"2022-06-18T08:31:37.828Z","comments":false,"path":"categories/index.html","permalink":"https://xav1erw.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-18T08:31:56.719Z","updated":"2022-06-18T08:31:56.719Z","comments":false,"path":"tags/index.html","permalink":"https://xav1erw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"形式语言与自动机复习","slug":"Notes/形式语言与自动机复习","date":"2022-06-17T16:00:00.000Z","updated":"2022-06-19T12:21:37.156Z","comments":true,"path":"2022/06/18/Notes/形式语言与自动机复习/","link":"","permalink":"https://xav1erw.github.io/2022/06/18/Notes/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"形式语言与自动机 字母表 注意区分\\(\\epsilon\\) 和 \\(\\varnothing\\) \\(\\epsilon\\) 是一个长度为0的句子 \\(\\varnothing\\) 是空集 乔姆斯基文法体系 0型文法 即文法 $ G(V,T,P,S)$ 称为 短语结构文法(PSG) 1型文法 对于0型文法G有 \\[ \\forall \\alpha \\to \\beta \\in P, \\quad |\\beta| \\geq |\\alpha| \\] 称为1型文法或 上下文有关文法(CSG) 2型文法 对于1型文法G有 \\[ \\forall \\alpha \\to \\beta \\in P, \\quad |\\beta| \\geq |\\alpha| 并且 \\alpha \\in V \\] 称为2型文法或 上下文无关文法(CFG) 3型文法 对于2型文法G \\[ \\forall \\alpha \\to \\beta \\in P, \\quad \\alpha \\to \\beta 具有形式\\\\ A \\to w\\\\ A \\to wA \\] 其中 \\(w \\in T^+\\) 称为3型文法或 正则文法 (RG) 文法类型 \\(\\forall \\alpha \\to \\beta\\) 0（短语结构） 无限制 1（上下文有关） \\(|\\beta| \\geq |\\alpha|\\) 2（上下文无关） \\(|\\beta|\\geq |\\alpha|\\) 并且 \\(\\alpha \\in V\\) 3（正则） \\(A \\to w\\\\A \\to wA\\) 从上到下是包含关系 正则文法最简形式 定理：L是RL充要条件是存在文法，其产生式要么形如 \\(A \\to a\\) 要么形如 \\(A \\to aB\\) 线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to wBx\\) 其中 \\(w, x \\in T^*\\) 右线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to wB\\) 其中 \\(w, x \\in T^*\\) 左线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to Bw\\) 其中 \\(w, x \\in T^*\\) 定理：左线性文法充要条件：其产生式要么形如 \\(A \\to a\\) 要么形如 \\(A \\to Ba\\) 定理：左线性文法与右线性文法等价 语言识别 回溯 遍历所有的推导 有限自动机 \\[ M = (Q, \\Sigma, \\delta, q_0, F) \\] \\(Q\\) 状态集合 \\(\\Sigma\\) 输入字母表 \\(\\delta\\) 状态转移函数 \\(q_0\\) 开始状态 \\(F\\) 终止状态 DFA 每个输入字符有确定的状态转移 即时描述 \\(\\delta (q_0, x) = q\\) 那么 \\(xqy\\) 称为一个即时描述，表示 xy是正在处理的字符串，当前到达状态q，M正准备处理y的第一个字符 \\(\\alpha \\vdash_M^n \\beta\\) 表示从即时描述 \\(\\alpha\\) 移动n次到达即时描述 \\(\\beta\\) ，上标同样可以使用 *、+ 如果 xqay 是M的一个即时描述，且 \\(\\delta (q, a) = p\\) 那么 \\(xqay \\vdash_M xapy\\) 定义 ：状态的字符串集合：从初始状态能引导状态机到达状态的字符串集合 \\[ \\text{set}(q) = \\{x|x\\in \\Sigma^*, \\delta(q_0, x)=q\\} \\] 定义：\\(R_M\\) 等价关系： \\[ \\forall x,y \\in \\Sigma^*, xR_My \\Leftrightarrow \\exists q \\in Q \\quad s.t.\\\\ x \\in \\text{set}(q) \\quad \\text{and} \\quad y \\in \\text{set}(q) \\] 上述是等价关系，能够将 \\(\\Sigma^*\\) 分成不多于 \\(|Q|\\) 个等价类 NFA 与DFA等价 从NFA到DFA NFAtoDFA 带空移动的NFA \\(\\epsilon\\) 闭包 \\[ \\epsilon-\\text{CLOSURE}(q) = \\{p|从q到p有一条标记为\\epsilon的路径\\} \\] 对状态集合同样也有闭包概念 \\[ \\hat \\delta (q,a) = \\hat \\delta (a,\\epsilon a) = \\epsilon-\\text{CLOSURE}(P)\\\\ P =\\{p|\\exists r \\in \\hat\\delta(q, \\epsilon) s.t. p \\in \\delta(r,a\\} \\\\ = \\bigcup_{r\\in \\hat \\delta(q,\\epsilon)} \\delta(r,a) \\] 由带空移动的NFA构造等价NFA 取NFA \\(M_2 = (Q, \\Sigma, \\delta_2, q_0, F_2)\\) 其中 \\[ F_2 \\left\\{ \\begin{align} &amp;F \\cup \\{q_0\\} \\quad &amp;\\text{如果} F\\cap \\epsilon-\\text{CLOSURE}(q_0)\\neq 0\\\\ &amp;F \\quad &amp;\\text{如果} F\\cap \\epsilon-\\text{CLOSURE}(q_0)= 0 \\end{align} \\right. \\] 对于 \\(\\forall (q,a) \\in Q \\times \\Sigma\\) 使 \\(\\delta_2(q,a) = \\hat \\delta_1(q,a)\\) 其实就是，写出 \\(\\hat \\delta\\) 的表，把空移动去除，按照表中集合连线，再按照上述步骤判断一下终止状态都有哪些。 如 \\(q_0\\) 的 0移动有 \\(q_0, q_1, q_2\\) ，那么局部的NFA有 graph LR q0((q0)) q1((q1)) q2((q2)) q0 --0-->q0 q0 --0-->q1 q0 --0-->q2 其余状态同理。 FA接收的语言是RG DFA转RG 构造方法 \\[ P = \\{q \\to ap | \\delta (q,a) = p\\} \\cup \\{q \\to a | \\delta (q,a) = p\\in F\\} \\] 例如： image-20220619104853348 RG转DFA 每个变量看成一个状态， 如果派生为 \\(A \\to wB\\) 的形式，那么DFA就为 A --w--&gt; B 的形式。 如果派生为 \\(A \\to w\\) 的形式，那么DFA就为 A --w--&gt; Z 的形式，其中Z代表终止状态。 可以用下式表示 \\[ \\delta(A,a) = \\left\\{ \\begin{align} &amp;\\{B|A \\to aB \\in P\\}\\cup\\{Z\\} \\quad &amp;\\text{if } A \\to a \\in P \\\\ \\\\ &amp;\\{B|A \\to aB \\in P\\} \\quad &amp;\\text{if } A \\to a \\notin P \\end{align} \\right. \\] image-20220619114104790 左线性文法转DFA 左线性文法 \\(G(V,T,P,S)\\) 无空串 FA为 \\(M=(V\\cup\\{Z\\}, T,\\delta,Z,\\{S\\})\\) 此处Z为初始状态 \\(\\forall (a,B) \\in T\\times V\\) 如果 \\(A \\to Ba \\in P\\) 那么 \\(\\delta (B,a)=A\\) 如果 \\(A \\to a \\in P\\) 那么 \\(\\delta (Z,a)=A\\) image-20220619114529002 DFA转左线性文法 预处理DFA 删除陷阱状态 图中添加Z作为文法开始变量 复制一条原本到达终止状态的弧，使其从原本状态出发到Z 构造文法 如果 \\(\\delta (A,a) = B\\) 则有 \\(B \\to Aa\\) 如果 \\(\\delta (A,a) = B\\) 且A是开始状态，则有 \\(B \\to a\\) image-20220619120727042 FA的变形 2DFA \\[ M = (Q,\\Sigma,\\delta,q_0,F) \\] \\(\\delta: \\ Q\\times \\Sigma \\to Q \\times \\{L,R,S\\}\\) image-20220619121354622 2NFA 类似2DFA Moore机 六元组 \\[ M = (Q,\\Sigma,\\Delta,\\delta,\\lambda,q_0) \\] \\(\\Delta\\) 输出字母表 \\(\\lambda: Q \\to \\Delta\\) 输出函数 ，状态 \\(q\\) 输出对应字符 image-20220619124315215 Mealy机 六元组 \\[ M = (Q,\\Sigma,\\Delta,\\delta,\\lambda,q_0) \\] \\(\\Delta\\) 输出字母表 \\(\\lambda: Q\\times \\Sigma \\to \\Delta\\) 输出函数 ，\\(\\lambda(q,a)=d\\) 表示在状态 q 读入字符 a，输出字符d Moore机和Mealy机等价 正则表达式 优先级：闭包&gt;乘&gt;加 运算律 结合律 分配律：\\(r(s+t) = rs+rt\\) 交换律：\\(r+s = s+r\\) 幂等律：\\(r+r=r\\) 零元素与空元素 \\(r+\\varnothing = r\\) \\(r\\epsilon = \\epsilon r = r\\) \\(r\\varnothing = \\varnothing r = \\varnothing\\)关于这点和上一点，看二者的定义 ，结合分配律理解 \\(L(\\varnothing) = \\varnothing\\) \\(L(\\epsilon) = \\{\\epsilon\\}\\) \\(L(\\varnothing^*) = \\{\\epsilon\\}\\) 因为 \\(L(\\varnothing^0) = \\{\\epsilon\\}\\) \\(L((r^*s^*)^* = L((r+s)^*)\\) RE与FA等价 RE转NFA 基本的例子 image-20220619154853677 image-20220619155341031 根据以上例子，给出 \\(r=r_1+r_2;\\quad r=r_1r_2;\\quad r=r_1^*\\) 构造方法 加法构造 image-20220619155635676 乘法构造 image-20220619155707763 闭包构造 image-20220619155737263 DFA转RE 预处理 给开始和终止加上X、Y状态 去掉所有不可达状态 对图操作 并弧：将从q到p的标记为\\(r_1,r_2,\\cdots,r_g\\)并⾏弧用从q到p的、标记为\\(r_1+r_2+\\cdots +r_g\\) 的弧取代这g个并⾏弧。 去状态1：如果从q到p有⼀条标记为\\(r_1\\)的弧，从p到t有⼀条标记为\\(r_2\\)的弧，不存在从状态p到状态p的弧，将状态p和与之关联的这两条弧去掉，用⼀条从q到t 的标记为\\(r_1r_2\\)的弧代替。 去状态2：如果从q到p有⼀条标记为\\(r_1\\)的弧，从p到t有⼀条标记为\\(r_2\\)的弧，从状态p 到状态p标记为\\(r_3\\)的弧，将状态p和与之关联的这三条弧去掉，用⼀条从q 到t的标记为\\(r_1r_3^ *r_2\\)的弧代替。 去状态3：如果图中只有三个状态，⽽且不存在从标记为X的状态到达标记为Y的状 态的路，则将除标记为X的状态和标记为Y的状态之外的第3个状态及其相 关的弧全部删除。 从标记为X的状态到标记为Y的状态的弧的标记为所求的正则表 达式。如果此弧不存在，则所求的正则表达式为 \\(\\varnothing\\) 正则语言表示方法转化 image-20220619161300327 正则语言的性质 泵引理 由于DFA中状态个数是有穷的， 所以在处理⼀个足够长的句⼦的过程中，必定会重复地经过某⼀个状态。 image-20220619161639784 设L为RL，那么对应有DFA \\(M = (Q,\\Sigma,\\delta,q_0,F)\\) 假设有N个状态。 那么 \\(z = a_1a_2\\cdots a_m\\quad m \\geq N\\) 由于一共N个状态，状态序列 \\(q_0,q_2,\\cdots ,q_N\\) 有N+1状态，会有两个状态重复。不妨假设 \\(q_k = q_j\\) $$ (q_0, a_1a_2a_k)=q_k \\ (q_k, a_{k+1}a_j)=q_j = q_k \\ (q_j, a_{j+1}a_m)=q_m \\ 因此i \\ (q_k, (a_{k+1}a_j)^i) = q_j=q_k $$ 因此可以理解为 \\(a_1\\cdots a_k (a_{k+1}\\cdots a_j)^i a_{j+1}\\cdots a_m \\in L(M)\\) 设 \\[ u= a_1a_2\\cdots a_k\\\\ v = a_{k+1}\\cdots a_j\\\\ w = a_{j+1}\\cdots a_m \\] 那么 \\(uv^iw \\in L\\) 由于 \\(k&lt;j\\leq N\\) 所以 \\(|uv| = j \\leq N, \\ |v|\\geq 1\\) 引理(泵引理) L为RL，则存在仅依赖于L的正整数N \\(\\forall z \\in L\\) 如果 \\(|z|\\geq N\\) 则存在u、v、w满足 z = uvw \\(|uv| \\leq N\\) \\(|v|\\geq 1\\) 对于任意整数 \\(i \\geq 0 \\quad uv^iw \\in L\\) N不大于接受L的最小DFA的状态数。 利用泵引理证明一个语言不是RL 首先假设该语言是RL，则其应该满足泵引理，选任意的N. 找到一个语言中的句子\\(z=L(|z|\\geq N)\\). 任选满足z=uvw，其中\\(|v| \\geq 1\\)，且\\(|uv|\\leq N\\)的u,v,w 找到一个\\(i\\geq 0\\)，证明使\\(uv^iw\\notin L\\). 推出矛盾说明该语言不满足泵引理，从而说明该语言不是RL。 image-20220619163240817 泵引理用来证明一个语言不是RL 不能用泵引理去证明一个语言是RL 正则语言的封闭性 定理：RL在并、乘积、闭包运算下是封闭的 定理：RL 在补运算下是封闭的。 DFA \\(M&#39;=(Q,\\Sigma, \\delta, q_0, Q-F)\\) 对应着正则语言的补集 定理：RL 在交运算下是封闭的。 正则代换 \\(\\Sigma\\quad \\Delta\\) 是两个字母表，映射 \\(f:\\Sigma \\to 2^{\\Delta^*}\\) 称为是代换，如果 \\(\\forall a \\in \\Sigma \\quad f(a)\\)是\\(\\Delta\\) 上的RL，那么称为正则代换。 先将f定义域扩展到 \\(\\Sigma^*\\) 上 \\(f(\\epsilon) = \\{\\epsilon\\}\\) \\(f(xa) = f(x)f(a)\\) 再扩展到 \\(2^{\\Sigma^*}\\) \\(f(L) = \\bigcup_{x\\in L} f(x)\\) image-20220619164535126 定理：L是Σ上的RL，那么正则代换f满足 \\(f(L)\\) 也是RL 定义：对于字母表\\(\\Sigma\\)和\\(\\Delta\\)，\\(f: \\Sigma \\to \\Delta^*\\) 如果 \\(\\forall x, y \\in\\Sigma^*\\quad f(xy) = f(x)f(y)\\) 则称为同态映射 L的同态像： \\[ \\forall L \\subset \\Sigma^*\\quad f(L) = \\bigcup_{x\\in L}f(x) \\] \\(\\forall w \\in \\Delta^* \\quad \\forall L \\subset \\Delta^*\\) 同态原像是一个集合 定义：商 \\(L_1/L_2 = \\{x|\\exists y \\in L_2 \\quad s.t.\\ xy\\in L_1\\}\\) 主要用来考虑句子后缀 Myhill-Nerode 等价关系 同样表述为 \\(xR_M y \\Leftrightarrow \\delta(q_0,x) = \\delta(q_0,y)\\) 语言确定的等价关系： \\(xR_L y \\Leftrightarrow (\\forall x \\in \\Sigma^*, xz\\in L \\Leftrightarrow yz \\in L)\\)；x,y后不管接什么串z，要么都是L的句子，要么都不是 右不变的等价关系：如果 \\(x\\ R\\ y\\) 那么 \\(\\forall z \\in \\Sigma^*\\) 必有 \\(xz\\ R\\ yz\\) \\(R_M\\) 和 \\(R_L\\) 都是右不变的。 R是 \\(\\Sigma^*\\) 上的等价关系， \\(\\Sigma^* / R\\) 表示等价关系分开的集合数量，称为\\(R\\)关于 \\(\\Sigma^*\\) 的指数 \\(R_M\\) 的分割更细致，因此称 \\(R_M\\) 是 \\(R_{L(M)}\\) 的加细 Myhill-Nerode定理：如下三个命题等价 L是RL L是\\(\\Sigma^*\\) 上某一个具有有穷指数的右不变等价关系R的某些等价类的并 \\(R_L\\) 具有有穷指数 证明该语言不是RL最方便的方法就是证明\\(R_L\\)的指数是无穷的 例： 证明 \\(\\{0^n1^n|n\\geq 0\\}\\)不是RL image-20220619171833963 极小化DFA 算法步骤 标记终止状态和其余非终止状态可区分 从第一个状态开始迭代标注它与其余状态是否可区分： 如果状态对转移后的关联状态对可区分，那么该状态对可区分 如果关联状态对没有被标注，那么将该关联状态加入关联状态链表（基于一个双向链表实现）（对状态列表的保存有冗余设计，每次向前添加时，实际会新建链表，即如果有一链表 q0-&gt;q3-&gt;q2，那么 q3-&gt;q2，q0-&gt;q3-&gt;q2都会被保存） 如果迭代到的状态对被标记，那么寻找以该状态对开始关联列表，并将关联列表上之后的状态都标记上 上述步骤会标记完成可区分状态表，接着合并不可区分状态，将不可区分的状态放入一个集合中： 遍历可区分状态表中的所有状态对 如果两状态对不可区分，那么遍历最终的不可区分状态 如果能在不可区分状态里找到某个集合包含状态对中的一个元素，那么将该状态对元素添加到这个集合中 如果不能，则从状态对元素新建一个集合，加入不可区分状态中。 对于上述得到的新的可区分状态（每个可区分状态可能包含多个不可区分状态），逐个遍历其中的不可区分状态，得到最终针对新可区分状态的状态转移函数。 image-20220619172230661 正则语言判定定理 定理：DFA \\(M=(Q, \\Sigma, \\delta, q_0,F)\\) 对应语言为非空的充要条件是： \\[ \\exists x \\in \\Sigma^*, \\quad |x|&lt;|Q|, \\delta(q_0,x) \\in F \\] 定理：DFA \\(M=(Q, \\Sigma, \\delta, q_0,F)\\) 对应语言为无穷的充要条件是： \\[ \\exists x \\in \\Sigma^*, \\quad |Q|\\leq|x|&lt;2|Q|, \\delta(q_0,x) \\in F \\] 可以联系泵引理 定理：设DFA \\(M_1=(Q_1,\\Sigma,\\delta_1,q_{01},F_1)\\)，DFA \\(M_2=(Q_2,\\Sigma,\\delta_2,q_{02},F_2)\\)，则存在判定M1与M2是否等价的算法。 定理：设L是字母表上的RL，对任意\\(x\\in \\Sigma^*\\)，存在判定x是不是L的句子的算法。 上下午无关语言 定义 派生树： 顶点的顺序：V1，V2是派生树T的两个不同顶点，如果存在顶点v，v至少有两个儿子，使得v，是v的较左儿子的后代，v，是v的较右儿子的后代，则顶点v在顶点v2的左边，顶点v2在顶点v，的右边。 派生树的结果： 派生树T的所有叶子顶点从左到右依次标记为X1，X2，…，X，则称符号串X1X2.…Xn是T的结果。 句型a的派生树：“结果为a的派生树”。·派生树的结果可以是句子，也可以是句型 一个文法可以有多棵派生树，它们可以有不同的结果。 设CFG \\(G=(V，T，P，S)\\)，\\(S\\Rightarrow^* \\alpha\\)的充分必要条件为G有一棵结果为$ $的派生树。 定义： 最左派生：\\(\\alpha\\)的派生过程中，每一步都是对当前句型的最左变量进行替换 左句型：最左派生得到的句型可叫做左句型。 最右归约：与最左派生相对的归约叫做最右归约。 定义： 最右派生：\\(\\alpha\\)的派生过程中，每一步都是对当前句型的最右变量进行替换 右句型：最右派生得到的句型可叫做右句型。 最左归约：与最左派生相对的归约叫做最左归约。 最右派生、右句型、最左归约又称为规范派生、规范句型、规范规约 二义性 字符串对应两个及以上派生树，则文法有二义性 如果语言L不存在非二义性文法，则称L是固有二义性的，又称L是先天二义性的。 无用符号 能出现字符串的派生过程中的有用，否则无用。 删除无用符号 删除派生不出终极符号行的变量 image-20220619175742158 删除不出现在任何句型中的语法符号 image-20220619175910894 依次使用上述算法(先删派生不出终极符号行的变量，再删不出现在任何句型中的语法符号)就可删除无用符号 空产生式 形如 \\(A\\to \\epsilon\\) 求CFG G的可空变量集 image-20220619180121022 去除空产生式 首先求可空变量集U 构造 \\(P&#39;\\) \\(\\forall A \\to X_1X_2\\cdots X_m \\in P\\) 将 \\(A\\to \\alpha_1\\alpha_2\\cdots \\alpha_m\\) 放入 \\(P&#39;\\) ， 如果\\(X_i \\in U,\\quad \\alpha_i = X_i\\text{ or }\\epsilon\\) ；如果 \\(X_i\\notin U\\quad \\alpha_i = X_i\\) image-20220619180650451 单一产生式 形如 \\(A \\to B\\) 消除：用\\(B\\) 的表达式直接代替\\(A \\to B\\) 中的B 如果 \\(A \\to \\alpha\\) 不是单一产生式，就放入 \\(P_2\\) 如果 \\(A \\to_G^+ B\\) 且\\(B \\to \\alpha\\) 不是 单一产生式，那么 \\(A \\to \\alpha\\) 放\\(P_2\\) CFG化简 流程 删除无用符号； 删除E-产生式； 删除单一产生式； 当删除单一产生式后，文法中再出现新的无用符号时，再次进行删除无用符号。 CNF 乔姆斯基范式 形式都为 \\(A \\to BC\\) 或 \\(A \\to a\\) 不允许有空产生式和单一产生式 通过CFG构造CNF 首先将化简后的CFG转化为都为 \\(A \\to B_1B_2\\cdots B_n\\) 和 \\(A\\to a\\) 的形式 对于 \\(A \\to aB\\) 这类转化为 \\(A \\to A_aB \\quad A_a \\to a\\) 将形如 \\(A \\to A_1A_2\\cdots A_n\\) 都替换为 \\[ A \\to A_1B_1 \\\\ B_1 \\to A_2B_2\\\\ \\cdots\\\\ B_{n-2} \\to A_{n-1}A_n \\] GNF 格雷巴赫范式 有如下两种形式 \\(A\\to a\\) \\(A\\to a A_1A_2\\cdots A_m\\) 首先 \\(A \\to \\alpha B \\beta\\) 又 \\(B \\to \\gamma_1|\\gamma_2|\\cdots\\) 那么可以将B替换为\\(\\gamma\\) 递归 如果存在 \\(A \\Rightarrow^n \\alpha A \\beta\\) 则称为递归派生；n&gt;2 称为间接递归；\\(\\alpha = \\epsilon\\) 称为左递归，反之为右递归 引理：对于 \\[ \\left\\{ \\begin{align} A &amp;\\to A\\alpha_1|A\\alpha_2|A\\alpha_3\\cdots\\\\ A &amp;\\to \\beta_1|\\beta_2|\\beta_3|\\cdots \\end{align} \\right. \\] 可以替换为 \\[ \\left\\{ \\begin{align} A &amp;\\to \\beta_1|\\beta_2|\\beta_3|\\cdots\\\\ A &amp;\\to \\beta_1B|\\beta_2B|\\beta_3B|\\cdots\\\\ B &amp;\\to \\alpha_1|\\alpha_2|\\alpha_3|\\cdots\\\\ B &amp;\\to \\alpha_1B|\\alpha_2B|\\alpha_3B|\\cdots \\end{align} \\right. \\] CFG转GNF 首先将产生式化成形式（通过引入变量替换终极符） \\[ A \\to A_1A_2\\ldots A_m\\\\ A\\to a A_1A_2\\ldots A_{m-1} \\\\ A \\to a \\] 将产生式都转化为形式 \\[ A_i \\to A_j \\alpha\\quad i &lt; j\\\\ A_i \\to a \\alpha\\\\ B_i \\to \\alpha \\] 当出现j &lt; i 的情况，就用 \\(A_i\\) 的表达式替换，直到出现左递归: image-20220619193420234 具有最大下标的A已经满足GNF的要求，将这些产生式带入还不满足要求的\\(A_2\\)产生式，使得\\(A_2\\)产生式都满足GNF的要求；之后递归的带入 \\(A_1\\) 下推自动机 CFG都可以化为GNF，最左派生是，句型中变量都以后缀形式出现。 使用下推自动机识别CFG \\[ M = (Q,\\Sigma, \\Gamma, \\delta,q_0,Z_0, F) \\] Q状态集合 \\(\\Sigma\\) 输入字母表 \\(\\Gamma\\) 栈顶符号表 \\(Z_0\\in \\Gamma\\) 开始符号，启动时栈内唯一的符号 \\(q_0\\) 开始状态 F终止状态 \\(\\delta\\) 转移函数，\\(\\delta: Q \\times (\\Sigma\\cup \\{\\epsilon\\} \\times \\Gamma) \\to 2^{Q\\times \\Gamma^*}\\) \\[ \\delta(q,a,Z) = \\{(p_1, \\gamma_1), (p_2, \\gamma_2), \\cdots\\} \\] 表示状态q下，栈顶为Z，读入a，状态可以转移为\\(q_i\\) 并且弹出Z并将 \\(\\gamma_i\\) 从右至左压入栈，读头移动，准备读入下一个字符。 特别的如果\\(a = \\epsilon\\) 那么读头不移动。 同样有 即时描述：\\((q,w,\\gamma)\\) 当前状态q，未处理字符串w，栈内符号串\\(\\gamma\\) （最左侧为栈顶） 接收语言 两种接受方法： 转移到特定终态接收 记作\\(L(M)\\) 空栈接收（栈为空时接收）记作\\(N(M)\\) GNF转PDA 模拟最左派生，对于 \\(A \\to b \\alpha\\)，就是读入b，压栈\\(\\alpha\\) \\[ \\forall A \\in V,\\ a\\in T,\\ \\gamma \\in V^*\\\\ \\delta(q,a,A) = \\{(q,\\gamma)|A\\to a\\gamma \\in P\\} \\] 对于含有空串的语言，再加入识别空串的 \\(\\delta_1(q_0,\\epsilon, Z) = \\{(q_0, \\epsilon), (q,S)\\}\\) 类似的还可以终态接受 image-20220619195359916 还可以直接观察语言结构来设计自动机，常用 image-20220619195513815 终态接受的PDA转空栈接受PDA 状态加入初始状态和清栈状态，栈顶符号加入一个用于放在栈底的符号。 初始状态空移动转移到原PDA初始状态，并将新加的栈符号连同原PDA栈底符号压入栈底 之后所有的转移都模拟原PDA，直到原终止状态 原终止状态转移到请栈状态，开始通过空移动清栈。 image-20220619200515110 空栈接受PDA转终态接受的PDA 加入终止状态和标志栈底的元素，等看到栈底元素后就进入终止状态。 PDA转CFG 使用三元组 \\([q,A,q_{next}]\\) 表示CFG中变量，其中A是栈顶符号。 对于 \\(\\delta(q,a,A) = (q_1,A_1A_2\\cdots A_n)\\) 我们不确定处理完\\(A_1\\) 到 \\(A_n\\) 后状态是什么，那么就遍历 image-20220619201358182 流程： 以该题为例 image-20220619201604339 首先构造S的产生式 \\(S\\to [q_0,Z,q_0]|[q_0,Z,q_1]|[q_0,Z,q_2]\\) 对每个转移函数构造产生式 对于空串的处理 image-20220619202110627","categories":[{"name":"Review","slug":"Review","permalink":"https://xav1erw.github.io/categories/Review/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"https://xav1erw.github.io/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"课内","slug":"课内","permalink":"https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"}],"author":"Xav1er"},{"title":"计算机网络期末复习","slug":"Notes/计算机网络复习","date":"2022-06-15T16:00:00.000Z","updated":"2022-06-19T07:22:20.461Z","comments":true,"path":"2022/06/16/Notes/计算机网络复习/","link":"","permalink":"https://xav1erw.github.io/2022/06/16/Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"计算机网络期末复习 计算机网络 网络协议栈各层作用 应用层：通过应用进程间交互完成特定的互联网应用，定义应用进程之间通信和交互的规则。 传输层：进程之间通信的通用数据传输服务。 网络层：网络中不同主机提供通信服务 链路层：两个相邻网络结点之间传送数据 物理层：如何在传输媒介中传输比特流 应用层 C-S和P2P工作特点 客户-服务器是需要服务器打开，客户连接通信；P2P各方之间是对等的。 优缺点 客户-服务器 优点：客户、服务器分离，允许网络分布操作；一个服务器可以服务于多个客户端； 缺点：客户机会比较依赖于服务器工作。 P2P 优点：可扩展性强，传播速度优化； 缺点：用户直连，没有确保安全性，管理困难。 为什么引入域名，DNS缓存作用 方便人们记住主机名标识，同时适应路由器需要定长有层次的IP地址，需要一种从主机名到IP地址的转换服务，因此DNS系统产生了；缓存就是对重复的访问，省去一些重复的解析，节省时间。 传输层 TCP 最大报文段长度( Maximum Segment Size,MSS) 。MSS 通常根据最初确定的由本地发送主机发送的最大链路层 帧 长度（ 即所谓的最大传输单元(Maximum Transmission Unit, MTU)) 来设置 。 设置该 MSS 要保证一个 TCP报文段（当封装在一个 IP 数据报中）加上 TCP/ IP 首部长度（通常 40 字节） 将适合单个链路层帧 。 注意到 MSS 是指在报文段里应用层数据的最大长度，而不是指包括首部的 TCP 报文段的最大长度 。 当 TCP 发送一个大文件 ，例如 某 Web 页面上的一个图像时，TCP 通常是将该文件划分成长度为 MSS 的 若干块（最后一块除外，它通常小于 MSS) 拥塞控制 运行在发送方的 TCP 拥塞控制机制跟踪 一 个额外的变量，即拥塞窗口(congestion window) 。 拥塞窗口表示为 cwnd它对一个 TCP 发送方能向网络中发送流量的速率进行了限制 。 \\[ LastByteSent - LastByteAcked\\leq \\min \\{cwnd,rwnd\\} \\] 网络层 因特网的地址分配策略被称为 无类别域间路由选择(Classless Interdomain Routing,CIDR) [ RFC 4632 ] CIDR 将 子网寻址的概念 一般化了）当使用子网寻址时，32 比特的IP 地址被划分为两部分，并且也具有点分十进制数形式 $ a. b. c. d/x$, 其中x指示了地址的第一部分中的比特数 Best effort service model 为尽力而为服务。 工作特点：尽最大的可能性发送报文，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。 优点：适用于绝大多数网络应用。尽力而为服务模型与适当带宽供给相结合已被证明超过“足够好”，能够用于大量的应用，包括语音、视频等流式视 频服务以及实时会议应用。 不足：对时延、可靠性不提供任何保证。 距离向量路由选择算法 令 \\(d_x (y)\\) 是从节点 x 到节点 y 的最低开销路径的开销 。 则该最低开销与著名的Bellman- Ford 方程相关，即 \\[ d_x (y) = \\min_v \\{c(x,v) + d_v(v)\\} \\] v为x的临近节点， \\(c(x,v)\\) 意为cost 总结常见的传统路由协议，并指出其使用的是什么路由算法。传统路由协议有什么弊端？ OSPF：Dijkstra RIP：距离向量路由算法 弊端：拓扑维护，影响路由器性能和效率；流量路径缺乏灵活调整能力；网络协议实现复杂，运维难度大等。 什么是SDN，它有哪些特点？ 软件定义网络，是在数据平面和控制平面作明确分割的网络设计理念 特点：基于流的转发；数据平面与控制平面分离；网络控制功能位于数据平面交换外部；可编程网络 相较于传统路由协议，SDN的优势是什么？ 数据控制解耦合，将控制器，交换机分离，开放生态； 基于流的转发更加灵活 可编程网络便于开发 控制逻辑中心化，集中式便于管理 链路层 CRC纠错 所有计算（加减乘除）都是模2运算，没有进位借位，相当于直接异或 发送方需要选择长度为r的bits附加到数据D后，然后会构造一个长度为r+1的生成多项式G（同样是二进制数） 发送的数据为 \\[ D\\cdot 2^r \\ \\text{XOR} \\ R \\] 并且要求该数据能够正好被G整除 \\[ D\\cdot 2^r \\ \\text{XOR} \\ R = nG \\] 可以推导 \\[ D\\cdot 2^r =nG \\text{XOR} \\ R \\\\ R = \\text{remainder} \\frac{D\\cdot 2^r}{G} \\] 每个 CRC 标准都能检测小于 r + 1 比特的 突发差错 。此外，在适当的假设下，长度大于 r + 1 比特的突发 差错 以概率 $1 -0. 5^r $ 被检测到。每个 CRC 标准也都能检测任何奇数个比特差错 。 随机接入协议 时隙 ALOHA 分为一个个时隙，每个时隙为 \\(L/R\\) 秒，其中L为帧的长度，则每个时隙够发一帧。 如果没碰撞，正常，有碰撞，则节点在之后的每个时隙中按照 \\(p\\) 的概率重传直至成功。 一 个给定节点传输的概率是 p; 剩余节点不传输的概率是\\((1 -p)^{N-1}\\) 。因此，一个给定节点成功传送的概率是 \\(p(1 -p)^{N-1}\\) 因为有 N 个节点 ，任意一个节点成功传送的概率是 \\[ Np(1 -p)^{N-1} \\] 找到最大化的\\(p^*\\) 可以计算当 \\(N \\to \\infty\\) 时，效率为 \\(1/e = 0.37\\) ALOHA 纯ALOHA，不分割时隙，任何时间都能传，没碰撞正常，有碰撞就在碰撞传输完后每帧时间按照p概率重传，各个节点时间都不同步，最大效率 \\(1/(2e)\\) 载波侦听多路访问(CSMA) 载波侦听(carrier sensing) ，即一个节点在传输前先听信道 。 如果来自另 一个节点的帧正向信道上发送，节点则等待直到检测到 一 小段时间没有传输，然后开始传输 。 碰撞检测(collision detection ) , 即当 一个传输节点在传输时 一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧， 它就停止传输，在重复“侦听-当 空 闲时传输”循环之前等待一段随机时间 。 中止传输后，适配器等待一个随机时间量，之后传输。 随机时间量执行二进制指数后退(binary exponenlial backoff )算法 ：在该帧经历了 一连串的 n 次碰撞后，节点随机地从 \\(\\{0,1,2,\\cdots, 2^n-1\\}\\) 中选择一个 K 值 。对于以太网，一个节点等待的实际时间量是 $ K $ 比特时间，即发送 512 比特进入以 网所需时间的K倍","categories":[{"name":"Review","slug":"Review","permalink":"https://xav1erw.github.io/categories/Review/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xav1erw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Xav1er"},{"title":"React学习笔记","slug":"Notes/React","date":"2022-03-24T16:00:00.000Z","updated":"2022-06-19T01:24:46.723Z","comments":true,"path":"2022/03/25/Notes/React/","link":"","permalink":"https://xav1erw.github.io/2022/03/25/Notes/React/","excerpt":"","text":"React 组件类型和定义 react组件首字母应当大写，因为使用时以标签形式使用，如果首字母小写会认为是html的内置标签，报错 1234567891011121314151617181920// 函数式组件function Welcome(props) &#123; // props是传入的参数 // 如果使用时不传参，也可以没有参数 return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;// 使用ReactDOM.render( &lt;Welcome name=&#x27;wx&#x27;/&gt;,document.getElementById(&#x27;xxx&#x27;))// 类式组件class Welcome extends React.Component &#123; // 继承 React.Component render() &#123; // 必须要有render函数，返回需要渲染的内容 return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 组件三大属性 state 箭头函数()=&gt;&#123;&#125; 和function 区别：箭头函数没有this，其中出现this会去找外侧的this，function自身有this。可以利用该点在类中使用箭头函数，其中用this改变类中的属性. react自定义方法一般用复制加箭头函数的方法 12345class Foo extends React.Component&#123; myMethod = ()=&gt;&#123; /*TODO*/ &#125;&#125; 组件对象有state属性用于表示组件状态，同时在不同事件后使用setState改变state的值实现不同状态的转化。注意setState会把相同的键合并，不同的键保留，不会覆盖 12345678910111213141516171819class Foo extends React.Component&#123; constructor(props) &#123; this.state = &#123;time:111&#125; this.myMethod = this.myMethod.bind(this) // 由于在调用myMethod 的时候，没用通过实例调用，是直接传入的函数 // 函数在类的原型对象上，因此其中的this指向不正确 // 因此使用bind在实例中加入属性myMethod &#125; myMethod() &#123; const time = this.state.time this.setState(&#123;time:time+1&#125;) &#125; render() &#123; return &lt;h1 onClick=&#123;this.myMethod&#125;&gt;现在的时间是&#123;this.state.time&#125;&lt;/h1&gt; &#125;&#125; 同时上述代码可以不需要构造器，简写如下 123456789101112class Foo extends React.Component&#123; state = &#123;time:111&#125; myMethod = ()=&gt;&#123; const time = this.state.time this.setState(&#123;time:time+1&#125;) &#125; render() &#123; return &lt;h1 onClick=&#123;this.myMethod&#125;&gt;现在的时间是&#123;this.state.time&#125;&lt;/h1&gt; &#125; // 相当于直接在类中追加state和myMethod的属性&#125; props 类组件中的props react 的props：我们在创建组件对象时不想用constructor，如何给组件传参？利用props属性，在使用对象标签时给标签参数就可以反映到props属性上 123456789class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt; &#125;&#125;ReactDOM.render(&lt;Person name=&#x27;wx&#x27; age=&#x27;18&#x27; gender=&#x27;M&#x27;/&gt;, document.getElementById(&#x27;xxx&#x27;)) react批量传props：使用对象传参数 12345678910111213class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt; &#125;&#125;let infos = &#123;name:&#x27;wx&#x27;, age:18, gender:&#x27;M&#x27;&#125;ReactDOM.render(&lt;Person &#123;...infos&#125;/&gt;, document.getElementById(&#x27;xxx&#x27;))// 注意此处不是对象的展开，因为外层的&#123;&#125;是表示这是一个js表达式// 这是Babel+react的特性，不是原生js语法// 直接console.log(...infos) 不会输出内容// 仅适用于传标签属性 拷贝时可以修改其中的某项参数 1234let a = &#123;name:&#x27;wx&#x27;, age:18, gender:&#x27;M&#x27;&#125;let copy = &#123;...a, name:&#x27;wx2&#x27;&#125;console.log(copy)// 结果为 &#123;name:&#x27;wx2&#x27;, age:18, gender:&#x27;M&#x27;&#125; 当直接使用标签属性的形式传递props时，形式为key=value此时value只能时字符串，如果想传递其它类型需要加&#123;&#125;表示这是js表达式 12345678910&lt;Person name=&#x27;wx&#x27; age=&#x27;19&#x27; gender=&#x27;M&#x27;/&gt;// 此处的age为字符串，但我们想传入数字// &lt;Person name=&#x27;wx&#x27; age=19 gender=&#x27;M&#x27;/&gt;// 这样会报错，19仅当为js变量时才具有意义，因此改用&lt;Person name=&#x27;wx&#x27; age=&#123;19&#125; gender=&#x27;M&#x27;/&gt;// 或者直接使用对象传入参数let a = &#123;name:&#x27;wx&#x27;, age:19, gender:&#x27;M&#x27;&#125;&lt;Person &#123;...a&#125;/&gt; 接上述内容，传入标签有不同类型，我们对不同类型标签需要有不同的操作，需要对不同标签的数据类型做限制。同时某些参数不传的时候，也需要参数的默认值。（参考函数传参需要限制参数类型和参数默认值）。组件类中使用属性propTypes 指定各个属性的限制，使用defaultProps指定默认值。具体使用如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import PropTypes from &#x27;prop-types&#x27;;// 15.5之前PropTypes在React核心库中，使用React.PropTypes，之后单独写在prop-types.js中class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt;; &#125;&#125;// 类型和必要性限制Person.propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func&#125;// 默认值的指定Person.defaultProps = &#123; gender:&quot;未知&quot;, age:18&#125;// 给类加入属性，可以在类内定义static属性class Person extends React.Component&#123; // 类型和必要性限制 static propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func &#125; // 默认值的指定 static defaultProps = &#123; gender:&quot;未知&quot;, age:18 &#125; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt;; &#125;&#125; props是只读的，不能修改 函数组件中的props 函数式组件通过参数的形式可以有props，但没有state 和refs，除非使用最新的hooks 1234567891011121314151617181920212223function Person(props)&#123; const &#123;name, age, gender&#125; = props return &lt;p&gt;这个人是&#123;name&#125;，&#123;gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;age&#125;岁&lt;/p&gt;;&#125;// 由于没有了类，只能在外部指定限制和默认值Person.propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func&#125;// 默认值的指定Person.defaultProps = &#123; gender:&quot;未知&quot;, age:18&#125;ReactDOM.render(&lt;Person name=&#x27;wx&#x27;/&gt;, document.getElementById(&#x27;xxx&#x27;)) refs 字符串形式的ref(不推荐) 组件内的标签可以通过ref 来标识自己，组件会把ref和标签组成一对key-value放入属性refs中 12345678910111213141516171819class Person extends React.Component&#123; showData= ()=&gt; &#123; // 直接通过this.refs获取到&lt;input&gt;标签 // 注意此时获取到的是真实DOM标签，不是虚拟DOM console.log(this.refs.input1.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#x27;input1&#x27; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;input type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;/div&gt; ) &#125;&#125; 回调函数形式的ref 当ref为函数时，该函数作为回调函数使用，将ref所在节点作为参数传入函数中。一般会利用回调函数，把当前节点赋值给组件属性 12345678910111213141516171819202122232425class Person extends React.Component&#123; showData1= ()=&gt; &#123; // 直接通过this.refs获取到&lt;input&gt;标签 // 注意此时获取到的是真实DOM标签，不是虚拟DOM console.log(this.refs.input1.value) &#125; showData2= ()=&gt; &#123; console.log(this.refs.input2.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;(currentNode)=&gt;&#123;this.input1 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;(currentNode)=&gt;&#123;this.input2 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27; /&gt; &lt;/div&gt; ) // 由于回调函数简单，只有1个参数和一句，还可简写为 // ref = currentNode =&gt; this.input1 = currentNode &#125;&#125; 有关内联函数(函数体直接定义在ref后面的函数)的问题： 当组件更新的时候（state改变，react重新调用render函数，重新渲染），会调用两次ref回调函数，第一次传入参数null 第二次才真正传入当前节点 原因：每次重新调用render 都会重新生成回调函数，不确定之前调用的回调函数有什么影响，为了消除影响，第一次先传入null消除之前可能的效果，之后再次调用，传入当前节点。 只是细节，基本不会产生影响 如果想改，可以把回调函数改为类中定义的函数 123456789101112131415161718192021222324252627282930313233class Person extends React.Component&#123; state = &#123;s:True&#125; showData1= ()=&gt; &#123; console.log(this.refs.input1.value) &#125; change= ()=&gt; &#123; const &#123;s&#125; = this.state this.setState(&#123;s:!s&#125;) &#125; refCallback=()=&gt; &#123; this.input1 = currentNode; console.log(&#x27;@&#x27;, currentNode) &#125; // 如果使用这个，控制台就只会出现 @ &lt;input ...&gt; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;(currentNode)=&gt;&#123;this.input1 = currentNode;console.log(&#x27;@&#x27;, currentNode)&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData1&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;button onClick=&#123;this.change&#125;&gt; 点击改变状态 &lt;/button&gt; &lt;/div&gt; ) &#125; // 当点击change后，可以看到控制台上输出 // @ null // @ &lt;input ...&gt; // 两个结果&#125; createRef 可以使用react内部的createRef来定义一个ref，createRef相当于创建一个容器，装ref对应的标签，每个createRef对应一个标签，createRef创建的ref是一个对象，其中有一个key为currrent 通过myRef.current获取到对应的标签 12345678910111213class Person extends React.Component&#123; state = &#123;s:True&#125; myRef1 = React.createRef() // ... render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;this.myRef1&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;/div&gt; ) &#125; React事件处理 React中的事件都被封装了一层 通过 onXxx 指定事件处理函数，如onClick、onBlur等 使用的是React自定义事件，而不是原生DOM事件 （为了更好的兼容性） 事件都是通过事件委托的方式处理的（委托给组件最外层元素） （为了高效） 通过event.target得到发生事件的DOM元素对象 （减少ref使用） 避免过度使用ref： 发生事件的元素正好是需要操作的元素，可以不用ref 利用事件的回调函数传入的event参数直接获取DOM元素对象 例： 123456789101112131415class Demo extends React.Component&#123; showOnBlur=(event)=&gt;&#123; // 回调该函数时会传入event参数，使用event.target获得该事件的DOM对象 // 这样可以避免ref的频繁使用 alert(event.target.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input onBlur=&#123;this.showOnBlur&#125; type=&#x27;text&#x27; placeholder=&#x27;失去焦点显示内容&#x27;/&gt; &lt;/div&gt; ) &#125; React 受控和非受控组件 非受控组件 12345678910111213141516171819202122class Login extends React.Component&#123; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this alert(`用户名：$&#123;username.value&#125; 密码：$&#123;passwd.value&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input ref=&#123;(c)=&gt;this.username=c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input ref=&#123;(c)=&gt;this.passwd=c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) // form中action表示提交表单数据的地址 &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) form表单不提供参数时，默认发起GET请求同时带有query参数 原生js中表单具有事件 onsubmit， React中为 onSubmit 避免表单提交刷新页面，可以使用 event.preventDefault() 阻止默认事件不提交表单 非受控组件：页面中所有输入类DOM的值现用现取（点击登录后，回调函数获取表单值）属于非受控组件 受控组件 原生js 有事件onchange 在改变时调用onchange 的回调函数，React中同样有 onChange 使用onChange 回调函数将输入内容直接存入状态中 123456789101112131415161718192021222324252627282930class Login extends React.Component&#123; state = &#123;username:&quot;NoName&quot;, passwd:&quot;NoPasswd&quot;&#125; readUserName = (event)=&gt; &#123; this.setState(&#123;username:event.target.value&#125;) &#125; readPasswd = (event)=&gt; &#123; this.setState(&#123;passwd:event.target.value&#125;) &#125; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this.state alert(`用户名：$&#123;username&#125; 密码：$&#123;passwd&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;this.readUserName&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input onChange=&#123;this.readPasswd&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) 关于受控和非受控： 非受控可以理解为拿到数据的行为不受程序控制，而受用户控制，只有用户进行提交等行为，组件才能最终拿到数据； 受控可以理解为拿数据的行为受程序控制，用户只要输入，不用提交，随着输入组件就能就拿到数据 更建议使用受控组件，因为非受控组件有几个输入，就有几个ref，受控组件可以减少ref 的使用 上述代码有重复实现的功能，可以改善，代码如下，具体使用了函数的柯里化 123456789101112131415161718192021222324252627282930class Login extends React.Component&#123; state = &#123;username:&quot;&quot;, passwd:&quot;&quot;&#125; changeFormData=(dataType)=&gt; &#123; return (event)=&gt; &#123; this.setState(&#123;[dataType]:event.target.value&#125;) &#125; // 将函数作为返回值供回调使用，同时利用传入参数实现不同功能 &#125; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this.state alert(`用户名：$&#123;username&#125; 密码：$&#123;passwd&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;this.changeFormData(&quot;username&quot;)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input onChange=&#123;this.changeFormData(&quot;passwd&quot;)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) 不用柯里化函数，也可以实现 123456789// 修改changeFormData，接受dataType和需要的参数changeFormData=(dataType, value)=&gt;&#123;/*do something*/&#125;// ...return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;(event)=&gt;&#123;this.changeFormData(&quot;username&quot;, event.target.value)&#125;&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt;) 直接利用回调函数给changeFormData传入不同的参数实现代码复用 组件生命周期（重要） 旧版本 组件第一次被渲染到页面上时，React中称之为挂载 (mount) ，从页面移除时称之为 卸载 (unmount) 挂载组件使用render() ，卸载使用ReactDOM.unmountComponentAtNode() 希望在组件挂载到页面上时执行一些操作，比如设置定时器等。可以使用 componentDidMount()进行操作，该函数在组件挂载时调用，并仅调用这一次。 例：希望组件中的文本周期性的透明度减小，到0时恢复为1。点击按钮使组件消失 12345678910111213141516171819202122232425262728293031323334353637383940class Life extends React.Component&#123; state=&#123;opacity:1&#125; delEle=()=&gt; &#123; ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;)) // 删除组件 // 测试中发现只能删除该组件外部的容器，而不能删除组件内部的标签 &#125; // componentDidMoun调用：只在挂载时调用 componentDidMount() &#123; setInterval( ()=&gt; &#123; let &#123;opacity&#125; = this.state opacity -= 0.1 if (opacity&lt;=0) &#123; opacity = 1 &#125; this.setState(&#123;opacity:opacity&#125;) &#125;,200 ) // 设置定时器，每200ms透明度减小0.1 &#125; // render调用：初始化渲染，更新调用 // 如果定时器设置在render中，每次更新都会创建新的定时器，造成混乱 render() &#123; return( &lt;div&gt; &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;测试文本&lt;/h2&gt; &lt;button onClick=&#123;this.delEle&#125;&gt;点我消失&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 以上代码会出现新的问题，在点击删除节点后，控制台报错：不能更新一个未挂载的组件(unmounted component)的状态 解决以上问题： 先把定时器绑定到this 上，即初始定义为this.timer = setInterval() ，之后在删除组件时加上删除定时器clearInterval(this.timer) 使状态停止更新 直接使用componentWillUnmount 做这项工作，在组件将要被卸载时执行的操作 12345678910111213141516// ...delEle=()=&gt;&#123; clearInterval(this.timer) // 提前清除定时器 ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;))&#125;componentDidMount()&#123; this.timer=setInterval( ()=&gt;&#123; /*TODO*/ &#125;,200 )&#125;// ... 1234componentWillUnmount()&#123; clearInterval(this.timer)&#125; 组件的生命周期实际就是组件从创建、挂载到卸载，其中重要的函数（如render、componentDidMount、componentWillUnmount 等）被称为：生命周期钩子函数、生命周期函数等 组件从创建到死亡有一些特定的阶段 组件包含一系列钩子函数会在特定阶段调用 定义组件时会在特定的生命周期回调函数中，做特定的工作。 对于上图：左侧好理解，不做赘述 右侧： setState 流程 调用后，首先会通过shouldComponentUpdate 阀门，检查是否应当更新当前组件，若返回true则能够进行下去，反之会被阻拦，无法调用后面的函数。如果该函数未定义，永远返回true 检查返回true后会依次调用componentWillUpdate 、 render 、componentDidUpdate 表示组件更新前、更新、更新后的操作 forceUpdate 流程 跳过shouldComponentUpdate 强制更新 直接调用componentWillUpdate 、 render 、componentDidUpdate 一般用做不更改状态数据，强制更新一下 通过this.forceUpdate 调用 父组件调用 render 首先组件要形成父子关系：在A组件中调用B组件，则A为B的父组件 父组件状态改变，重新render后，调用子组件钩子 componentWillReceiveProps （组件将要接收props） 注意！ 上述钩子在第一次传入props 时不会调用！只有更新传入新的props时才会调用（可以认为父组件重新render后调用） 1234567891011121314151617181920212223242526272829303132333435363738394041// 父组件调用render展示// 父组件class A extends React.Component&#123; state = &#123;s:true&#125;; changeState = () =&gt; &#123; const &#123;s&#125; = this.state; this.setState(&#123;s:!s&#125;); &#125;; render() &#123; const &#123;s&#125; = this.state; let st = s? &quot;状态1&quot;:&quot;状态2&quot;; return( &lt;div&gt; &lt;p&gt;这是A组件&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变状态&lt;/button&gt; &lt;B show=&#123;st&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// 子组件class B extends React.Component &#123; componentWillReceiveProps() &#123; console.log(&quot;B---componentWillReceiveProps&quot;); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;这是B组件，展示状态：&#123;this.props.show&#125;&lt;/p&gt; &lt;/div&gt;); &#125;&#125;// 在页面初始时，控制台不会显示B---componentWillReceiveProps// 之后每点击一次button，控制台就多显示一个B---componentWillReceiveProps 以上都为旧版本的生命周期，做如下总结 初始化阶段，由ReactDOM.render() 触发 （初次渲染） constructor componentWillMount render componentDidMount 常用，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息 更新阶段，由this.setState 或父组件 render 触发 shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载组件，通常由 ReactDOM.unmountComponentAtNode 触发 componentWillUnmount 常用，通常做一些收尾工作，例：关闭定时器、取消订阅 新版本 componentWillMount 、componentWillReceiveProps 、 componentWillUpdate 前都需要加上UNSAFE_ 记忆：除了 componentWillUnmount，所有带will 的钩子都需要加UNSAFE_ unsafe：未来版本后加入异步渲染后，这三个钩子可能带来一些bug（现在不会），因此加入UNSAFE标志，同时提醒减少这三个钩子的使用 新生命周期如下图 生命周期新 对于新生命周期，可以理解为： 废弃componentWillMount 、componentWillReceiveProps 、 componentWillUpdate三个旧的钩子 提出 getDerivedStateFromProps 、 getSnapshotBeforeUpdate 两个新的钩子 注：实际使用中，两个新的钩子使用情况极其罕见 对于getDerivedStateFromProps： 定义在类上，因此需要是静态方法 static getDerivedStateFromProps ；同时返回值也必须是状态对象或null 接受参数props和state ，得到标签参数 当返回null时，不会产生影响 当返回状态对象，会将返回的对象设置为当前的state 理解：从props中得到派生的状态，即通过props的值得到状态，state的值在任何时候都取决于props，修改就没作用了 注意：容易造成代码冗余并且难以维护 123456789101112131415161718192021222324252627282930313233343536class A extends React.Component&#123; state = &#123;s:0&#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; // return null // 返回null不会有任何影响 console.log(nextProps, prevState); // 第一次输出 &#123;s:100&#125; &#123;s:0&#125; // 之后输出 &#123;s:100&#125; &#123;s:101&#125; return &#123;s:nextProps.s&#125; &#125; // 从props中得到数据，并强行指定state值 changeState = () =&gt; &#123; const &#123;s&#125; = this.state; this.setState(&#123;s:s+1&#125;); // 每次点击+1 &#125;; render() &#123; const &#123;s&#125; = this.state; return( &lt;div&gt; &lt;p&gt;这是A组件&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变状态&lt;/button&gt; &lt;p&gt;当前状态值为&#123;s&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;A s=&#123;100&#125;/&gt;, document.getElementById(&#x27;root&#x27;)); 对于getSnapshotBeforeUpdate： 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。 说明： componentDidUpdate 实际有三个参数 componentDidUpdate(preProps, preState, snapshot) 接收更新前的props、更新前的state和getSnapshotBeforeUpdate 传递进来的快照 snapshot 案例说明： 需求：有一新闻列表，长度固定；不断有新的新闻刷新，新的新闻在列表最上方；超出列表长度，使用滚动条。 问题：当内容不断刷新出现时，滚动条相对于最高点位置是固定的，反映到内容上，旧的内容会被新的内容挤到下方 解决：需要固定内容相对不动，即每次更新内容时，需要滚动条相对顶部的高度加上新内容的高度 提前定义好列表和新闻样式为 12345678910.newsList&#123; width: 200px; height:150px; background:skyblue; overflow: auto;&#125;.news&#123; height: 30px;&#125; 代码 为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class NewsList extends React.Component&#123; state = &#123;newsArr:[]&#125; // state中保存新闻列表 componentDidMount() &#123; setInterval(() =&gt; &#123; // 获取原状态 const &#123;newsArr&#125; = this.state // 模拟生成新闻消息 const news = &quot;新闻&quot; + (newsArr.length+1) // 更新状态，把新的新闻信息放到第一个 this.setState(&#123;newsArr:[news,...newsArr]&#125;) &#125;, 1000); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; return this.NewsList.scrollHeight // 拿到更新之前内容区的高度，以和更新后比较，计算更新前后差值 // 将高度留下快照 // 快照传给componentDidUpdate &#125; componentDidUpdate(prevProps, prevState, heightSnapshot) &#123; // 获取更新后的高度 let currentHeight = this.NewsList.scrollHeight // scrollTop即规定滚动条到顶部的距离 // 每次距离要加上增加的内容长度 // 注意不要=，直接=相当于固定滚动条高度，内容还是会被挤下去 this.NewsList.scrollTop += currentHeight-heightSnapshot &#125; render() &#123; return ( &lt;div className=&#x27;newsList&#x27; ref=&#123;(cNode)=&gt;&#123;this.NewsList = cNode&#125;&#125;&gt; &#123; this.state.newsArr.map( (n,index)=&gt;&#123; return &lt;div className=&#x27;news&#x27; key=&#123;index&#125;&gt;&#123;n&#125;&lt;/div&gt; &#125; ) // 回想：react会自动展开可迭代的一系列标签 &#125; &lt;/div&gt; ); // 注：中间有key属性是因为要求列表中每一个子节点都有一个unique key // 为简单因此将index作为key // 实际这样使用会出现一些问题，之后再做探讨 &#125;&#125; 新版本生命周期总结如下 初始化阶段，由ReactDOM.render() 触发 （初次渲染） constructor getDerivedStateFromProps render componentDidMount 常用，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息 更新阶段，由this.setState 或父组件 render 触发 getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate 卸载组件，通常由 ReactDOM.unmountComponentAtNode 触发 componentWillUnmount 常用，通常做一些收尾工作，例：关闭定时器、取消订阅 Diffing算法 React每次更新不是直接更新真实DOM，而是修改虚拟DOM，比较修改前后的虚拟DOM，只找不同的地方在真实DOM修改，不用真实DOM每次都全部更新，效率高 Diffing算法最小更新粒度是标签，但是会比较多层，比如 1234&lt;span&gt; 现在的时间是：&#123;this.state.time&#125; &lt;input type=&quot;text&quot;/&gt;&lt;/span&gt; 其中this.state.time 一秒钟更新一次，表示当前时间，span 标签内容改变，但是内部的input标签并没有改变，react只更新改变的内容，内部的 input 不会更新。 虚拟DOM中key的作用 简单：key是虚拟DOM对象的标识，更新显示时key起着极其重要的作用 详细： 当状态数据发生变化时，react会根据新数据生成新的虚拟DOM，随后React将【新虚拟DOM】与【旧虚拟DOM】的diff比较，规则如下： 旧DOM找到了与新DOM相同的key，： 若虚拟DOM内容不变，则仍用原本的真实DOM 若虚拟DOM内容改变了，则根据改变的虚拟DOM生成真实DOM，替换页面内容 未找到相同的key：根据数据创建真实DOM并渲染到页面 之前的代码 提到用index作为key 会产生一些问题，下分析其低效原因 代码示例： 12345678910111213141516171819202122232425262728293031class Person extends React.Component &#123; state = &#123; persons:[ &#123;id:0, name:&quot;小王&quot;, age:18&#125;, &#123;id:1, name:&quot;小李&quot;, age:19&#125;, ] &#125;; add = () =&gt; &#123; const &#123;persons&#125; = this.state; const p = &#123;id:persons.length+1, name:&quot;小张&quot;, age:20&#125; this.setState(&#123;persons:[p,...persons]&#125;) // 注意此处将信息系加入到了前面 &#125;; render() &#123; return( &lt;div&gt; &lt;h2&gt;信息展示&lt;/h2&gt; &lt;button onClick=&#123;this.add&#125;&gt;添加小张&lt;/button&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj, index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;;&#125; 分析其中的更新步骤： 1. 初始化创建， state 内为 1234[ &#123;id:1, name:&quot;小王&quot;, age:18&#125;, &#123;id:2, name:&quot;小李&quot;, age:19&#125;] 那么虚拟DOM中标签为 12&lt;li key=0&gt;小王---18&lt;/li&gt;&lt;li key=1&gt;小李---19&lt;/li&gt; 更新后，数据变为 12345[ &#123;id:3, name:&quot;小张&quot;, age:20&#125;, &#123;id:1, name:&quot;小王&quot;, age:18&#125;, &#123;id:2, name:&quot;小李&quot;, age:19&#125;] 新生成的虚拟DOM标签为 123&lt;li key=0&gt;小张---20&lt;/li&gt;&lt;li key=1&gt;小王---18&lt;/li&gt;&lt;li key=2&gt;小李---19&lt;/li&gt; 按照之前的diffing比较步骤： 1. 首先取 key=0 旧虚拟和新虚拟比较：有该key，但内容不同，则重新渲染到真实DOM中 2. 再取 key=1 旧虚拟和新虚拟比较：有该key，但内容不同，则重新渲染到真实DOM中 3. 取 key=2 旧虚拟和新虚拟比较：无该key，直接渲染到真实DOM中 可以发现，实际将三个标签全部重新渲染，但是我们可以看出，两个标签是重复的，不必要再次渲染，这样冗余的渲染造成了效率低下 进一步看造成冗余的原因：使用index作为key，在数据列表等顺序改变时，会直接改变已有数据的key，导致新加入数据后，原本数据对应标签的key 也发生变化，造成多余的真实DOM渲染，没有复用之前的标签 最好不要使用index，而是用数据的唯一标识，如id等作为key的值 以上的问题，不只会带来效率降低，当有输入框等嵌套结构时，还会造成数据错位： 123456789101112131415161718192021222324252627282930313233343536373839404142class Person extends React.Component &#123; state = &#123; persons:[ &#123;id:0, name:&quot;小王&quot;, age:18&#125;, &#123;id:1, name:&quot;小李&quot;, age:19&#125;, ] &#125;; add = () =&gt; &#123; const &#123;persons&#125; = this.state; const p = &#123;id:persons.length+1, name:&quot;小张&quot;, age:20&#125; this.setState(&#123;persons:[p,...persons]&#125;) // 注意此处将信息系加入到了前面 &#125;; render() &#123; return( &lt;div&gt; &lt;h2&gt;信息展示&lt;/h2&gt; &lt;h3&gt;使用index为key&lt;/h3&gt; &lt;button onClick=&#123;this.add&#125;&gt;添加小张&lt;/button&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj, index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;hr/&gt; &lt;hr/&gt; &lt;h3&gt;使用id为key&lt;/h3&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj)=&gt;&#123; return &lt;li key=&#123;personObj.id&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;;&#125; 上述代码，上半部分在输入后点击“添加小张” 会造成输入框数据的错位；下半部分则不会 原因： * 在用index作为key的部分，由于相同的key内部值不同，节点都做了更新，但因为虚拟DOM中 input 没有 value 属性，直接比较内部 input 标签都一样，因此没有更新 input 标签，这样相当于保留输入但改变前面内容，造成了最终的错位 * 使用id为key，比较后id相同不做更新，直接在最前方加入 li 标签，输入框和文本信息统一后移，不会有错位 总结：用index作为key可能的问题 1. 若对数据进行排序、逆序、删除、插入等操作破坏原本顺序：会造成不必要的真实DOM更新，降低效率 2. 如果结构中还包含输入类DOM：会产生错误的DOM更新造成信息的错误显示 3. 如果不对数据进行排序、逆序、删除、插入等操作，仅用于渲染展示信息，可以使用index作为key React脚手架 文件介绍 punlic/index.html head部分内容解释 123456&lt;!-- 以链接形式指定图标，%PUBLIC_URL%为public文件夹 --&gt;&lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&lt;!-- 开启理想视口，适配移动端 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;&lt;!-- 指定地址栏和标签页的主题颜色（仅针对安卓手机） --&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; punlic/manifest.json 如果网页用作应用加壳，使用的配置文件（即，直接使用网页套壳作为安卓、iOS应用等） src/App.js 存放最外层App组件，用脚手架开发之后，所有小组件都作为App的子组件，最后只加载App组件到页面 src/App.test.js 对App组件做测试的脚本，几乎不用 src/index.js webpack的入口文件 其中加载App组件，用&lt;React.StrictMode&gt; 包裹：这样会检查App组件中不合理的部分（比如使用字符串形式的ref会弹出警告等） src/reportWebVital.js 用于分析、记录、显示页面性能 src/setupTests.js 用于模块的整体测试 编写方式 不同组件放到 src 统一的文件夹下，文件夹内部，一个组件一个文件夹，用于存放组件使用的外部js和样式等 将不同组件在App中进行组合 区分组件和业务逻辑文件： 组件文件名大写 组件文件后缀可以使用 jsx 多层文件引入麻烦，可以不同组件文件夹不同，但定义组件的文件都叫 index.jsx ，这样只要引入文件夹即可 样式模块化 避免不同模块之间样式冲突（不同模块指定相同名字的class不同样式，后引入的会覆盖之前引入的），要使用样式的模块化 模块化css：文件名改为 xxx.module.css 这样引入时可以将样式作为模块引入，使用时按照模块使用（xxx.class 等形式） 1234/* xxx.module.css */.title&#123; background-color:skyblue;&#125; 12345678910import xxx from &#x27;./xxx.module.css&#x27;export default class Hello extends React.Component&#123; render() &#123; return ( &lt;h1 className=&#123;xxx.title&#125;&gt;Hello&lt;/h1&gt; ); &#125;&#125; 应用案例 TodoList 上方Header组件为一个输入框，接受用户输入需要完成的任务，将任务加入到列表中 中间List展示已经有的任务，并且每个任务可以标志是否完成、可以删除 下方Footer展示已完成可全部任务数量，可以删除所有已完成任务，可以给所有任务打勾 困难：Header和List之间为兄弟，Header的数据无法传给List，也就无法新加入任务 解决：Header用某种方式将数据传给父组件App，再由App用props的形式将数据传给List 子组件向父组件传递数据 将父组件类内部的处理、显示数据的函数传给子组件，子组件将数据作为函数参数传入并调用，相当于给父组件传入了参数，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// App.jsclass App extends React.Component&#123; state=&#123;todos:[ &#123;id:&#x27;001&#x27;, name:&quot;aaa&quot;, done:true&#125;, &#123;id:&#x27;002&#x27;, name:&quot;bbb&quot;, done:false&#125;, &#123;id:&#x27;003&#x27;, name:&quot;ccc&quot;, done:false&#125;, ]&#125;; // 添加todo，接受一个todo对象（包含id、name、done等参数） addTodo = (todoObj) =&gt; &#123; const &#123;todos&#125; = this.state; // 追加todo const newTodos=[todoObj,...todos]; // 更新状态 this.setState(&#123;todos:newTodos&#125;) &#125;; render() &#123; return ( &lt;Header addTodo=&#123;this.addTodo&#125;/&gt; &lt;List/&gt; &lt;Footer/&gt; ); &#125;&#125;// =======================================// Header.jsclass Header extends React.Component &#123; handleKeyUp = (event) =&gt; &#123; // onKeyUp: 只要键盘按下就调用该事件 const &#123;keyCode, target&#125; = event; // keyCode 为按下去的按键编码，value为输入框内容 if (keyCode!== 13) return // 当按下的键不是回车直接返回，不处理 // 构造todo对象 // id需要不同，可以用库构造uuid，uuid库过大，可以使用nanoid // 每次调用都生成唯一的id // npm i nanoid const todoObj=&#123;id:nanoid(), name:target.value, done:false&#125; // 调用addTodo函数 加入新的任务 this.props.addTodo(todoObj) &#125;; render() &#123; return ( &lt;div&gt; &lt;input onKeyUp=&#123;this.handleKeyUp&#125; type=&quot;text&quot; placeholder=&quot;请输入任务名，按回车确认&quot;/&gt; &lt;/div&gt; ); &#125;&#125; 具体实现见：Todo_src React 和 axios 跨域请求和代理配置 当出现以下情况，都属于跨域访问 跨域原因 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 我们在测试请求数据时：在不同端口实现前端(3000)和后端服务器(5000)，造成跨域访问，导致数据获取失败。 Ajax 对于跨域请求：请求可以发出，后端服务器能够接收到，但是后端服务器发往前端的数据会被ajax阻止 对于跨域，我们可以设置代理： 代理将前端请求转发给后端，将后端响应返回给前端 代理与前端端口和域名一致：前端仅与代理通信，不会造成跨域，请求不会被阻拦 代理访问后端实际为跨域，但是由于没有ajax阻拦所以可以实现 做法：在package.json 中最后加入 \"proxy\":\"后端服务器地址\" 发送数据时就直接给前端端口（不会产生跨域）发送数据，代理自动将数据转发 注意：请求会首先在真正的前端端口下寻找资源，如果找到是不会转发给后端服务器的 附 原生js基础 展开运算符：...用于展开可迭代的变量，如数组等，但字面量对象(可以理解为字典)无法直接展开 123456789let a = [1,2,3,4]let b = [5,8,7]console.log(...a)// 输出1 2 3 4let c = [...a,...b]// 用于拼接数组// let b = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;&#125;// console.log(...b) // 会报错 对象相关 对象的复制：形式类似于展开运算符，但需要在外层加上&#123;&#125; 12345678910let a = &#123;name:&#x27;ccc&#x27;, age:&#x27;3&#x27;&#125;let b = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;, nigger: true&#125;let c = &#123;...a&#125;// 复制a到c// 注意，直接赋值 c=a 相当于直接返回a的指针，修改a，c也改变let merged = &#123;...a, ...b&#125;// 合并a、b，其中相同的key被后者覆盖，不同的key加上// merged = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;, nigger: true&#125; 所有对象中key:value 表达式，默认key 为字符串，name:\"wx\" 等价于 \"name\":\"wx\"。如果想使变量作为key 可以使用方括号[] 123456let dataType = &quot;username&quot;;console.log(&#123;dataType:&quot;wx&quot;&#125;);// 输出结果为&#123;dataType:&quot;wx&quot;&#125;console.log(&#123;[dataType]:&quot;wx&quot;&#125;);// 输出结果为&#123;username:&quot;wx&quot;&#125; 当对象key和value相同时，有简写形式 12345opacity = 0.5style1 = &#123;opacity:opacity&#125;style2 = &#123;opacity&#125;// 两种写法效果相同// 都会得到 &#123;opacity:0.5&#125; 常用 setInterval 定时器，两个参数，第一个参数为函数，为执行的操作；第二个参数为执行函数间隔的时间 12time = 200 //mssetInterval(()=&gt;&#123;&#125;, time) 特殊概念 高阶函数 如果一个函数接受一个函数作为参数，那么就是高阶函数 如果一个函数将一个函数作为返回值，也是高阶函数 函数的柯里化：通过函数调用最终返回函数的方式，实现多次接收参数，最后统一处理的函数编码形式。如受控和非受控组件中的代码 资源 库的js可以通过官网找到，下载 还可以在BootCDN 找到，该网站提供了常用js库的加速访问","categories":[{"name":"Tech","slug":"Tech","permalink":"https://xav1erw.github.io/categories/Tech/"},{"name":"前端","slug":"Tech/前端","permalink":"https://xav1erw.github.io/categories/Tech/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xav1erw.github.io/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"https://xav1erw.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://xav1erw.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Xav1erW"}],"categories":[{"name":"Review","slug":"Review","permalink":"https://xav1erw.github.io/categories/Review/"},{"name":"Tech","slug":"Tech","permalink":"https://xav1erw.github.io/categories/Tech/"},{"name":"前端","slug":"Tech/前端","permalink":"https://xav1erw.github.io/categories/Tech/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"https://xav1erw.github.io/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"课内","slug":"课内","permalink":"https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://xav1erw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","permalink":"https://xav1erw.github.io/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"https://xav1erw.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://xav1erw.github.io/tags/%E5%89%8D%E7%AB%AF/"}]}