{"meta":{"title":"Xav1er Blog","subtitle":"","description":"","author":"Xav1er","url":"https://blog.x-wang.tech","root":"/"},"pages":[{"title":"","date":"2022-06-20T12:25:44.301Z","updated":"2022-06-20T12:25:44.301Z","comments":false,"path":"tags/index.html","permalink":"https://blog.x-wang.tech/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-20T12:25:44.300Z","updated":"2022-06-20T12:25:44.300Z","comments":false,"path":"categories/index.html","permalink":"https://blog.x-wang.tech/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-01T03:39:29.944Z","updated":"2022-07-01T03:39:29.944Z","comments":true,"path":"tool/crypto-js.min.js","permalink":"https://blog.x-wang.tech/tool/crypto-js.min.js","excerpt":"","text":"!function(t,e){\"object\"==typeof exports?module.exports=exports=e():\"function\"==typeof define&&define.amd?define([],e):t.CryptoJS=e()}(this,function(){var n,o,s,a,h,t,e,l,r,i,c,f,d,u,p,S,x,b,A,H,z,_,v,g,y,B,w,k,m,C,D,E,R,M,F,P,W,O,I,U=U||function(h){var i;if(\"undefined\"!=typeof window&&window.crypto&&(i=window.crypto),\"undefined\"!=typeof self&&self.crypto&&(i=self.crypto),!(i=!(i=!(i=\"undefined\"!=typeof globalThis&&globalThis.crypto?globalThis.crypto:i)&&\"undefined\"!=typeof window&&window.msCrypto?window.msCrypto:i)&&\"undefined\"!=typeof global&&global.crypto?global.crypto:i)&&\"function\"==typeof require)try{i=require(\"crypto\")}catch(t){}var r=Object.create||function(t){return e.prototype=t,t=new e,e.prototype=null,t};function e(){}var t={},n=t.lib={},o=n.Base={extend:function(t){var e=r(this);return t&&e.mixIn(t),e.hasOwnProperty(\"init\")&&this.init!==e.init||(e.init=function(){e.$super.init.apply(this,arguments)}),(e.init.prototype=e).$super=this,e},create:function(){var t=this.extend();return t.init.apply(t,arguments),t},init:function(){},mixIn:function(t){for(var e in t)t.hasOwnProperty(e)&&(this[e]=t[e]);t.hasOwnProperty(\"toString\")&&(this.toString=t.toString)},clone:function(){return this.init.prototype.extend(this)}},l=n.WordArray=o.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:4*t.length},toString:function(t){return(t||c).stringify(this)},concat:function(t){var e=this.words,r=t.words,i=this.sigBytes,n=t.sigBytes;if(this.clamp(),i%4)for(var o=0;o>>2]>>>24-o%4*8&255;e[i+o>>>2]|=s2]=r[c>>>2];return this.sigBytes+=n,this},clamp:function(){var t=this.words,e=this.sigBytes;t[e>>>2]&=4294967295>>24-n%4*8&255;i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join(\"\")},parse:function(t){for(var e=t.length,r=[],i=0;i>>3]|=parseInt(t.substr(i,2),16)2]>>>24-n%4*8&255;i.push(String.fromCharCode(o))}return i.join(\"\")},parse:function(t){for(var e=t.length,r=[],i=0;i>>2]|=(255&t.charCodeAt(i))>8&255,i=255&t,255===(e=t>>16&255)?(e=0,255===r?(r=0,255===i?i=0:++i):++r):++e,t=0,t+=e>0>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0>>0?1:0)|0,this._b=e[7]>>>0>>0?1:0;for(r=0;r>>16;R[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=R[0]+(R[7]>16)+(R[6]>16)|0,t[1]=R[1]+(R[0]>24)+R[7]|0,t[2]=R[2]+(R[1]>16)+(R[0]>16)|0,t[3]=R[3]+(R[2]>24)+R[1]|0,t[4]=R[4]+(R[3]>16)+(R[2]>16)|0,t[5]=R[5]+(R[4]>24)+R[3]|0,t[6]=R[6]+(R[5]>16)+(R[4]>16)|0,t[7]=R[7]+(R[6]>24)+R[5]|0}function q(){for(var t=this._X,e=this._C,r=0;r>>0>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0>>0?1:0)|0,this._b=e[7]>>>0>>0?1:0;for(r=0;r>>16;I[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=I[0]+(I[7]>16)+(I[6]>16)|0,t[1]=I[1]+(I[0]>24)+I[7]|0,t[2]=I[2]+(I[1]>16)+(I[0]>16)|0,t[3]=I[3]+(I[2]>24)+I[1]|0,t[4]=I[4]+(I[3]>16)+(I[2]>16)|0,t[5]=I[5]+(I[4]>24)+I[3]|0,t[6]=I[6]+(I[5]>16)+(I[4]>16)|0,t[7]=I[7]+(I[6]>24)+I[5]|0}return F=(M=U).lib,n=F.Base,o=F.WordArray,(M=M.x64={}).Word=n.extend({init:function(t,e){this.high=t,this.low=e}}),M.WordArray=n.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:8*t.length},toX32:function(){for(var t=this.words,e=t.length,r=[],i=0;i2]|=t[i]2]>>>16-n%4*8&65535;i.push(String.fromCharCode(o))}return i.join(\"\")},parse:function(t){for(var e=t.length,r=[],i=0;i>>1]|=t.charCodeAt(i)>2]>>>16-n%4*8&65535);i.push(String.fromCharCode(o))}return i.join(\"\")},parse:function(t){for(var e=t.length,r=[],i=0;i>>1]|=s(t.charCodeAt(i)2]>>>24-o%4*8&255)>2]>>>24-(o+1)%4*8&255)>2]>>>24-(o+2)%4*8&255,c=0;c>6*(3-c)&63));var a=i.charAt(64);if(a)for(;n.length%4;)n.push(a);return n.join(\"\")},parse:function(t){var e=t.length,r=this._map;if(!(i=this._reverseMap))for(var i=this._reverseMap=[],n=0;n>>2]|=c2]>>>24-s%4*8&255)>2]>>>24-(s+1)%4*8&255)>2]>>>24-(s+2)%4*8&255,a=0;a>6*(3-a)&63));var h=n.charAt(64);if(h)for(;o.length%4;)o.push(h);return o.join(\"\")},parse:function(t,e=!0){var r=t.length,i=e?this._safe_map:this._map;if(!(n=this._reverseMap))for(var n=this._reverseMap=[],o=0;o>>2]|=c>5]|=128>98),e[14+(64+i>>>98),t.sigBytes=4*(e.length+1),this._process();for(var e=this._hash,o=e.words,s=0;s24)|4278255360&(c>8)}return e},clone:function(){var t=i.clone.call(this);return t._hash=this._hash.clone(),t}});function H(t,e,r,i,n,o,s){s=t+(e&r|~e&i)+n+s;return(s>32-o)+e}function z(t,e,r,i,n,o,s){s=t+(e&i|r&~i)+n+s;return(s>32-o)+e}function C(t,e,r,i,n,o,s){s=t+(e^r^i)+n+s;return(s>32-o)+e}function D(t,e,r,i,n,o,s){s=t+(r^(e|~i))+n+s;return(s>32-o)+e}t.MD5=i._createHelper(e),t.HmacMD5=i._createHmacHelper(e)}(Math),P=(M=U).lib,t=P.WordArray,e=P.Hasher,P=M.algo,l=[],P=P.SHA1=e.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=0;a27)+c+l[a];h+=a>5]|=128>9>919)^u>>>10)+_[f-16]);var d=i&n^i&o^n&o,u=l+((c>6)^(c>11)^(c>25))+(c&a^~c&h)+p[f]+_[f],l=h,h=a,a=c,c=s+u|0,s=o,o=n,n=i,i=u+(((i>2)^(i>13)^(i>22))+d)|0}r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0,r[5]=r[5]+a|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128>9>97)+Z+((j=(Z=(J>>>1|$>8|$>7|$>0>>0?1:0))+((G>>>19|V>>6)+((j+=J=(V>>>19|G>>6|G>0>>0?1:0),j+=$=Q.low,N.high=T=T+Y+(j>>>0>>0?1:0),N.low=j);var q=F&W^~F&I,Z=P&O^~P&U,V=A&z^A&D^z&D,G=(H>>>28|A7),J=t1[L],Q=J.high,Y=J.low,$=X+((P>>>14|F>18|F>>14|P>18|P>>0>>0?1:0),J=G+(H&C^H&E^C&E),K=I,X=U,I=W,U=O,W=F,O=P,F=R+(N=(N=(N=N+q+(($=$+Z)>>>0>>0?1:0))+Q+(($=$+Y)>>>0>>0?1:0))+T+(($=$+j)>>>0>>0?1:0))+((P=M+$|0)>>>0>>0?1:0)|0,R=D,M=E,D=z,E=C,z=A,C=H,A=N+(((A>>>28|H7))+V+(J>>>0>>0?1:0))+((H=$+J|0)>>>0>>0?1:0)|0}d=i.low=d+H,i.high=f+A+(d>>>0>>0?1:0),p=n.low=p+C,n.high=u+z+(p>>>0>>0?1:0),y=o.low=y+E,o.high=_+D+(y>>>0>>0?1:0),g=s.low=g+M,s.high=v+R+(g>>>0>>0?1:0),w=c.low=w+P,c.high=B+F+(w>>>0>>0?1:0),m=a.low=m+O,a.high=k+W+(m>>>0>>0?1:0),x=h.low=x+U,h.high=S+I+(x>>>0>>0?1:0),r=l.low=r+X,l.high=b+K+(r>>>0>>0?1:0)},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128>10>10>>24]^n[d>>>16&255]^o[h>>>8&255]^s[255&l]^r[u++],g=i[d>>>24]^n[h>>>16&255]^o[l>>>8&255]^s[255&f]^r[u++],h=_,l=y,f=v,d=g;_=(c[h>>>24]>16&255]>8&255]>24]>16&255]>8&255]>24]>16&255]>8&255]>24]>16&255]>8&255]5]>>>31-i%32&1}for(var n=this._subKeys=[],o=0;o>t^this._rBlock)&e;this._rBlock^=e,this._lBlock^=e>t^this._lBlock)&e;this._lBlock^=e,this._rBlock^=e16],n=this._C=[t[2]>16,4294901760&t[0]|65535&t[1],t[3]>16,4294901760&t[1]|65535&t[2],t[0]>16,4294901760&t[2]|65535&t[3],t[1]>16,4294901760&t[3]|65535&t[0]],r=this._b=0;r8),o=16711935&(c>24)|4278255360&(c>8),s=e>>>16|4294901760&o,c=o16^r[3]>16^r[5]>16^r[7]>16^r[1]16,t[1],t[0]>16,t[2],t[1]>16,t[3],t[2]>16],i=this._C=[t[2]>16,4294901760&t[0]|65535&t[1],t[3]>16,4294901760&t[1]|65535&t[2],t[0]>16,4294901760&t[2]|65535&t[3],t[1]>16,4294901760&t[3]|65535&t[0]],n=this._b=0;n8),o=16711935&(t>24)|4278255360&(t>8),s=e>>>16|4294901760&o,t=o16^r[3]>16^r[5]>16^r[7]>16^r[1]"},{"title":"Web Tool","date":"2022-07-01T11:36:20.567Z","updated":"2022-07-01T11:36:20.567Z","comments":false,"path":"tool/index.html","permalink":"https://blog.x-wang.tech/tool/index.html","excerpt":"","text":"body { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; } #raw-input { display: flex; flex-direction: column; align-items: center; } .output { width: 50%; overflow: auto; margin-bottom: 20px; } .output>span:nth-child(1) { font-weight: bold; } Tool 原始输入 输出 md5 sha1 sha256 base64 var input = document.getElementById('input'); var output = document.getElementById('output'); var md5 = document.getElementById('md5'); var sha1 = document.getElementById('sha1'); var sha256 = document.getElementById('sha256'); var base64 = document.getElementById('base64'); input.addEventListener('input', function (e) { var value = e.target.value; md5.innerText = md5_encode(value); sha1.innerText = sha1_encode(value); sha256.innerText = sha256_encode(value); base64.innerText = base64_encode(value); }); function md5_encode(value) { return CryptoJS.MD5(value).toString(); } function sha1_encode(value) { return CryptoJS.SHA1(value).toString(); } function sha256_encode(value) { return CryptoJS.SHA256(value).toString(); } function base64_encode(value) { return CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(value)); }"}],"posts":[{"title":"计算机视觉","slug":"Review/计算机视觉复习","date":"2023-05-30T16:00:00.000Z","updated":"2023-05-31T10:31:01.987Z","comments":true,"path":"2023/05/31/Review/计算机视觉复习/","link":"","permalink":"https://blog.x-wang.tech/2023/05/31/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"计算机视觉 滤波 高斯核的性质： 使用小方差的高斯核卷积多次和一个大的方差的高斯核卷积效果一样，比如使用方差为\\(\\sigma\\) 的高斯核卷积两次，和使用方差为\\(\\sqrt 2\\sigma\\) 的高斯核卷积一次效果一样。上述关系类似勾股定理，第一次使用 \\(m\\sigma\\)卷积，第二次使用\\(n\\sigma\\)卷积，结果相当于使用\\(\\sqrt{m^2+n^2}\\sigma\\)卷积 高斯卷积核可以分解为x和y方向，分解为两个方向分别卷积 选择卷积核大小：中心左右各3sigma，filter size：\\(2\\cdot3\\sigma +1\\) 中值滤波： 使用卷积核中的中间值作为输出（可以类比max pooling，看作median pooling），可以去除椒盐噪声或白噪声 边缘 Sobel算子：相当于先高斯后梯度 \\[ \\begin{bmatrix} -1 &amp; 0 &amp; 1\\\\ -2 &amp; 0 &amp; 2\\\\ -1 &amp; 0 &amp; 1\\\\ \\end{bmatrix} = \\begin{bmatrix} 1\\\\ 2\\\\ 1\\\\ \\end{bmatrix} \\begin{bmatrix} -1 &amp; 0 &amp; 1 \\end{bmatrix} \\] Riberts算子：Mx检测135°的My检测45° \\[ M_x = \\begin{bmatrix} 0 &amp; 1\\\\ -1 &amp; 0 \\end{bmatrix} \\qquad M_y = \\begin{bmatrix} 1 &amp; 0\\\\ 0 &amp; -1 \\end{bmatrix} \\] 实际使用为了去除噪声，需要先高斯平滑，再提取边缘，这需要两次卷积： image-20230531145355816 为了合并成一次卷积，利用结合率 \\(\\frac{d}{dx} (f * g) = f *\\frac{d}{dx}g\\) （求导也是卷积因此满足结合律，先对高斯求导，使用求导出的东西卷积），出来一个高斯偏导模板，类似高斯核，不过是使用高斯函数的导数去填充，即x方向上使用\\(\\frac{\\partial}{\\partial x} \\frac{1}{2\\pi\\sigma^2} \\exp(-\\frac{x^2+y^2}{2\\sigma^2})\\) 函数填充，y方向类似： image-20230531145436679 最小二乘&amp;RANSAC 最小二乘，检测线，只在垂直方向：对于\\(XB=Y\\)的方程（\\(B=[m\\ b]^T\\)）最优解满足 \\[ X^T XB = X^T Y \\] 对于矩阵乘法：\\(AX=0\\)，那么使矩阵\\(A\\)特征值为0的特征向量就是解。 鲁棒的最小二乘：相当于阈值化距离，当距离过长时对error的贡献和较近的点类似，如下图，可以认为距离10和距离4最终error一样都是1 image-20230530082917155 参数选择：\\(\\sigma\\) 选择最小二乘后的平均残差的1.5倍 RANSAC 迭代次数选择：根据迭代次数和外点率可以求得得到的直线的置信度 \\[ (1-(1-e)^s)^N = 1-p \\] 其中s时估计曲线需要的点的个数，对于直线就是2，e为外点率，不属于直线的点 RANSAC算出一条线后还会将所有内点最小二乘算出最终的线 霍夫变换 求直线：直接用\\(y = ax+b\\)也可以做，但是参数没有边界，同时无法表达垂直的线 因此换成极坐标表示： \\[ x\\cos \\theta+y\\sin\\theta=\\rho \\] \\(\\theta\\)可以在0-180穷举，还可改进，因为直线的点上梯度的方向垂直于线，可以通过梯度进一步缩小theta的搜索范围 噪声处理 选择更好网格或者离散化，如果噪声多可以网格大一点，但是会不够准确 提高邻居格子的评分（软门限），比如投票到某一格子，给该各自周边的bin也根据距离投票，比如中心投票加0.1，距离为1的加0.05，距离为2的加0.01，总分为1 减少外点数：只统计边缘的点和更确定的投票，比如对于直线，只投票梯度theta方向或theta附近方向投票 Harris角点 好的特征的特性： 可靠性，在不同的角度、不同的图片中都能有这个特征 显著性：不能太平庸，得有代表性，不能和别的长得太像 计算高效 只和局部相关 角点检测，通过移动窗口并对前后的窗口相减就可以看出变化 \\[ E(u,v) = \\sum_{x,y} w(x,y) [I(x+u, y+v)-I(x,y)]^2 \\] x,y为窗口内坐标，u,v为窗口移动的距离 将上式用泰勒展开，最后只会留下二阶项（0，1阶为0） \\[ E(u,v)=[u\\quad v]\\begin{bmatrix}E_{uu}(0,0) &amp; E_{uv}(0,0)\\\\ E_{uv}(0,0) &amp; E_{vv}(0,0)\\end{bmatrix} [u\\quad v]^T \\] 由于\\(E_{uu}(0,0) = \\sum_{x,y}2w(x,y)I_x(x,y)I_x(x,y)\\) 其他也可表示为类似的，最终可以表示为 \\[ E(u,v)=[u\\quad v]M [u\\quad v]^T\\\\ M = \\sum_{x,y}w(x,y) \\begin{bmatrix}I_x^2 &amp; I_x I_y\\\\ I_x I_y &amp; I_y^2\\end{bmatrix} \\] 如果我们的角的两边分别和图片的长宽平行，那么M是一个对角矩阵，对应着一个垂直坐标轴的椭圆（因为上述是一个二次项，可以表示为一个椭圆），否则M四个元素都不为0，对应一个旋转的椭圆。我们可以进行对角化将其转化 \\[ M = R^{-1}\\begin{bmatrix}\\lambda_1 &amp; 0\\\\ 0 &amp; \\lambda_2\\end{bmatrix} R \\] 那么最终可以表示为 \\[ E(u,v)&amp;=[u\\quad v] R^{-1} M&#39; R[u\\quad v]^T\\\\ &amp;= (R[u\\quad v])^T M&#39;(R[u\\quad v]^T) \\] 注：因为R正交所以转置和逆相等 这样就相当于把角旋转正。上面的lambda1，2是和椭圆的轴有关，\\(\\sqrt{1/\\lambda}\\) 是轴的长度，lambda越大，轴越短，那么lambda越大那么梯度变化越快 最终可以分为如下情况： lambda1，2都很小，变化都不强烈，所以是平坦区域 lamdba1&gt;&gt;lambda2或反过来，只在一个方向变化大，是边 都很大，是角点 最终判断通过公式： \\[ R = \\det(M) - \\alpha \\trace(M) = \\lambda_1\\lambda_2 - \\alpha (\\lambda_1+\\lambda_2)^2 \\] alpha经验值，取0.04到0.06，用M的行列式，减去M的迹（对角元素和），这样不用求特征值，对于\\(M=\\begin{bmatrix}a&amp;c\\\\c&amp;b\\end{bmatrix}\\) 直接用\\((ab-c^2)-\\alpha(a+b)\\) 最终\\(R&gt;0\\)是角点，\\(R&lt;0\\)是边，\\(R\\approx 0\\) 是平坦区域 总体流程： 计算每个点的梯度（x和y方向的） 计算每个像素的二阶矩矩阵（需要每个像素画个小框计算M，并且用高斯加权，中心权重大，周围权重低） 计算R 根据R的阈值保留可能的角点 非极大抑制（在窗口内取最大的值） 观察代码实现：一半提取梯度和高斯统一使用Sobel完成（因为Sobel可以看作高斯核与梯度核的结合） 特点： 光照或亮度的变换\\(I \\to aI+b\\)，如果整体亮度变化，\\(I \\to I+b\\)，因为只用了导数方向，影响不大但如果\\(I \\to aI\\) 可能导致部分R可能小于或大于门限，对最终结果产生影响 invariance shift平移，比如角在0，0和在5，5，点都会检测出来，但位置会不同，需要经过一个平移变换，因此是covariance（经过一些变换能够对应上） 旋转：同样是covariance 尺度：图像放大缩小：可以考虑极端的，如果一个角放大足够大，也会变得平滑而不是角点，因此不是尺度不变的 SIFT(Blob检测) 出发点：希望找到一种尺度不变的特征（针对角点的缺点），希望这个特征针对尺度是covariance的 可视化：希望找到一个特征选择器，给一个点向周围画圆，到合适大小时这个圆半径得分最高，之前之后都小 image-20230531144754559 回忆之前：找边缘的时候，使用高斯偏导模板对信号卷积，相当于先高斯后偏导，在边缘处得到最大的响应，那么我们如果对高斯求二阶偏导呢？结果如下图： image-20230531145857202 边缘就是过零点的地方，二阶导也叫做拉普拉斯核 高斯核、一阶导、拉普拉斯核都遵循经验公式：filter size=\\(2\\cdot3\\sigma +1\\)，因此只用指定一个参数\\(\\sigma\\) 当我们用固定参数的拉普拉斯核卷积不同大小的信号时，边缘可以看作是一个涟漪，而当信号和核的参数尺度匹配时，两个涟漪叠加形成一个极大值： image-20230531150457845 上图可以看出卷积核参数与信号的匹配性，那么我们如果使用不同的模板参数卷积，找出最大的模板参数就能得到尺度信息。但是使用拉普拉斯卷积，当方差过大时(\\(\\sigma\\))，信号会被衰减，无法比较。 因为高斯偏导模板积分出来面积为 \\(\\frac{1}{\\sigma \\sqrt{2\\pi}}\\) 为了使不受sigma影响，因此应当补偿乘一个sigma，而拉普拉斯是二阶导，因此补偿一个 \\(\\sigma^2\\)，补偿前后效果： image-20230531151730304 将上述卷积结果的中心连在一起看就可以看出本章第一张图的效果，即圆的半径和得分的关系。 需要在x、y方向上分别应用这个核： \\[ \\nabla^2g = \\frac{\\partial^2g}{\\partial x^2}+\\frac{\\partial^2g}{\\partial y^2}\\\\ \\nabla_{\\text{norm}}^2g =\\sigma^2\\left( \\frac{\\partial^2g}{\\partial x^2}+\\frac{\\partial^2g}{\\partial y^2}\\right) \\] 拉普拉斯核方差和图像上半径的关系：\\(\\sigma=r/\\sqrt 2\\)，结论：最大响应时信号的宽度正好和拉普拉斯核的0平面部分宽度一样 image-20230531153213179 使用时使用多个尺度去卷积，得到一系列的尺度表达： 每三个相邻尺度为一组，看中间的的尺度是否是极大的，如果是，那么认为该尺度得到了匹配。（因为是三个相邻尺度比较，所以总体上一个点可能有多次被匹配，一个点画好几个圆）；因为一个点不仅有上下的不同尺度，还有同尺度的不同空间位置，因此在这里非极大抑制，只有中心点比周围26个点都大，才胜出 image-20230531154152541 拉普拉斯如果全图搜索的话，需要做很多不同尺度的卷积，运算量很大，那么有两个个改进： Harris-Laplacian：在角点附近搜索特征点 SIFT：Scale-Invariant Feature Transform SIFT 提出了laplacian的改进：高斯差分DoG，结果和拉普拉斯很像：\\(G(x,y,k\\sigma)-G(x,y,\\sigma) \\approx (k-1)\\sigma^2\\nabla^2G\\) image-20230531155452703 因为高斯核有个性质，大高斯核的卷积结果能够用多次小高斯核的结果得到，减少了卷积运算量（大卷积核运算量更大） 与拉普拉斯的对应关系：\\(\\sigma \\to \\sigma_{lap}\\quad k\\sigma \\to k\\sigma_{lap}\\) ，最终结果只相差一个常数\\(k-1\\)，相差一个常数无所谓，因为最终只对比相对大小，都差一个常数相当于都不差，依次类推 后者：相当于\\(G(x,y,k^2\\sigma)-G(x,y,k\\sigma) = (k-1)(k\\sigma)^2\\nabla^2G\\) 是\\(k\\sigma\\)尺度下的拉普拉斯响应的常数缩放(k-1) image-20230531155901455 同时，利用高斯核的特性：\\(k\\sigma\\)的结果只需要在\\(\\sigma\\)上再用\\(\\sqrt{(k\\sigma)^2-\\sigma^2}\\) 卷积就好，这个卷积核比\\(k\\sigma\\)的卷积核小，提高了效率。 SIFT还把图像缩小到1/2，1/4等等不同大小，这样同样的核卷积出来的结果尺度大多个倍数，也不用更大的卷积核来做，减小了运算量同时检测到了更大尺度的特征。比如使用sigma=1检测到了特征，如果是原图上，这个特征对应的区域半径是\\(\\sqrt2\\)，那么在缩小的图像检测出的，对应到原图上就是半径\\(2\\sqrt2\\)的区域。 因此SIFT不同尺度区域的sigma是通过缩放图像不同倍数得到的，比如1-2的尺度在原图上卷积得到，2-4的尺度在缩小1/2的图上，4-8的尺度在缩小到1/4的图上得到。 k如何设置？\\(k=2^{1/s}\\)，其中s代表最终能输出多少个尺度，上图为例，一共得到了四个高斯差分，每相邻三个高斯差分的中间能得到一个最终的尺度表达，那么四个最终能输出\\(k\\sigma\\)和$k^2\\(2个尺度的表达，因此\\)s=2$ 这样能够形成连续的尺度空间，因此最初的高斯的层数取决于选择的s。 并且对于上图的情况，我们通常把倒数第三层直接下采样，就变成了上一级octave的第一层 有关不变性 拉普拉斯的响应：旋转和尺度不变invariant Blob的位置和尺度是旋转和尺度的协变covariant SIFT对于视角不是不变的，因为视角改变，圆可能变成椭圆 如果想对视角变化有一定鲁棒性：给出圆，然后计算圆内所有像素的M矩阵（Harris角点），看两个特征值，如果两个特征值相差多，把最初的圆在小特征值方向压扁成一个椭圆，再计算椭圆区域的M，重复上述步骤，直到区域内两个特征值差不多。仿射自适应。 我们依据仿射自适应把两个区域变化到一样的大小，可以发现内容基本一致，但是方向不同 为了处理角度不同：基于梯度方向。求出整个SIFT区域每个点的梯度强度和方向，画出梯度方向直方图（0-360分为8份），落到哪个方向范围就在对应的方向范围加上梯度的强度，以此得到信号变化最大的方向，根据这个方向将图旋转使方向归0 为了处理亮度的不同，最终使用梯度描述区域特征：最后把区域分为4*4=16份，同时每个小格分别统计梯度方向直方图，量化为8份（同上），将这8个数作为该小区域的一个描述，一共16个区域形成一个128维的向量作为区域的描述符 SIFT描述符不局限于SIFT算法：Harris+Laplacian也可以得到区域，也可以使用sift描述符表示。 拆分成小格：在局部上做直方图上统计，能够保留一些空间特征（patch顺序保留了一些空间信息） SIFT特征匹配 两张对同一物品的图片如何匹配SIFT特征，两两计算特征距离，但是如何定义门限？ 对于一个特征，看与他匹配的另一张图的特征的第一近邻和第二近邻的距离，如果差异较大，说明匹配成功；如果差异不大说明匹配模糊，可能错误丢弃 纹理","categories":[{"name":"Review","slug":"Review","permalink":"https://blog.x-wang.tech/categories/Review/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://blog.x-wang.tech/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"author":"Xav1er"},{"title":"BUPT 智能交互机器人 Roban和仿真环境","slug":"Course/机器人","date":"2023-03-17T16:00:00.000Z","updated":"2023-03-18T07:54:15.070Z","comments":true,"path":"2023/03/18/Course/机器人/","link":"","permalink":"https://blog.x-wang.tech/2023/03/18/Course/%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"BUPT 智能交互机器人 场景搭建 很重要，如果设置不对运行时会报错 机器人 首先是机器人的模型，需要从别的有机器人的场景中复制，建议从 ~/robot_ros_application/catkin_ws/src/bodyhub/vrep/Roban.ttt 这个场景中复制，这个场景可能是最基本的示例场景 使用CoppeliaSim打开该场景，把场景中的Talos物体完全展开，按住shift加点击，全部选中它的子实体（下图只选了一点） image-20230317180725215 复制到自己新建的场景中。复制之后机器人的轴会凸出来（红色的）不知道如何解决 复制之后，双击打开机器人的仿真环境代码，检查和之前场景(Roban.ttt)中的代码是否一致，这个代码应该是规定了仿真模型如何接受ROS中的信号并且做出对应动作的 image-20230317180915631 场景 很必要，之前就是因为这个没能跑起来 除了机器人有相应的代码，场景也有代码，可能也是处理与ROS通信相关内容的，自建的场景是不带这部分的，需要从Roban.ttt中复制 双击roban.ttt中场景代码，查看代码并复制 image-20230317181212232 之后双击自己新建场景中的代码，进行替换 物理模拟可能需要替换成Newton image-20230317181917755 运行 ROS Interface CoppeliaSim如果需要和ROS通信，需要一个 libsimExtROSInterface.so 动态链接库，但是好像镜像中给的CoppeliaSim没有，重新编译这个库困难重重，因此可以重新从软件官网下载一个新的 12345678# download.shwget https://www.coppeliarobotics.com/files/CoppeliaSim_Edu_V4_1_0_Ubuntu16_04.tar.xztar -xvJf CoppeliaSim_Edu_V4_1_0_Ubuntu16_04.tar.xzrm -rf CoppeliaSim_Edu # 删除前也可以先 cp CoppeliaSim_Edu CoppeliaSim_Edu.bak 复制一遍备份mv CoppeliaSim_Edu_V4_1_0_Ubuntu16_04 CoppeliaSim_Edu 以上脚本下载的是Ubuntu16.04的4.1版本 运行机器人代码 根据给出的示例，仿照 complete.py 中方式运行 所有工作开始前，要先运行 roscore 开启服务（？可能是http） 运行 ~/CoppeliaSim_Edu 中的 coppeliaSim.sh 打开仿真软件 如果要直接打开特定场景，使用 coppeliaSim.sh scene.ttt 其中 scene.ttt 为场景文件路径 运行~/robot_ros_application/catkin_ws/src/ros_actions_node/scripts/game/2022/normal_sim_game/ai_innovative_roban_sim/scripts/auto_run 中的node_start.sh 该脚本内容如下 123456# node_start.shsleep 3srosrun ik_module ik_module_node &amp;. /home/fan/robot_ros_application/catkin_ws/devel/setup.bashecho &quot;121&quot; | sudo -S bash bodyhub.sh &amp; 首先第三行使用rosrun运行 ik_module_node ，之后第五行设置catkin环境，该语句可能执行不成功，在前面加上bash变成 bash /home/fan/robot_ros_application/catkin_ws/devel/setup.bash 第六行使用sudo特权运行 bodyhub.sh bodyhub.sh 中使用roslaunch运行了bodyhub 12# bodyhub.shroslaunch bodyhub bodyhub.launch sim:=True 这两项可能是开启了python程序中给机器人的指令和ros以及仿真环境的通信渠道？ 使用 python filename.py 运行想要运行的python程序。 给的示例程序中，依赖到了 pyaudio 这个库，需要自行pip安装 运行python的时候有可能遇到问题，找不到 lejufunc ，需要创建符号链接。 在 ~/robot_ros_application/catkin_ws/src/ros_actions_node/scripts 中执行命令 1ln -s ../../leju_lib_pkg/src/lejufunc/ lejufunc 还有一个符号链接 lejulib.py 指向 ../../leju_lib_pkg/lejulib.py 也通过这种方法创建","categories":[{"name":"Course","slug":"Course","permalink":"https://blog.x-wang.tech/categories/Course/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"机器人","slug":"机器人","permalink":"https://blog.x-wang.tech/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"author":"Xav1er"},{"title":"3D-CNN学习","slug":"ML/3D-CNN","date":"2022-09-21T12:42:00.000Z","updated":"2022-09-21T13:31:14.509Z","comments":true,"path":"2022/09/21/ML/3D-CNN/","link":"","permalink":"https://blog.x-wang.tech/2022/09/21/ML/3D-CNN/","excerpt":"","text":"3D-CNN学习 2D卷积 传统的2D的 卷积神经网络(CNN) 使用一个卷积核在2D空间上滑动卷积操作 2D单通道卷积 如果是多通道卷积，那么卷积核通道和图片通道数是一致的，并且 不同通道的卷积核参数不同 2D多通道卷积 通过2D的卷积，我们可以感受出，卷积操作实际上是一个卷积核在一个空间中滑动的，滑动重合的部分进行乘weight并加上bias的操作 2D的卷积是在平面空间进行上述操作的，那么，能否将上述操作推广到更广的空间中？ 3D卷积 答案是可以的。 3D-CNN 当我们有很多层的图片 （比如视频中的连续帧）时，将这些二维数据叠在一起，形成一个三维结构，通过在三维空间移动这样的三维卷积核并进行卷积计算，得到卷积的结果，如上图。 3D-CNN-animation 如果传入的为拥有多通道的图片序列（如RGB图片），那么上述卷积核每个位置还要在通道方向上为每个通道拆分出一层，可以理解为 分别对每个通道进行三维卷积操作 与二维卷积的区别 首先卷积核为3维的。虽然多通道的二维卷积中卷积核也可以看成有多个第三维度的层，但这些层在卷积操作中互相独立不产生影响；而三维卷积中卷积核拥有的深度(depth)维度之间会在操作中有加和操作，最终转化为输出结果的一个数 滑动空间是三维空间。3D卷积会在深度方向上滑动并卷积，而2D卷积不存在深度方向。 参考： 2D-CNN和3D-CNN计算 - 掘金 (juejin.cn) 3D Convolutions : Understanding + Use Case | Kaggle 1D &amp; 3D Convolutions explained with… MS Excel! | by Thom Lane | Apache MXNet | Medium","categories":[{"name":"ML","slug":"ML","permalink":"https://blog.x-wang.tech/categories/ML/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://blog.x-wang.tech/tags/Deep-Learning/"},{"name":"CV","slug":"CV","permalink":"https://blog.x-wang.tech/tags/CV/"},{"name":"CNN","slug":"CNN","permalink":"https://blog.x-wang.tech/tags/CNN/"}]},{"title":"操作系统lab问题总结","slug":"Course/操作系统-lab1","date":"2022-09-16T16:00:00.000Z","updated":"2022-09-18T06:38:46.200Z","comments":true,"path":"2022/09/17/Course/操作系统-lab1/","link":"","permalink":"https://blog.x-wang.tech/2022/09/17/Course/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-lab1/","excerpt":"","text":"Lab1 问题 环境问题 最好在Ubuntu运行，安装虚拟机或WSL（教程很多） 执行问题 下载 从 http://web.cecs.pdx.edu/~harry/Blitz/BlitzBin/Ubuntu64/blitztools.tar 下载可执行二进制文件 1wget http://web.cecs.pdx.edu/\\~harry/Blitz/BlitzBin/Ubuntu64/blitztools.tar 之后使用以下命令解压 1tar -xf blitztools.tar 执行 64位Ubuntu无法直接运行，需要先安装32位依赖库 通过 1sudo apt install lib32stdc++6 安装依赖，之后应当能正常执行 在配置好环境变量后（项目指导的pdf有相关内容），输入 1asm 应该输出 1Must use -o option when input is from stdin 编译(STEP 9 kpl) 可能会遇到问题 Illegal character 0x0d 主要是 .c 和 .h 行尾换行符导致的语法解析错误 课程仓库中代码行尾换行符为 CRLF 而 解析器认为合法的换行符为 LF ，多出了 \\r (0x0d) 需要改变换行符 方法一 使用vscode在右下角将 CRLF 替换为 LF 方法二 Linux下使用工具 dos2unix 1sudo apt install dos2unix 安装工具后，按照 dos2unix &lt;filename&gt; 的方式，如 dos2unix HelloWorld.c运行工具，改变换行符 将所有以 .c 和 .h 为后缀的文件修改后，就可以正常运行了。 作业提交 按照word中操作， 首先从课程仓库fork 进入fork出的个人仓库（找不到的话，链接格式为 https://gitee.com/username/osai22/ 或 https://edu.gitee.com/hliang-bupt/repos/username/osai22/sources）将其中的username替换为个人用户名 切换分支到develop 熟悉git的可以直接clone仓库，再复制报告到文件夹后 pull 并 push 不熟悉的同学可以 在 lab1-Upload address 文件夹内 点击上传文件，上传自己的作业文件 上传完成后 在自己的仓库内 点击 请求评审 或 pull request (分别对应高校版和普通版) 从自己仓库的 develop 分支 合并到 课程仓库的develop分支","categories":[{"name":"Course","slug":"Course","permalink":"https://blog.x-wang.tech/categories/Course/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.x-wang.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"Xav1er"},{"title":"python判断黑白图像","slug":"Tech/python判断黑白图像","date":"2022-07-03T04:15:04.000Z","updated":"2022-07-03T11:14:22.704Z","comments":true,"path":"2022/07/03/Tech/python判断黑白图像/","link":"","permalink":"https://blog.x-wang.tech/2022/07/03/Tech/python%E5%88%A4%E6%96%AD%E9%BB%91%E7%99%BD%E5%9B%BE%E5%83%8F/","excerpt":"","text":"python判断黑白图像 12345678def is_grayscale(img:Image): im = img.convert(&quot;RGB&quot;) stat = ImageStat.Stat(im) if sum(stat.sum)/3 == stat.sum[0]: return True else: return False 上述代码通过计算红、绿、蓝三种颜色的和，如果三个和的平均值和任意一个相等(代码中取的是第0个)，那么认为是灰度图（因为灰度图r=g=b） rgb - Python Fastest way to check if image is greyscale or color? - Stack Overflow","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.x-wang.tech/categories/Tech/"},{"name":"snippet","slug":"Tech/snippet","permalink":"https://blog.x-wang.tech/categories/Tech/snippet/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://blog.x-wang.tech/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"python","slug":"python","permalink":"https://blog.x-wang.tech/tags/python/"},{"name":"snippet","slug":"snippet","permalink":"https://blog.x-wang.tech/tags/snippet/"}]},{"title":"git-submodule","slug":"Tech/git-submodule","date":"2022-06-28T07:53:10.000Z","updated":"2022-06-28T07:53:10.512Z","comments":true,"path":"2022/06/28/Tech/git-submodule/","link":"","permalink":"https://blog.x-wang.tech/2022/06/28/Tech/git-submodule/","excerpt":"","text":"什么是Submodule 项目中有时会使用到其他仓库的代码，如果直接clone进项目的子目录，git会在提交更改的时候提示当前git仓库嵌套有一个git仓库，而这是不允许的。 1234567891011121314warning: adding embedded git repository: foo2hint: You&#x27;ve added another git repository inside your current repository.hint: Clones of the outer repository will not contain the contents ofhint: the embedded repository and will not know how to obtain it.hint: If you meant to add a submodule, use:hint:hint: git submodule add &lt;url&gt; foo2hint:hint: If you added this path by mistake, you can remove it from thehint: index with:hint:hint: git rm --cached foo2hint:hint: See &quot;git help submodule&quot; for more information. 还有另一种方法，直接把文件复制进项目目录，而不包含 .git 文件夹。这虽然可行，但是无法跟踪依赖仓库的更新。 这时就需要git submodule了。 submodule能够让另一个仓库作为本仓库的子模块，在clone是可以自动拉取最新的仓库内容，同时修改时也可以很方便的同步修改submodule对应的仓库内容。 如何使用 使用命令 1git submodule add &lt;url&gt; path/of/submodule 命令会自动clone仓库，并将另一个git仓库转化为该仓库的子模块 12345678910git submodule add git@github.com:Xav1erW/Foo.git foo2Cloning into &#x27;/path/to/foo/foo/foo2&#x27;...remote: Enumerating objects: 115, done.remote: Counting objects: 100% (115/115), done.remote: Compressing objects: 100% (68/68), done.remote: Total 115 (delta 39), reused 105 (delta 35), pack-reused 0Receiving objects: 100% (115/115), 3.68 MiB | 313.00 KiB/s, done.Resolving deltas: 100% (39/39), done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directory 此时项目根目录会出现文件 .gitmodules ，内容为子模块的信息 123[submodule &quot;foo2&quot;] path = foo2 url = git@github.com:Xav1erW/Foo.git 如果需要保存，子模块的目录和 .gitmodules 都需要提交保存。 对submodule修改 直接生成的子模块只对应一个 commit id 而不属于任何一个submodule的分支，因此如果需要修改 先 git checkout 到需要修改的分支上； 修改后，在submodule内提交其修改； 之后还需要回到父仓库下提交submodule的修改。 更新submodule 可以直接在父仓库内使用命令 1git submodule foreach git pulll 或者在submodule内进行git pull 操作 。 clone包含submodule的仓库 递归参数 直接克隆不会自动克隆仓库内的submodule，因此需要带上递归参数 1git clone git@github.com:Xav1erW/Foo1.git --recursive submodule init 还可以先clone父仓库，之后在父仓库内使用 1git submodule init 这会将submodule先进行注册 接着更新submodule 1git submodule update","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.x-wang.tech/categories/Tech/"},{"name":"git","slug":"Tech/git","permalink":"https://blog.x-wang.tech/categories/Tech/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.x-wang.tech/tags/git/"},{"name":"git-.submodule","slug":"git-submodule","permalink":"https://blog.x-wang.tech/tags/git-submodule/"}]},{"title":"计算机组成原理复习","slug":"Review/计算机组成原理复习","date":"2022-06-19T16:00:00.000Z","updated":"2022-06-21T14:29:42.339Z","comments":true,"path":"2022/06/20/Review/计算机组成原理复习/","link":"","permalink":"https://blog.x-wang.tech/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"计算机系统概论 数字计算机与模拟计算机 比较内容 电子数字计算机 电子模拟计算机 数据表示方式 0，1 电压 计算方式 数字技术 电压组合或测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑判断能力 强 无 冯诺依曼机 由运算器、存储器、控制器、输入设备和输出设备五个部分组成； 存储器以二进制形式存储指令和数据； 指令和数据放在同一个存储器； 指令由操作码和地址码组成； 存储程序并按地址顺序执行； 冯·诺依曼机的核心设计思想，机器自动化工作 的关键； 以运算器为中心。 控制器 工作周期：取指周期，执行周期 数据字：该字代表要处理的数据； 指令字：该字为一条指令； 指令流：取指周期中，从内存读出的信息流； 数据流：执行周期中，从内存读出的信息流。 区分数据和指令：取指周期拿出来的是指令，执行周期拿出来的是数据。 运算方法和运算器 定点数 假设用n+1位保存一个定点数 纯小数： 有符号：\\(x = x_sx_{-1}\\cdots x_{-n}\\) 范围 \\(0 \\leq |x| \\leq 1-2^{-n}\\) 无符号：\\(x = x_{-1}x_{-2}\\cdots x_{-n-1}\\) 范围 \\(0\\leq x \\leq 1-2^{-n-1}\\) 纯整数： 有符号：范围 \\(|x|\\leq 2^{n}-1\\) 无符号：范围 \\(0 \\leq x \\leq 2^{n+1}-1\\) 原码 定点小数 \\[ [x]_原 = \\left\\{ \\begin{align} &amp;x \\quad &amp;1 &gt; x \\geq 0\\\\ &amp;1-x = 1+|x| \\quad &amp;0 \\geq x &gt;-1 \\end{align} \\right. \\] 定点整数 \\[ [x]_原 = \\left\\{ \\begin{align} &amp;x \\quad &amp;2^n &gt; x \\geq 0\\\\ &amp;2^n-x = 2^n+|x| \\quad &amp;0 \\geq x &gt;-2^n \\end{align} \\right. \\] 特点：0有两种表示方法 整体范围： 小数： \\(-1 &lt; x &lt; 1\\) 整数： \\(-2^n &lt; x &lt; 2^n\\) 补码 定点小数 \\[ [x]_补 = \\left\\{ \\begin{align} &amp;x \\quad &amp;1 &gt; x \\geq 0\\\\ &amp;2+x = 2-|x| \\quad &amp;0 \\geq x \\geq-1 \\end{align} \\right. \\] 定点整数 \\[ [x]_补 = \\left\\{ \\begin{align} &amp;x \\quad &amp;2^n &gt; x \\geq 0\\\\ &amp;2^{n+1}+x = 2^{n+1}-|x| \\quad &amp;0 \\geq x \\geq -2^n \\end{align} \\right. \\] 0有唯一表示方法 补码的补码就是原码 除2可以直接通过右移 最小值是 \\(100000\\cdots\\) 原码求补码 方法1：除符号位各位取反加一 方法2：从最低位开始，遇到的第一个1以前的各位保持不变，之后各位取反。 相反数的补码 已知 [x]补求[-x]补 连符号位一起各位求反，末位加1。 移码 把真值平移\\(2^n\\) 个单位 \\[ [x]_移 = 2^n+x \\] 与补码符号位相反 可以比较直观地判断两个数据的大小 表示浮点数阶码时，容易判断是否下溢； 真值 x(十进制) 真值 x(二进制) [x]原 [x]反 [x]补 [x]移 –127 –0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 –1 –0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 +1 + 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 +127 + 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 浮点数 \\[ N = R^e \\times M \\] M尾数，纯小数 R基数，默认是2 e阶码，指定小数点位置 规格化 保证表示唯一 要求： \\(1/R \\leq M &lt; 1\\) 尾数向左移n位(小数点右移)，同时阶码减n； 尾数向右移n位(小数点左移)，同时阶码加n。 尾数用原码表示时：尾数数值最高数值位为1； 尾数用补码表示时：尾数最高数值位和尾数符号位相反； IEEE754 32位：1位数符，8位阶码（包括符号），23位尾数 64位：1位数符，11位阶码（包括符号），52位尾数 尾数原码表示，由于规格化最高位为1，因此隐藏最高位的1. 32位阶码为移127码：\\(E = e+127\\) ，真值为 \\[ N = (-1)^S \\times (1.M) \\times 2^{E-127} \\] 64位 \\[ N = (-1)^S \\times (1.M) \\times 2^{E-1023} \\] 特殊值： 正负零：\\(E = 0;\\ M=0\\) 正负由符号决定 正负无穷： \\(E = 1111\\cdots; \\ M = 0\\) 正负由符号决定 真正指数的范围：-126~+127 符号位S 阶码E 尾数M 数值N 0/1 0 =0 0 0/1 0 ≠0 \\((-1)^S\\times(0.M)×2^{-126}\\) 0/1 1~254 ≠0 \\((-1)^S\\times(1.M)×2^{E-127}\\) 0/1 255 ≠0 NaN（非数值） 0/1 255 =0 \\((-1)^S\\times \\infty\\) 运算 补码加法 整数 \\([x+y] = [x]+[y] (\\mod 2^{n+1})\\) 小数 \\([x+y] = [x]+[y] (\\mod 2)\\) 补码减法 整数 \\([x-y] = [x]-[y] = [x]+[-y] (\\mod 2^{n+1})\\) 小数 \\([x-y] = [x]-[y] = [x]+[-y] (\\mod 2)\\) \\([-y]\\) 等于 \\([y]\\) 按位取反（包括符号位）再+1 溢出问题 直接判别法 同号补码相加，结果符号位与被加数相反；溢出 异号补码相减，结果符号位与被减数相反；溢出 硬件实现复杂 变形补码判别法 变形补码：也叫模4补码：采用双符号位表示补码 双符号位 结果 00 正 01 上溢 10 下溢 11 负 硬件实现简单，只需对结果符号位进行异或 进位判别法 判别方法：最高数值位的进位与符号位的进位是否相同； 溢出标志 \\[ V = C_f \\oplus C_{n-1} \\] 其中 \\(C_f\\) 为符号位进位；\\(C_{n-1}\\) 为数值最高位进位。 image-20220620153117043 加减法电路统一： 加入控制信号M，M和输入B的每一位为异或关系，当M为1的时候，\\(B&#39; = \\neg B\\) ；同时M作为进位输入，完成求-B的补码操作。 image-20220620153801436 多位加法器延迟时间 \\[ t_a = n\\cdot 2T+9T = (2n+9)T \\] 如果不考虑溢出就为 \\[ t_a= [2(n-1)+9]T \\] 定点乘法 分析手算乘法步骤 image-20220620154257830 乘法 = 加法+位移 原码并行乘法 \\[ a = \\sum_{i=1}^{m-1} a_i 2^i \\qquad b = \\sum_{j=0}^{n-1}b_j2^j \\] 相乘得到 \\[ p = ab =\\left(\\sum_{i=1}^{m-1} a_i 2^i\\right) \\left(\\sum_{j=0}^{n-1}b_j2^j\\right) = \\sum_{i=1}^{m-1}\\sum_{j=0}^{n-1}(a_ib_j)2^{i+j} \\] \\(A_i\\cdot b_j\\)部分乘积项（位积）叫做一个被加数。\\(M\\times N\\)个被加数用与门并行产生(a AND b) 时间 \\[ t_m = (8n-4)T \\] 阵列乘法器 image-20220620155108703 有符号乘法 \\[ A \\cdot B = (a_n \\oplus b_n) (a_{n-1}\\cdots a_0 \\times b_{n-1}\\cdots b_0) \\] 使用3个求补器，分别用对应的符号位控制： 2个算前求补器：将两个操作数真值绝对值送入运算器； 1个算后求补器：乘积为负时把结果变成带符号数； 两相反数的补码特征： 自右向左，第一个“1”的右侧所有数据位，均相同； 左侧所有数据位，均相反。 对2求补器电路逻辑：采用按位扫描技术来执行求补操作；E为控制信号线，可由数据a的符号位来控制； image-20220620155610968 乘法器结构： image-20220620155745544 定点除法 可控加法/减法(CAS)单元：用于加减交替法的除法器中；由控制端P选择运算类型：P=0，作加法运算；P=1，作减法运算 四个输入： 被加/减数Ai 减数Bi 低 位进/借位Ci 控制端P 四个输出： 加/减数Bi 当位和/差Si 向高位的进/借位Ci+1 控制端P 除法器结构：（被除数6位，除数3位） image-20220620160215240 执行时间 \\[ t_d = 3(n+1)^2T \\] 在加减交替的除法阵列中，每一行所执行的操作究竟是加法还是减法，取决于前一行输出的符号与被除数的符号是否一致。当出现不够减时，部分余数相对于被除数来说要改变符号。这时应该产生一个商位“0”，除数首先沿对角线右移，然后加到下一行的部分余数上。当部分余数不改变它的符号时，即产生商位“1”，下一行的操作应该是减法。 image-20220620160943308 浮点数加减运算 步骤： 零操作数检查 一个操作数为0，则不必运算，节省运算时间 两操作数对阶 使小数点位置对齐，为加减运算做准备 尾数相加减 以双符号位的补码形式进行加减法操作 结果的规格化 结果的舍入处理 结果的溢出判断 对阶 以较大的阶码为标准，调整阶码较小的数据； 求阶差\\(\\Delta E ＝ E_X－E_Y\\) 调整阶码较小的数据 若\\(\\Delta E &gt;0\\)，则MY右移\\(\\Delta E\\)位，结果的阶码为\\(E_X\\) 若\\(\\Delta E &lt;0\\)，则MX右移\\(|\\Delta E|\\)位，结果的阶码为\\(E_Y\\) 结果的规格化处理 两尾数加减的结果有两种情况: 尾数溢出：两符号位为01或10，则右规 ；尾数右移1位，阶码加1 尾数为非规格化数据，则左规 ；尾数左移1位，阶码减１，直至数值位最高位与符号位相反。 结果的舍入处理 在对阶或右规操作时，会使加数或结果的尾数低若干位移出， 影响精度，常用两种舍入处理方法： 方法1：0舍1入法 保留右移时的移出位，若最高位为１，则尾数加１；否则舍去； 特点：精度较高，但需要记录所有的移出位。 方法2：恒置1法 若之前步骤有右移操作，则直接将结果的最低位置1; 特点：精度较0舍1入法较低，但应用简单。 结果的溢出判断 尾数溢出 在规格化处理时，通过完成右规完成； 阶码溢出 上溢(结果绝对值太大)——置上溢标志，结束； 下溢(结果绝对值太小)——置机器零； 正常——运算结束； 浮点乘除法运算 浮点数乘除运算的步骤 0操作数检查； 阶码加/减操作； 尾数乘/除操作； 结果规格化、舍入和溢出处理； 内部存储器 存储容量：存储单元个数×存储字长 存储速度： 存取时间(访问时间)：从启动一次访问操作到完成该操作为止所经历的时间；以ns为单位，存取时间又分读出时间、写入时间两种。 存取周期：存储器连续启动两次独立的访问操作所需的最小间隔时间。以ns为单位，存取周期=存取时间+复原时间 存储器带宽：每秒从存储器进出信息的最大数量；单位为位/秒或者字节/秒。 只读存储器又分为掩膜 ROM、一次可编程 ROM(PROM)和可擦除PROM(EPROM)，后者又分为紫外线擦除EPROM(UV-EPROM)、电擦除EPROM(EEPROM或 E2PROM)和闪速(Flash)只读存储器。 当一个存储字的字长高于八位时，就存在一个存储字内部的多字节的排列顺序问题，其排列方式称为端模式。大端(big-endian)模式将一个字的高有效字节放在内存的低地址端，低有效字节放在内存的高地址端，而小端(little-endian)模式则将一个字的低有效字节放在内存的低地址端，高有效字节放在内存的高地址端。 SRAM 静态RAM（SRAM）：由MOS电路构成的双稳触发器保存二进制信息； 优点：访问速度快，只要不掉电可以永久保存信息； 缺点：集成度低，功耗大，价格高； 动态RAM（DRAM）：由MOS电路中的栅极电容保存二进制信息； 优点：集成度高，功耗约为SRAM的1/6，价格低； 缺点：访问速度慢，电容的放电作用会使信息丢失，要长期保存数据必须定期刷新存储单元；主要种类有：SDRAM、DDR SDRAM 基本的静态存储元阵列 芯片封装后，3种外部信号线： 地址线：2n个单元，对应有n根地址线； 地址信号经过译码电路，产生每个单元的字线选通信号； 数据线：每个单元m位，对应有m根数据线； 控制线：读写控制信号：R/W =1，为读操作； R/W=0，为写操作； 地址：单译码和双译码 image-20220620170725756 DRAM 存储的信息 1 或 0 则是由电容器上的电荷量来体现——当电容器充满电荷时，代表存储了 1，当电容器放电没有电荷时，代表存储了 0。 image-20220620170816151 1M×4 位 DRAM 芯片的外部引脚图。 与 SRAM 不同的是，图中增加了行地址锁存器和列地址锁存器。由于 DRAM 容量很大，地址线的数目相当多，为减少芯片引脚的数量，将地址分为行、列两部分分时传送。存储容量为 1M 字，共需 20 位地址线。此芯片地址引脚的数量为 10 位，先传送行地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器；然后传送列地址码 A10～A19，由列选通信号CAS 打入到列地址锁存器。片选信号的功能也由增加的 RAS 和 CAS 信号实现。 image-20220620170905183 与SRAM对比 外部地址引脚比SRAM减少一半：送地址信息时，分行地址和列地址分别传送； 内部结构：比SRAM复杂 刷新电路：用于存储元的信息刷新； 行、列地址锁存器：用于保存完整的地址信息：行选通信号 （Row Address Strobe）、列选通信号 （Columns Address Strobe） DRAM的读写周期：与SRAM的读写周期相似，只是地址总线上的信号有所不同；在同一个读写周期内发生变化，分别为行地址、列地址； 刷新 DRAM 存储位元是基于电容器上的电荷量存储信息的，DRAM 的读操作是破坏性的，读操作会使电容器上的电荷流失，因而读出后必须刷新。而未读写的存储元也要定期刷新，因为电荷量会逐渐泄漏而减少。 在固定时间内对所有存储单元，通过“读出(不输出)—写入” 的方式恢复信息的操作过程； 当前主流的 DRAM 器件的刷新间隔时间(刷新周期)为 64ms 自动刷新：刷新计数器的宽度等于行地址锁存器的宽度。由于自动刷新不需要给出列地址，而行地址由片内刷新计数器自动生成，故可利用 CAS 信号先于 RAS 信号有效来启动一次刷新操作，此时地址线上的地址无效。 刷新过程中存储 器不能进行正常的读写访问 集中式刷新策略中，每一个刷新周期中集中一段时间对 DRAM 的所有行进行刷新。由于刷新操作的优先级高，刷新操作时正常的读/写操作被暂停，数据线输出被封锁。等所有行刷新结束后，又开始正常的读/写周期。由于在刷新的过程中不允许读/写操作，集中式刷新策略存在“死时间”。 分散式刷新策略中，每一行的刷新操作被均匀地分配到刷新周期时间内。将每个系统工作周期分为两部分，前半部分用于DRAM读/写/ 保持，后半部分用于刷新存储器的一行； 存储扩展 位扩展 例如：由1K×4的存储芯片构成1K×8的存储器 存储芯片与CPU的引脚连接方法： 地址线：各芯片的地址线直接与CPU地址线连接； 数据线：各芯片的数据线分别与CPU数据线的不同位连接； 片选及读写线：各芯片的片选及读写信号直接与CPU的访存及读写信号连接； 字扩展 字扩展：每个单元位数不变，总的单元个数增加。例如：用1K×8的存储芯片构成2K×8的存储器 存储芯片与CPU的引脚连接方法： 地址线：各芯片的地址线与CPU的低位地址线直接连接； 数据线：各芯片的数据线直接与CPU数据线连接； 读写线：各芯片的读写信号直接与CPU的读写信号连接； 片选信号：各芯片的片选信号由CPU的高位地址和访存信号产生； 计算字位扩展所需的存储芯片的数目 用L×K的芯片构成M×N的存储系统：所需芯片总数为 \\[ M/L \\times N/K \\] 扩展的时候可以使用74LS138等选择器 ROM 其访问速度比 RAM 稍低，可以按地址随机访问并在线执行程序，因而在计算机中用于储存固件、引导加载程序、监控程序及不变或很少改变的数据。“只读”的意思是在其工作时只能读出，不能写入。 掩模式ROM 定义：数据在芯片制造过程中写入，不能更改； 优点：可靠性、集成度高，价格便宜； 缺点：通用性差，不能改写内容； 一次编程ROM（PROM） 定义：用户第一次使用时写入确定内容； 优点：用户可根据需要对ROM编程； 缺点：只能写入一次，不能更改； 多次编程ROM 定义：可用紫外光照射（EPROM）或电擦除（E2PROM） 多次改写其中内容； 优点：通用性较好，可反复使用； 闪速存储器（Flash Memory） 定义：一种高密度、非易失性的读/写半导体存储器，它突破了 传统的存储器体系，改善了现有存储器的特性。 在EPROM功能基础上，增加了电路的电擦除 和重新编程能力；也叫快擦型存储器。 有关存储器选择 系统程序区默认为写死的，因此使用ROM，用户程序需要修改因此使用RAM。 存储器设计的连接要点 参考存储扩展 片选线的连接 一般使用CPU的高位地址线的和CPU的访存允许控制信号 线/MREQ，经译码器译码后产生各芯片的片选信号。 关键点，也是最容易出错的地方。 并行存储器 双端口存储器 双端口存储器采用空间并行技术：同一个存储体使用两组相互独立的读写控制线路，可并行操作。 显卡上的存储器一般都是双端口存储器。 读写特点 无冲突读写：访问的存储单元不同，可并行读写存储体； 有冲突读写：访问同一存储单元，可使用/BUSY信号控制读写优先顺序； 多模块交叉存储器 顺序方式 访问地址按顺序分配给一个模块后，接着又按顺序为下一个模块分配访问地址。这样，存储器的 32个字可由 5 位地址寄存器指示，其中高 2 位选择 4 个模块中的一个，低 3 位选择每个模块中的 8 个字。 在顺序方式中某个模块进行存取时，其他模块不工作。而某一模块出现故障时，其他模块可以照常工作。另外通过增添模块来扩充存储器容量也比较方便。但顺序方式的缺点是各模块一个接一个串行工作，因此存储器的带宽受到了限制。 交叉方式 每个模块的单元地址是 不连续的；连续地址分 布在相邻的不同模块内。 对于数据的成块传送， 各模块可以实现多模块 流水式并行存取； 当存储器寻址时，用地址寄存器的低 2 位选择 4 个模块中的一个，而用高 3 位选择模块中的 8 个字。 image-20220620175154754 二者带宽计算 模块数为m，存储周期为T，总线周期 \\(\\tau\\) 连续传送m个字： 顺序： \\(m*T\\) 交叉：\\(T+(m-1)*\\tau\\) Cache Cache的作用： 在CPU和主存之间加一块高速的SRAM（Cache）； 主存中将要被访问的数据提前送到Cache中； CPU访存时，先访问Cache，若没有再进行数据调度。 使用Cache的依据：在一段时间内，CPU所执行的程序和访问的数据大部分都在 某一段地址范围内，而该段范围外的地址访问很少；（程序访问的局部性原理） CPU 与 cache 之间的数据交换是以字为单位，而 cache 与主存之间的数据交换是以块为单位。一个块由若干字组成，是定长的。 image-20220620180201780 当 CPU 读取内存中一个字时，便发出此字的内存地址到 cache 和主存。此时 cache 控制逻辑依据地址判断此字当前是否在 cache 中：若是，则 cache 命中，此字立即传送给 CPU；若非，则 cache 缺失(未命中)，用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到cache 中。 读操作 CPU发出有效的主存地址： 经地址变换机构，变换为可能的Cache地址； 查找块表，判断所要访问的信息是否在Cache中； 若在，则CPU直接读取Cache获取数据； 若不在，则CPU访问主存，并判断Cache是否已满； 若Cache未满，将该数据所在块从主存中调入Cache； 若Cache已满，使用某种替换机制，使用当前数据块替换 掉Cache中的某些块。 写操作 CPU发出有效的主存地址： 经地址变换机构，变换为可能的Cache地址； 找对应的相联存储器，判断所要访问的信息是否在Cache中； 若不在，则使CPU直接写主存数据； 若在，则使用某种写策略将数据写入Cache。 cache的命中率 命中率 = 访问信息在Cache中的次数 / 访问总次数 影响命中率的主要因素 Cache 容量： 过小时，局部信息装不完，命中率低。 过大时，对提高效率不明显，且成本高。 Cache中块的大小： 一般用一个主存周期所能调出的单元数（字或字节）作 为一个块大小。 Cache/主存系统的平均访问时间\\(t_a\\)为 \\[ t_a = ht_c + (1-h)t_m \\] tc ——命中时的cache访问时间 tm ——未命中时的主存访问时间 h ——命中率 设 \\(r = t_m/t_c\\) 访问效率为 \\[ e = \\frac{t_c}{t_a} = \\frac{t_c}{ht_c + (1-h)t_m} = \\frac{1}{h + (1-h)r} = \\frac{1}{r + (1-r)h} \\] 平均访问时间同样也可以计算为 \\[ t_a = t_c/e \\] 地址映射 cache 与主存的数据交换是以块为单位。为了把主存块放到 cache 中，必须应用某种方法把主存地址定位到 cache 中，称为地址映射。“映射”一词的物理含义是确定位置的对应关系，并用硬件来实现。这样当 CPU 访问存储器时，它所给出的一个字的内存地址会自动变换成 cache 的地址，即 cache 地址变换。 全相联映射方式 cache 的数据块大小称为行，用 \\(L_i\\) 表示，其中 \\(i=0,1,2,…,m–1\\)，共有 $m=2^r $行。主存的数据块大小称为块，用 $B_j $ 表示，其中 $ j=0,1,2,…,n–1$ ，共有 $n=2^s $块。行与块是等长的，每个块(行)由 \\(k=2^w\\) 个连续的字组成，字是 CPU 每次访问存储器时可存取的最小单位。 主存中的任意字块可调进cache的任一行中； 当主存的数据块调入Cache中时，该块的块号（主存标记） 保存于调入Cache行的对应标记位（即块表中） 块表的大小应为\\(2^c×m\\)位，c为行地址长度，m为块地址长度 在全相联映射中，将主存中一个块的地址(块号)与块的内容(字)一起存于 cache 的行 中，其中块地址存于 cache 行的标记(tag)部分中。这种带全部块地址一起保存的方法，可使主存的一个块直接复制到 cache 中的任意一行上，非常灵活。 image-20220620181718030 特点： 优点： 灵活性好(最理想)，Cache中只要有空行，就可以调入所需要的主存数据块； 缺点： 成本高：标记位为m位，使cache标记容量变大； 速度太慢：访问cache时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在cache中； 一般较少使用。 直接映射 主存中的每一块数据只能调入Cache的特定行中； 地址映射函数为 \\[ i = j\\mod 2^c \\] image-20220620184431080 地址格式： 主存共\\(2^n\\)个单元，分成\\(2^m\\)个块，每块单元数为\\(2^b\\)个：主存地址为m+b位； Cache空间分成\\(2^c\\)行，每行大小也应为\\(2^b\\)单元：Cache地址为c+b位； 直接映射中主存块与Cache行的关系： 主存的\\((2^m/ 2^c)= 2^{m-c}\\)个块映射于Cache的同一行； 主存地址中的c位决定该主存块对应的Cache行，m-c位为 主存标记； 块表的大小应为\\(2^c×(m-c)\\)位； 主存的地址格式为： image-20220620184925945 特点： 一个主存块只能调入cache的一个特定行中 。 优点：该映射函数实现简单，查找速度快； 主存地址的中间c位即为Cache的行地址； 在对应的块表中使用高t位地址进行比较，决定是否命中； 缺点：灵活性差； 主存的2t个字块只能对应唯一的Cache字块，即使Cache 中别的字块空着也不能占用。 image-20220620185701996 若CPU发出的主存地址为0000 01 001； 先取高4位地址（主存标记0000）送往比较器的一端； 再用中间的2位地址（Cache行号01），在块表中取出该单 元中保存的主存标记送往比较器的另一端； 若二者相等，则为命中，直接访问Cache的第01行中地址 为001的单元，读取数据； 若二者不相等，则为未命中； 组相联映射 组相联映射是直接映射和全相联映射的一种折中方案。 映射关系：将Cache中的行等分为若干组，主存中的每一块只能映射 到Cache的特定组中，但是可调入到该组的任一行中； 组间为直接映射，组内为全相联映射。 设Cache共u组，每组v行，则映射函数如下 \\[ q = j \\mod u \\] 当Cache的一组包含r行时，通常称为r路组相联映射。 image-20220620195000670 特点： 灵活性：比直接映射灵活（主存可映射到组内任一块）； 快速性：比全相联比较次数少，只需组内全部比较； image-20220620195959199 替换策略： 最不经常使用(LFU)算法 替换原则：将一段时间内被访问次数最少的那行数据替换出去； 使用方法 每行设置一个计数器，从0开始计数; 每访问一次， 被访行的计数器增1; 当需要替换时，将计数值最小的行换出，同时将这些行的计数器都清零。 特点：这种算法将计数周期限定在对这些特定行两次替换之间的间 隔时间内，不能严格反映近期访问情况。 近期最少使用(LRU)算法 替换原则：将近期内长久未被访问过的行替换出去。 使用方法 每行也设置一个计数器; 每访问一次，被访行的计数器清零，其它各行计数值1； 当需要替换时，将计数值最大的行换出。 特点：这种算法保护了刚拷贝到cache中的新数据行，使Cache的使用率较高。 随机替换算法 替换原则：从特定的行位置中随机地选取一行换出。 特点：在硬件上容易实现，且速度也比前两种策略快。但降低了命中率和cache工作效率。 写策略 写回式 写入策略：只修改cache的内容，而不立即写入主存；只有当此行被换出时才写回主存。 优点：减少了访问主存的次数 缺点：存在Cache与主存不一致性的隐患。 实现该方法时，cache行必须配置一个修改位，以反映此行是否被CPU修改过。 全写式 这种策略又称写透式 写入策略：cache与主存同时发生写修改，因而较好地维护了cache与主存的内容的一致性。cache中每行无需设置一个修改位以及相应的判断逻辑。 缺点：降低了cache的功效。 写一次法 写入策略： 基于写回法，并结合全写法的写策略; 写命中与写未命中的处理方法与写回法基本相同， 只是第一次写命中时要同时写入主存。 第一次写命中时，启动一个主存的写周期，其目的是 使其它Cache可以及时更新或废止该块内容，这便于 维护系统全部cache的一致性 指令系统 操作码 两地址指令的分类： SS（存储器-存储器） RR 这种指令结构常用于算术逻辑运算类指令 RS 操作码扩展 image-20220620210635102 指令字长度 机器字长：运算器一次能处理的二进制数的位数。机器指令的长度直接决定着CPU运算的精度和直接寻址能 力的大小； 指令字长：一个指令字中包含二进制代码的位数； ¡指令字长由操作码长度、操作数长度和个数共同决定。指令有半字长、单字长、双字长、多字长等不同的长度类型；指令系统可分为等长指令字结构、变长指令字结构两种。 寻址方式 指令寻址 顺序寻址方式：当程序按顺序执行时的指令寻址方式； 必须用程序计数器记录所要执行指令的存放单元地址； 一般做顺序加1的操作； 程序计数器又称指令指针寄存器； 跳跃寻址方式：当程序转移执行时的指令寻址方式；程序计数器的内容由本条指令给出，而不是顺序改变。 操作数的寻址方式 隐含寻址 立即寻址 直接寻址 间接寻址 寄存器寻址 寄存器间接寻址 偏移寻址 堆栈寻址； image-20220620211148581 偏移寻址 相对寻址： 隐含引用的专用寄存器是程序计数器(PC)，即 EA=A+(PC)，它是当前 PC 的内容加上指令地址字段中 A 的值。一般来说，地址字段的值在这种操作下被看成 2 的补码数的值。因此有效地址是对当前指令地址的一个上下范围的偏移，它基于程序的局部性原理。使用相对寻址可节省指令中的地址位数，也便于程序在内存中成块搬动。 基址寻址 ：被引用的专用寄存器含有一个存储器地址，地址字段含有一个相对于该地 址的偏移量(通常是无符号整数)。寄存器的引用可以是显式的，也可以是隐式的。基址寻址也利用了存储器访问的局部性原理。后面讲到的段寻址方式中，就采用了段基址寄存器，它提供了一个范围很大的存储空间。 变址寻址 ：地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，与基址寻址刚好相反。但是二者有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如，主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时值 A 存入指令地址字段，再用一个变址寄存器(初始化为 0)。每次操作之后，变址寄存器内容增 1。此时，EA=A+(R)，R←(R+1)。 基址寻址把 寄存器中的作为基础，指令中给出偏移量 变址寻址把 指令中的地址作为基础，寄存器给出偏移量 段寻址 微型机中采用了段寻址方式，例如，它们可以给定一个20 位的地址，从而有 220=1MB 存储空间的直接寻址能力。为此将整个 1MB 空间存储器按照最大长度 64KB 划分成若干段。在寻址一个内存具体单元时，由一个基地址再加上某些寄存器提供的 16 位偏移量来形成实际的 20 位物理地址。这个基地址就是 CPU 中的段寄存器。在形成 20 位物理地址时，段寄存器中的 16 位数会自动左移 4 位，然后与 16 位偏移量相加，即可形成所需的内存地址。这种寻址方式的实质还是基址寻址。 image-20220620211746817 中央处理器 CPU的功能 CPU（中央处理器）：控制程序按设定方式执行； CPU的主要功能： 指令控制：控制程序的执行顺序；顺序寻址、跳跃寻址 操作控制：产生和发送各操作信号；对指令操作码译码后产生控制信号 时间控制：控制指令、或操作的实施时间；维持各类操作的时序关系 数据加工：对数据进行算术逻辑运算；由ALU完成具体的运算 image-20220620212327176 指令周期 指令周期：CPU从内存中取出一条指令，并执行的时间总和 CPU周期：又称机器周期，一般为从内存读取一条指令字的最短时间；一个CPU周期可以完成CPU的一个基本操作。 时钟周期：也叫节拍脉冲或T周期，是计算机处理操作的基本时间单位。 image-20220620212637023 不同指令的指令周期所包含的 时钟周期个数不一定相同。 MOV R1, R2 LAD R1, ADDR 从数据存储器单元取出数据装入通用寄存器R 三个CPU周期： 取指周期 间址周期：从IR的地址码字段获 取操作数地址；（或 者通过计算获得EA） 执行周期：访存获取操作数送入 通用寄存器R1； image-20220620213324658 ADD R1 , R2 取指周期（略） 执行周期 从寄存器R1、R2中取出数据，作为源操作数； 将两数据送往ALU，并使ALU进行加运算； 结果保存到R1中 STO R2 , (R3) STO指令是RS型指令，需要3个CPU周期。存数指令 R2 -&gt; [R3] 取指周期（略） 间址周期：根据R3中的地址寻址所要访问的存储单元； 执行周期：将寄存器R2中的数据送入指定的存储单元； JMP 两个周期： 取指 执行：直接给PC赋值 微指令和微程序 控制存储器（CM）：存放实现全部指令系统的微指令；由只读存储器构成，要求速度快，读出周期短。 微指令寄存器：存放由控制存储器读出的一条微指令信息； 微地址寄存器：决定将要访问的下一条微指令的地址； 微命令寄存器：保存一条微指令的操作控制字段和判别测试字 段的信息。 地址转移逻辑 顺序控制部分的P1、P2为判别测试标志； 若为00，则顺序寻址微指令； 若为01、10，则跳跃寻址微指令。 微操作在执行部件中是最基本的操作。由于数据通路的结构关系，微操作可分为相容 性和相斥性两种。所谓相容性的微操作，是指在同时或同一个 CPU 周期内可以并行执行的微操作。所谓相斥性的微操作，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。 CPU周期与微指令周期关系 微指令周期：读出微指令的时间加上执行该条微指令的时间；串行方式的微程序控制器中的概念； 一般来讲，一个微指令周期时间设计得恰好和CPU 周期时间相等。 image-20220620222820709 机器指令与微指令的关系 一条机器指令对应一个微程序，一个微程序由若干条微指 令序列组成的；一条机器指令所完成的操作划分成若干条微指令来完成， 由微指令进行解释和执行。 从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者与内存有关，后者与控制存储器有关。 每一个CPU周期对应一条微指令。 微程序设计技术 微命令编码 直接表示法：操作控制字段中的每一位代表一个微命令； 优点：简单直观，其输出可直接用于控制，执行速度快； 缺点：微指令字较长，因而使控制存储器容量较大。 编码表示法：将微指令操作控制字段划分为若干个子字段；每个子字段的所有微命令进行统一编码；每个子字段的不同编码表示不同的微命令； image-20220620223233590 遵循原则： 把相斥的微命令划分在同一个字段中，相容的微命令划分 在不同字段； 字段的划分应与数据通路结构相适应； 每个子字段应留出一个空操作状态； 每个子字段所定义的微命令不宜太多； 优点：可大大缩短微指令字长； 缺点：需要微命令译码，故微程序的执行速度稍稍减慢。 微地址的形成方法 计数器方式：同CPU中程序计数器产生机器指令地址的方法相类似。 优点：微指令的顺序控制字段较短，微地址产生机构简单。 缺点：多路并行转移功能较弱，速度较慢，灵活性较差。 多路转移方式：可根据“判别测试”标志和“状态条件”信息选定某 一个候选微地址的方法。 特点：能以较短的顺序控制字段配合，实现多路并行转移， 灵活性好，速度较快； 但转移地址逻辑需要用组合逻辑方法设计 微指令格式 水平型微指令：一次能定义并执行多个并行操作微命令的微指令；一般由操作控制字段、判别测试字段、下地址字段三部分构成；根据控制字段编码方式的不同，可分为全水平型、字段译码法水平型、直接和译码相混合的水平型三种微指令。 垂直型微指令：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能；垂直型微指令的结构类似于机器指令的结构。在一条微指令中只有 1～2 个微操作命令，每条微指令的功能简单，因此，实现一条机器指令的微程序要比水平型微指令编写的微程序长得多。它是采用较长的微程序结构去换取较短的微指令结构。 水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。 水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。 由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反，微指令字较短而微程序长。 水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。 流水CPU image-20220620224644452 数据相关 在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是数据相关的。 写后读(RAW)相关；应当前一个指令写入数据再读数据，流水线导致未写入就读出。 读后写(WAR)相关；需要先读出内容并写入，之后再修改之前读出的内容，流水线导致先修改再读。 写后写(WAW)相关。两个都要写入，但之后的先完成，先写入，发生错误。 总线系统 构成计算机系统的互联机构，是系统内各功能部件之间进行 信息传送的公共通路。 总线宽度：一次总线操作中，最多可传送的数据位数。 总线周期：一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T=1/f 总线带宽：单位时间内通过总线的数据位数，总线的数据传输率；单位一般为MB/s。 单总线结构：系统内的所有部件均由系统总线连接； 双总线结构：系统内的所有部件均由系统总线连接；在CPU和主存之间再 专门设置了一组高速的存储总线。 三总线结构：系统总线负责连接CPU、主存、I/O通道；存储总线负责连接 CPU与主存；I/O总线负责连接各I/O适配器。 总线的仲裁 集中式：由中央仲裁器决定总线使用权的归属。 分布式：多个仲裁器竞争使用总线。 集中式 image-20220620224812519 计数器定时查询方式：设备的优先权由计数值决定，计数值为0时同链式查询方式； 每次计数可以从“0”开始，也可以从中止点开始。如果从“0”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。计数器的初值也可用程序来设置，这就可以方便地改变优先次序，显然这种灵活性是以增加线数为代价的。 image-20220620225551800 分布式 分布式仲裁不需要中央仲裁器，由分布在各部件中的多个仲裁 器竞争使用总线。 每个潜在的主模块都有自己的仲裁器和唯一的仲裁号，通过仲 裁总线上仲裁号的比较，决定可占用总线的部件。 某部件有总线请求时，将其仲裁号发送到共享仲裁总线上； 每个仲裁器将仲裁总线上得到的号与自己的号进行比较； 如果仲裁总线上的号大，则它的总线请求不予响应，并撤 消它的仲裁号； 最后，获胜者的仲裁号保留在仲裁总线上。 分布式仲裁是以优先级仲裁策略为基础。 image-20220620225243489 . 外围设备 磁盘存储设备 在磁表面存储器中，信息的读写是利用磁头来进行的； 磁头：由软磁材料做铁芯，绕有读写线圈的电磁铁。 写操作：原理：电-磁变换；利用磁头写线圈中的脉冲电流，在磁表面每个存储元上形 成不同的磁化状态； 读操作：原理：磁-电变换；利用磁头读线圈， 将磁表面每个存储 元上的不同剩磁状 态转换成电信号读出； 硬磁盘按盘片结构，分成可换盘片式与固定盘片式两种；磁头也分为可移动磁头和固定磁头两种。 可移动磁头固定盘片的磁盘机 特点是一片或一组盘片固定在主轴上，盘片不可更换。盘片每面只有一个磁头，存取数据时磁头沿盘面径向移动。 固定磁头磁盘机 特点是磁头位置固定，磁盘的每一个磁道对应一个磁头，盘片不可更换。优点是存取速度快，省去磁头找道时间，缺点是结构复杂。 可移动磁头可换盘片的磁盘机 盘片可以更换，磁头可沿盘面径向移动。优点是盘片可以脱机保存，同种型号的盘片具有互换性。 温彻斯特磁盘机 温彻斯特磁盘简称温盘，是一种采用先进技术研制的可移动磁头固定盘片的磁盘机。它是一种密封组合式的硬磁盘，即磁头、盘片、电机等驱动部件乃至读写电路等组装成一个不可随意拆卸的整体。工作时，高速旋转在盘面上形成的气垫将磁头平稳浮起。优点是防尘性能好，可靠性高，对使用环境要求不高，成为最有代表性的硬磁盘存储器。而普通的硬磁盘要求具有超净环境，只能用于大型计算机中。 磁盘上信息的分布 记录面：磁盘片表面；一个盘片有上下两个记录面。 磁道：记录面上一系列同心圆； 最外圈为0磁道 ，依次为1、2、……、N磁道； 每个磁道的存储容量均相同； 不同盘片的相同磁道构成一个柱面； 扇区：同心圆上的一段磁道区域；每个扇区的存储容量也相同。 image-20220621090432994 技术指标 存储密度 道密度：沿磁盘半径方向单位长度上的磁道数；单位：道/英寸。 位密度：磁道单位长度上能记录的二进制代码位数；单位：位/英寸。注意：每个磁道的位密度均不相同，有最高、最低位密度。 0磁道的位密度为最低位密度； 面密度：位密度和道密度的乘积；单位：位/平方英寸。 存储容量：一个磁盘存储器所能存储的字节总数； 存储容量=记录面数×每面磁道数×磁道容量 非格式化容量：磁记录表面可以利用的磁化单元总数。 格式化容量：按照某种特定的记录格式所能存储信息的总量，也就是用户可以真正使用的容量。格式化容量一般是非格式化容量的60%—70%。 平均存取时间：从读/写指令发出到开始第一笔数据读/写时所用的平均时间 平均访问时间近似等于平均寻道时间+平均等待时间，即平均寻址时间。 平均等待时间：与磁盘转速有关，是磁盘旋转一周时间的一半。 \\[ T_a = T_s + \\frac{1}{2r} + \\frac{b}{rN} \\] Ts平均寻道时间，b传送字节数，N每磁道字节数，r转速。 1/2r 平均等待时间；b/rN 数据传输时间 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数； 设磁盘旋转速度为每秒n转，磁道容量为N个字节：数据传输率Dr= n × N（字节/秒） 设某磁道位密度为D字节/英寸，磁盘转速为v英寸/秒，则数据传输率Dr= D × v （字节/秒） 有关描述 内外径说的都是 直径 编址例子： image-20220621092504834 输入输出系统 程序查询方式 工作过程：CPU传送数据之前先检查外设的状态，若没有准备好，则继续查询等待，直至外设就绪即进行数据传送。 硬件要求：只需接口电路的状态、数据口，不需增加其他控制电路。 特点：CPU主动查询，程序控制数据传送过程，简单易行；每次查询之后只能传送一个字或一个字节的数据，数据传输率不高，CPU时间浪费较多。 适用场合：CPU不太忙且对传送速度要求不高的系统。 统一编址方式 将I/O系统与主存系统作为一个整体进行编址 优点：访问I/O端口可使用访存指令，操作类型多样使用灵活；I/O端口有较大的编址空间； 缺点：占用主存空间，使实际主存容量减小；I/O访问的指令字长较长，执行速度慢。 独立编址方式 将/O系统与主存系统分别编址； 特点：I/O端口地址不占用主存空间；使用专用的I/O指令，指令字长短，执行速度快；与主存空间区分容易。 image-20220621093936528 可通过改变查询顺序修改设 备的优先权；CPU工作效率低； 程序中断 工作过程：CPU有传送要求时，启动外设后可处理其他事件，当外设准就绪后，通过中断的方式和CPU完成数据传送工作。 硬件要求：需要附加的中断控制电路。 特点：一定程度上实现了CPU和外设的并行工作；中断操作过程增加了软硬件的开销，且每次数据传送只能传送一个字或一个字节的数据，数据传送效率低 适用场合：CPU与慢速外设之间的数据传送。 机器内部原因导致出错引起的中断叫内中断，也叫异常。外部设备请求服务的中断叫外中断。 流程 中断请求：CPU在结束一个指令周期后，检测中断请求信号； 中断响应 关中断； 保护断点现场； 判断中断源，获取中断向量； 根据中断向量转入中断服务程序执行； 中断服务 保护CPU现场； 执行中断服务程序； 开中断； 恢复CPU现场； 中断返回：恢复断点现场，返回主程序继续执 中断服务程序入口地址的获取 向量中断 ：中断机构自动将相应中断源的中断向量地址送入 CPU，包括段地址和段内偏移地址， 共4个字节的内容 CPU响应中断时，将中断源对应的中断向量送入CS（段地 址）、IP（段内偏移地址）寄存器中，以跟踪中断服务程序 的执行。 一般而言，系统中所有的中断向量都按顺序存放在内存指定位置的一张中断向量表中，当 CPU 识别出某中断源时，由硬件直接产生一个与该中断源对应的中断向量地址，以便能快速在中断向量表中找到并转入中断服务程序入口。 image-20220621094643232 上图可知，中断类型号(n) × 4 ＝ 中断向量在表中的偏移地址 image-20220621094754589 程序中断方式的基本 I/O 接口 image-20220621094845232 单级中断系统 所有的中断源都属于同一个级别，不允许有中断嵌套； image-20220621095013634 向量中断：由硬件直接产生一个与该中断源对应的向量地址； 向量地址——中断源的中断服务程序入口地址； 要求：在硬件设计时考虑所有中断源的向量地址。 位移量中断：由硬件直接产生一个位移量，该位移量加上CPU中某寄存器中的基地址，得到中断处理程序的入口地址。 向量地址转移：由硬件直接产生一个该中断源对应的固定地址码，该地址码中存放可转入中断服务程序的入口地址。 多级中断 根据各中断事件的轻重缓急程度不同而分成若干级别，每一中断级分配给一个优先权。一般说来，优先权高的中断级可以打断优先权低的中断服务程序，以程序嵌套方式进行工作。 多级中断中需要进行优先权的控制和判断。 image-20220621095303010 改变优先级的方法：修改屏蔽字 欲使第2级中断的优先权高于第3级：则可设置第3级中的屏蔽字设为：00001011第2级中的屏蔽字设为：00001111 image-20220621095351474 不可屏蔽中断NMI 由CPU的NMI引脚引入该中断请求，CPU得到该中断请求立即响应，不需要CPU发响应信号； 中断类型号固定为2； 中断优先权高于可屏蔽中断INTR，一般用于系统对紧急情况的处理，用户不能使用； 常见的NMI中断： 系统RAM奇偶校验错、 I/O通道校验错、 协处理器出错等。 可屏蔽中断INTR 由CPU的INTR引脚引入该中断请求； 该中断请求只有在CPU的中断允许标志位IF=1时，CPU才会通过发回响应信号的方式响应； CPU对INTR中断的响应控制可由STI（允许响应INTR中断）、CLI（禁止响应INTR中断）两条指令完成。 此类中断的中断类型号由中断源提供； 常见的INTR中断： 外部设备的中断请求，如I/O设备的数据传送请求，用户可自行设计； 指令中断INTN 由CPU执行在程序中预先安排好的中断指令引起的；该中断是可预期的、且不可屏蔽的； 处理该中断时，CPU不需要发响应信号； 指令的操作数字段（n）即为中断类型号； 中断类型号的范围为5≤n≤255； 这类中断包括BIOS中断、DOS中断以及一些未定义的自由中断（可由系统扩充或根据应用需要自定义）。 异常中断 由CPU内部的突发事件引起的中断，是不可屏蔽中断； 其中断类型号固定； 除法错中断一一类型号为0；执行除法指令时，除数为0，或除得的商大于规定位数； 单步中断——类型号为1； 断点中断——类型号为3； 溢出中断——类型号为4； 该类中断的实质：由CPU运行过程中的突发事件引起系统在适当位置自动添加一条中断指令，然后由CPU执行该指令引起的中断； 同指令中断一样，处理该中断时，CPU不需要发响应信号。 image-20220621100318360 直接内存访问 工作过程：CPU分配总线使用权之后，在硬件DMA控制器（DMAC）的控制下完成存储器与高速外设之间的大量数据的传送。 硬件要求：需要相应的DMA控制器及数据通路，电路结构复杂，硬件开销大。 特点：数据传送不需要经过CPU，直接由硬件控制；外设与存储器之间的数据传送量大。 适用场合：：包含有高速外设的系统中。 DMA（直接内存访问）方式磁盘与主存之间的数据传送，完全由硬件控制执行I/O交换的工作方式；DMAC完全接管系统总线的控制权，利用总线控制数据在主存和外设之间的直接传送，所交换的数据不经过CPU。 特点：速度快，但硬件复杂度高。 DMA方式中，DMAC的工作：接受外设的DMA请求，并提交给CPU；接管总线的控制权，控制主存和外设之间的数据传送；完成数据传送后，交还总线使用权。 DMA传送时，CPU不能使用总线，会影响CPU的工作效率； 当CPU需要访存，或者访问外设时，程序会阻塞； 可使DMAC与CPU分时复用总线； 停止CPU访问方式 工作过程：DMA传送期间，由DMAC长期占用总线，CPU不能访存，只有DMA传送结束时才将总线归还给CPU使用； 特点：控制简单，适于高速外设的数据成组传送；内存使用效率不高。（一般外设的读写周期远大于主存的存取周期） 周期挪用方式 工作过程：每次DMA传送，都是通过外设挪用一个或几个主存周期， 分别完成数据的成块传送。 特点：主存使用效率较高，常用； I/O 设备要求 DMA 传送时可能遇到两种情况：一种是此时 CPU 不需要访内，如 CPU 正在执行乘法指令。由于乘法指令执行时间较长，此时 I/O 访内与 CPU 访内没有冲突，即I/O 设备挪用一两个内存周期对 CPU 执行程序没有任何影响。另一种是 I/O 设备要求访内时CPU 也要求访内，这就产生了访内冲突，在这种情况下 I/O 设备访内优先，因为 I/O 访内有时间要求，前一个 I/O 数据必须在下一个访内请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一两个内存周期，意味着 CPU 延缓了对指令的执行，或者更明确地说，在 CPU执行访内指令的过程中插入 DMA 请求，挪用了一两个内存周期。 DMA与CPU交替访存方式 如果 CPU 的工作周期比内存存取周期长很多，则采用交替访内的方法可以使 DMA 传 送和 CPU 同时发挥最高的效率； 假设 CPU 工作周期为1.2μs，内存存取周期小于 0.6μs，那么一个 CPU 周期可分为 C1 和 C2 两个分周期，其中 C1专供 DMA 控制器访内，C2 专供 CPU 访内。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过 C1 和 C2 分时控制的。 CPU 和 DMA 控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控 制寄存器。 工作过程：将CPU的工作周期一分为二，分别用于DMA和CPU访存； 特点：对主存的访问时间不会发生冲突，也不需要总线控制权的申请建立和归还过程； 也称为“透明DMA方式”；DMA传送不影响CPU的工作； image-20220621101304899 DMA数据传送过程 DMA请求 DMAC向CPU请求总线使用权； DMA响应 CPU给DMAC分配总线使用权； DMA传送 DMAC寻址外设和存储器； DMAC控制外设与主存之间的数据传送，并检测是否传送结束； DMA结束 ODMAC归还总线使用权。 和中断控制方式的区别 数据传送的实现方式 中断——程序传送；DMA——硬件实现； CPU响应请求的时间 中断——一个指令周期结束；DMA——一个总线周期结束； 请求的目的 中断——CPU的服务；DMA——总线的使用权； 是否需要保护现场 中断——需要；DMA——不需要（CPU不参与数据传送）； DMA的优先权高于中断的优先权。 通道方式 工作过程：CPU将IO控制的权利下放给通道，由通道统一管理所有的输入输出操作。 硬件要求：需要IO通道（也称IO处理器，IOP）；通道是一个具有特殊功能的处理器。 特点：硬件代价较高；lO传送的效率高，并且减轻了CPU的工作负担。 适用场合：高性能要求的系统中。","categories":[{"name":"Review","slug":"Review","permalink":"https://blog.x-wang.tech/categories/Review/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://blog.x-wang.tech/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"Xav1er"},{"title":"形式语言与自动机复习","slug":"Review/形式语言与自动机复习","date":"2022-06-17T16:00:00.000Z","updated":"2022-06-22T01:41:23.451Z","comments":true,"path":"2022/06/18/Review/形式语言与自动机复习/","link":"","permalink":"https://blog.x-wang.tech/2022/06/18/Review/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"字母表 注意区分\\(\\epsilon\\) 和 \\(\\varnothing\\) \\(\\epsilon\\) 是一个长度为0的句子 \\(\\varnothing\\) 是空集 乔姆斯基文法体系 0型文法 即文法 $ G(V,T,P,S)$ 称为 短语结构文法(PSG) 1型文法 对于0型文法G有 \\[ \\forall \\alpha \\to \\beta \\in P, \\quad |\\beta| \\geq |\\alpha| \\] 称为1型文法或 上下文有关文法(CSG) 2型文法 对于1型文法G有 \\[ \\forall \\alpha \\to \\beta \\in P, \\quad |\\beta| \\geq |\\alpha| 并且 \\alpha \\in V \\] 称为2型文法或 上下文无关文法(CFG) 3型文法 对于2型文法G \\[ \\forall \\alpha \\to \\beta \\in P, \\quad \\alpha \\to \\beta 具有形式\\\\ A \\to w\\\\ A \\to wA \\] 其中 \\(w \\in T^+\\) 称为3型文法或 正则文法 (RG) 文法类型 \\(\\forall \\alpha \\to \\beta\\) 0（短语结构） 无限制 1（上下文有关） \\(|\\beta| \\geq |\\alpha|\\) 2（上下文无关） \\(|\\beta|\\geq |\\alpha|\\) 并且 \\(\\alpha \\in V\\) 3（正则） \\(A \\to w\\\\A \\to wA\\) 从上到下是包含关系 正则文法最简形式 定理：L是RL充要条件是存在文法，其产生式要么形如 \\(A \\to a\\) 要么形如 \\(A \\to aB\\) 线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to wBx\\) 其中 \\(w, x \\in T^*\\) 右线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to wB\\) 其中 \\(w, x \\in T^*\\) 左线性文法 \\(\\forall \\alpha \\to \\beta \\in P\\) 均具有形式 \\(A \\to w\\) \\(A \\to Bw\\) 其中 \\(w, x \\in T^*\\) 定理：左线性文法充要条件：其产生式要么形如 \\(A \\to a\\) 要么形如 \\(A \\to Ba\\) 定理：左线性文法与右线性文法等价 语言识别 回溯 遍历所有的推导 有限自动机 \\[ M = (Q, \\Sigma, \\delta, q_0, F) \\] \\(Q\\) 状态集合 \\(\\Sigma\\) 输入字母表 \\(\\delta\\) 状态转移函数 \\(q_0\\) 开始状态 \\(F\\) 终止状态 DFA 每个输入字符有确定的状态转移 即时描述 \\(\\delta (q_0, x) = q\\) 那么 \\(xqy\\) 称为一个即时描述，表示 xy是正在处理的字符串，当前到达状态q，M正准备处理y的第一个字符 \\(\\alpha \\vdash_M^n \\beta\\) 表示从即时描述 \\(\\alpha\\) 移动n次到达即时描述 \\(\\beta\\) ，上标同样可以使用 *、+ 如果 xqay 是M的一个即时描述，且 \\(\\delta (q, a) = p\\) 那么 \\(xqay \\vdash_M xapy\\) 定义 ：状态的字符串集合：从初始状态能引导状态机到达状态的字符串集合 \\[ \\text{set}(q) = \\{x|x\\in \\Sigma^*, \\delta(q_0, x)=q\\} \\] 定义：\\(R_M\\) 等价关系： \\[ \\forall x,y \\in \\Sigma^*, xR_My \\Leftrightarrow \\exists q \\in Q \\quad s.t.\\\\ x \\in \\text{set}(q) \\quad \\text{and} \\quad y \\in \\text{set}(q) \\] 上述是等价关系，能够将 \\(\\Sigma^*\\) 分成不多于 \\(|Q|\\) 个等价类 NFA 与DFA等价 从NFA到DFA NFAtoDFA 带空移动的NFA \\(\\epsilon\\) 闭包 \\[ \\epsilon-\\text{CLOSURE}(q) = \\{p|从q到p有一条标记为\\epsilon的路径\\} \\] 对状态集合同样也有闭包概念 \\[ \\hat \\delta (q,a) = \\hat \\delta (a,\\epsilon a) = \\epsilon-\\text{CLOSURE}(P)\\\\ P =\\{p|\\exists r \\in \\hat\\delta(q, \\epsilon) s.t. p \\in \\delta(r,a\\} \\\\ = \\bigcup_{r\\in \\hat \\delta(q,\\epsilon)} \\delta(r,a) \\] 由带空移动的NFA构造等价NFA 取NFA \\(M_2 = (Q, \\Sigma, \\delta_2, q_0, F_2)\\) 其中 \\[ F_2 \\left\\{ \\begin{align} &amp;F \\cup \\{q_0\\} \\quad &amp;\\text{如果} F\\cap \\epsilon-\\text{CLOSURE}(q_0)\\neq 0\\\\ &amp;F \\quad &amp;\\text{如果} F\\cap \\epsilon-\\text{CLOSURE}(q_0)= 0 \\end{align} \\right. \\] 对于 \\(\\forall (q,a) \\in Q \\times \\Sigma\\) 使 \\(\\delta_2(q,a) = \\hat \\delta_1(q,a)\\) 其实就是，写出 \\(\\hat \\delta\\) 的表，把空移动去除，按照表中集合连线，再按照上述步骤判断一下终止状态都有哪些。 如 \\(q_0\\) 的 0移动有 \\(q_0, q_1, q_2\\) ，那么局部的NFA有 graph LR q0((q0)) q1((q1)) q2((q2)) q0 --0-->q0 q0 --0-->q1 q0 --0-->q2 其余状态同理。 FA接收的语言是RG DFA转RG 构造方法 \\[ P = \\{q \\to ap | \\delta (q,a) = p\\} \\cup \\{q \\to a | \\delta (q,a) = p\\in F\\} \\] 例如： image-20220619104853348 RG转DFA 每个变量看成一个状态， 如果派生为 \\(A \\to wB\\) 的形式，那么DFA就为 A --w--&gt; B 的形式。 如果派生为 \\(A \\to w\\) 的形式，那么DFA就为 A --w--&gt; Z 的形式，其中Z代表终止状态。 可以用下式表示 \\[ \\delta(A,a) = \\left\\{ \\begin{align} &amp;\\{B|A \\to aB \\in P\\}\\cup\\{Z\\} \\quad &amp;\\text{if } A \\to a \\in P \\\\ \\\\ &amp;\\{B|A \\to aB \\in P\\} \\quad &amp;\\text{if } A \\to a \\notin P \\end{align} \\right. \\] image-20220619114104790 左线性文法转DFA 左线性文法 \\(G(V,T,P,S)\\) 无空串 FA为 \\(M=(V\\cup\\{Z\\}, T,\\delta,Z,\\{S\\})\\) 此处Z为初始状态 \\(\\forall (a,B) \\in T\\times V\\) 如果 \\(A \\to Ba \\in P\\) 那么 \\(\\delta (B,a)=A\\) 如果 \\(A \\to a \\in P\\) 那么 \\(\\delta (Z,a)=A\\) image-20220619114529002 DFA转左线性文法 预处理DFA 删除陷阱状态 图中添加Z作为文法开始变量 复制一条原本到达终止状态的弧，使其从原本状态出发到Z 构造文法 如果 \\(\\delta (A,a) = B\\) 则有 \\(B \\to Aa\\) 如果 \\(\\delta (A,a) = B\\) 且A是开始状态，则有 \\(B \\to a\\) image-20220619120727042 FA的变形 2DFA \\[ M = (Q,\\Sigma,\\delta,q_0,F) \\] \\(\\delta: \\ Q\\times \\Sigma \\to Q \\times \\{L,R,S\\}\\) image-20220619121354622 2NFA 类似2DFA Moore机 六元组 \\[ M = (Q,\\Sigma,\\Delta,\\delta,\\lambda,q_0) \\] \\(\\Delta\\) 输出字母表 \\(\\lambda: Q \\to \\Delta\\) 输出函数 ，状态 \\(q\\) 输出对应字符 image-20220619124315215 Mealy机 六元组 \\[ M = (Q,\\Sigma,\\Delta,\\delta,\\lambda,q_0) \\] \\(\\Delta\\) 输出字母表 \\(\\lambda: Q\\times \\Sigma \\to \\Delta\\) 输出函数 ，\\(\\lambda(q,a)=d\\) 表示在状态 q 读入字符 a，输出字符d Moore机和Mealy机等价 正则表达式 优先级：闭包&gt;乘&gt;加 运算律 结合律 分配律：\\(r(s+t) = rs+rt\\) 交换律：\\(r+s = s+r\\) 幂等律：\\(r+r=r\\) 零元素与空元素 \\(r+\\varnothing = r\\) \\(r\\epsilon = \\epsilon r = r\\) \\(r\\varnothing = \\varnothing r = \\varnothing\\)关于这点和上一点，看二者的定义 ，结合分配律理解 \\(L(\\varnothing) = \\varnothing\\) \\(L(\\epsilon) = \\{\\epsilon\\}\\) \\(L(\\varnothing^*) = \\{\\epsilon\\}\\) 因为 \\(L(\\varnothing^0) = \\{\\epsilon\\}\\) \\(L((r^*s^*)^* = L((r+s)^*)\\) RE与FA等价 RE转NFA 基本的例子 image-20220619154853677 image-20220619155341031 根据以上例子，给出 \\(r=r_1+r_2;\\quad r=r_1r_2;\\quad r=r_1^*\\) 构造方法 加法构造 image-20220619155635676 乘法构造 image-20220619155707763 闭包构造 image-20220619155737263 DFA转RE 预处理 给开始和终止加上X、Y状态 去掉所有不可达状态 对图操作 并弧：将从q到p的标记为\\(r_1,r_2,\\cdots,r_g\\)并⾏弧用从q到p的、标记为\\(r_1+r_2+\\cdots +r_g\\) 的弧取代这g个并⾏弧。 去状态1：如果从q到p有⼀条标记为\\(r_1\\)的弧，从p到t有⼀条标记为\\(r_2\\)的弧，不存在从状态p到状态p的弧，将状态p和与之关联的这两条弧去掉，用⼀条从q到t 的标记为\\(r_1r_2\\)的弧代替。 去状态2：如果从q到p有⼀条标记为\\(r_1\\)的弧，从p到t有⼀条标记为\\(r_2\\)的弧，从状态p 到状态p标记为\\(r_3\\)的弧，将状态p和与之关联的这三条弧去掉，用⼀条从q 到t的标记为\\(r_1r_3^ *r_2\\)的弧代替。 去状态3：如果图中只有三个状态，⽽且不存在从标记为X的状态到达标记为Y的状 态的路，则将除标记为X的状态和标记为Y的状态之外的第3个状态及其相 关的弧全部删除。 从标记为X的状态到标记为Y的状态的弧的标记为所求的正则表 达式。如果此弧不存在，则所求的正则表达式为 \\(\\varnothing\\) 正则语言表示方法转化 image-20220619161300327 正则语言的性质 泵引理 由于DFA中状态个数是有穷的， 所以在处理⼀个足够长的句⼦的过程中，必定会重复地经过某⼀个状态。 image-20220619161639784 设L为RL，那么对应有DFA \\(M = (Q,\\Sigma,\\delta,q_0,F)\\) 假设有N个状态。 那么 \\(z = a_1a_2\\cdots a_m\\quad m \\geq N\\) 由于一共N个状态，状态序列 \\(q_0,q_2,\\cdots ,q_N\\) 有N+1状态，会有两个状态重复。不妨假设 \\(q_k = q_j\\) $$ (q_0, a_1a_2a_k)=q_k \\ (q_k, a_{k+1}a_j)=q_j = q_k \\ (q_j, a_{j+1}a_m)=q_m \\ 因此i \\ (q_k, (a_{k+1}a_j)^i) = q_j=q_k $$ 因此可以理解为 \\(a_1\\cdots a_k (a_{k+1}\\cdots a_j)^i a_{j+1}\\cdots a_m \\in L(M)\\) 设 \\[ u= a_1a_2\\cdots a_k\\\\ v = a_{k+1}\\cdots a_j\\\\ w = a_{j+1}\\cdots a_m \\] 那么 \\(uv^iw \\in L\\) 由于 \\(k&lt;j\\leq N\\) 所以 \\(|uv| = j \\leq N, \\ |v|\\geq 1\\) 引理(泵引理) L为RL，则存在仅依赖于L的正整数N \\(\\forall z \\in L\\) 如果 \\(|z|\\geq N\\) 则存在u、v、w满足 z = uvw \\(|uv| \\leq N\\) \\(|v|\\geq 1\\) 对于任意整数 \\(i \\geq 0 \\quad uv^iw \\in L\\) N不大于接受L的最小DFA的状态数。 利用泵引理证明一个语言不是RL 首先假设该语言是RL，则其应该满足泵引理，选任意的N. 找到一个语言中的句子\\(z=L(|z|\\geq N)\\). 任选满足z=uvw，其中\\(|v| \\geq 1\\)，且\\(|uv|\\leq N\\)的u,v,w 找到一个\\(i\\geq 0\\)，证明使\\(uv^iw\\notin L\\). 推出矛盾说明该语言不满足泵引理，从而说明该语言不是RL。 image-20220619163240817 泵引理用来证明一个语言不是RL 不能用泵引理去证明一个语言是RL 正则语言的封闭性 定理：RL在并、乘积、闭包运算下是封闭的 定理：RL 在补运算下是封闭的。 DFA \\(M&#39;=(Q,\\Sigma, \\delta, q_0, Q-F)\\) 对应着正则语言的补集 定理：RL 在交运算下是封闭的。 正则代换 \\(\\Sigma\\quad \\Delta\\) 是两个字母表，映射 \\(f:\\Sigma \\to 2^{\\Delta^*}\\) 称为是代换，如果 \\(\\forall a \\in \\Sigma \\quad f(a)\\)是\\(\\Delta\\) 上的RL，那么称为正则代换。 先将f定义域扩展到 \\(\\Sigma^*\\) 上 \\(f(\\epsilon) = \\{\\epsilon\\}\\) \\(f(xa) = f(x)f(a)\\) 再扩展到 \\(2^{\\Sigma^*}\\) \\(f(L) = \\bigcup_{x\\in L} f(x)\\) image-20220619164535126 定理：L是Σ上的RL，那么正则代换f满足 \\(f(L)\\) 也是RL 定义：对于字母表\\(\\Sigma\\)和\\(\\Delta\\)，\\(f: \\Sigma \\to \\Delta^*\\) 如果 \\(\\forall x, y \\in\\Sigma^*\\quad f(xy) = f(x)f(y)\\) 则称为同态映射 L的同态像： \\[ \\forall L \\subset \\Sigma^*\\quad f(L) = \\bigcup_{x\\in L}f(x) \\] \\(\\forall w \\in \\Delta^* \\quad \\forall L \\subset \\Delta^*\\) 同态原像是一个集合 定义：商 \\(L_1/L_2 = \\{x|\\exists y \\in L_2 \\quad s.t.\\ xy\\in L_1\\}\\) 主要用来考虑句子后缀 Myhill-Nerode 等价关系 同样表述为 \\(xR_M y \\Leftrightarrow \\delta(q_0,x) = \\delta(q_0,y)\\) 语言确定的等价关系： \\(xR_L y \\Leftrightarrow (\\forall x \\in \\Sigma^*, xz\\in L \\Leftrightarrow yz \\in L)\\)；x,y后不管接什么串z，要么都是L的句子，要么都不是 右不变的等价关系：如果 \\(x\\ R\\ y\\) 那么 \\(\\forall z \\in \\Sigma^*\\) 必有 \\(xz\\ R\\ yz\\) \\(R_M\\) 和 \\(R_L\\) 都是右不变的。 R是 \\(\\Sigma^*\\) 上的等价关系， \\(\\Sigma^* / R\\) 表示等价关系分开的集合数量，称为\\(R\\)关于 \\(\\Sigma^*\\) 的指数 \\(R_M\\) 的分割更细致，因此称 \\(R_M\\) 是 \\(R_{L(M)}\\) 的加细 Myhill-Nerode定理：如下三个命题等价 L是RL L是\\(\\Sigma^*\\) 上某一个具有有穷指数的右不变等价关系R的某些等价类的并 \\(R_L\\) 具有有穷指数 证明该语言不是RL最方便的方法就是证明\\(R_L\\)的指数是无穷的 例： 证明 \\(\\{0^n1^n|n\\geq 0\\}\\)不是RL image-20220619171833963 极小化DFA 算法步骤 标记终止状态和其余非终止状态可区分 从第一个状态开始迭代标注它与其余状态是否可区分： 如果状态对转移后的关联状态对可区分，那么该状态对可区分 如果关联状态对没有被标注，那么将该关联状态加入关联状态链表（基于一个双向链表实现）（对状态列表的保存有冗余设计，每次向前添加时，实际会新建链表，即如果有一链表 q0-&gt;q3-&gt;q2，那么 q3-&gt;q2，q0-&gt;q3-&gt;q2都会被保存） 如果迭代到的状态对被标记，那么寻找以该状态对开始关联列表，并将关联列表上之后的状态都标记上 上述步骤会标记完成可区分状态表，接着合并不可区分状态，将不可区分的状态放入一个集合中： 遍历可区分状态表中的所有状态对 如果两状态对不可区分，那么遍历最终的不可区分状态 如果能在不可区分状态里找到某个集合包含状态对中的一个元素，那么将该状态对元素添加到这个集合中 如果不能，则从状态对元素新建一个集合，加入不可区分状态中。 对于上述得到的新的可区分状态（每个可区分状态可能包含多个不可区分状态），逐个遍历其中的不可区分状态，得到最终针对新可区分状态的状态转移函数。 image-20220619172230661 正则语言判定定理 定理：DFA \\(M=(Q, \\Sigma, \\delta, q_0,F)\\) 对应语言为非空的充要条件是： \\[ \\exists x \\in \\Sigma^*, \\quad |x|&lt;|Q|, \\delta(q_0,x) \\in F \\] 定理：DFA \\(M=(Q, \\Sigma, \\delta, q_0,F)\\) 对应语言为无穷的充要条件是： \\[ \\exists x \\in \\Sigma^*, \\quad |Q|\\leq|x|&lt;2|Q|, \\delta(q_0,x) \\in F \\] 可以联系泵引理 定理：设DFA \\(M_1=(Q_1,\\Sigma,\\delta_1,q_{01},F_1)\\)，DFA \\(M_2=(Q_2,\\Sigma,\\delta_2,q_{02},F_2)\\)，则存在判定M1与M2是否等价的算法。 定理：设L是字母表上的RL，对任意\\(x\\in \\Sigma^*\\)，存在判定x是不是L的句子的算法。 上下文无关语言 定义 派生树： 顶点的顺序：V1，V2是派生树T的两个不同顶点，如果存在顶点v，v至少有两个儿子，使得v，是v的较左儿子的后代，v，是v的较右儿子的后代，则顶点v在顶点v2的左边，顶点v2在顶点v，的右边。 派生树的结果： 派生树T的所有叶子顶点从左到右依次标记为X1，X2，…，X，则称符号串X1X2.…Xn是T的结果。 句型a的派生树：“结果为a的派生树”。·派生树的结果可以是句子，也可以是句型 一个文法可以有多棵派生树，它们可以有不同的结果。 设CFG \\(G=(V，T，P，S)\\)，\\(S\\Rightarrow^* \\alpha\\)的充分必要条件为G有一棵结果为$ $的派生树。 定义： 最左派生：\\(\\alpha\\)的派生过程中，每一步都是对当前句型的最左变量进行替换 左句型：最左派生得到的句型可叫做左句型。 最右归约：与最左派生相对的归约叫做最右归约。 定义： 最右派生：\\(\\alpha\\)的派生过程中，每一步都是对当前句型的最右变量进行替换 右句型：最右派生得到的句型可叫做右句型。 最左归约：与最左派生相对的归约叫做最左归约。 最右派生、右句型、最左归约又称为规范派生、规范句型、规范规约 二义性 字符串对应两个及以上派生树，则文法有二义性 如果语言L不存在非二义性文法，则称L是固有二义性的，又称L是先天二义性的。 无用符号 能出现字符串的派生过程中的有用，否则无用。 删除无用符号 删除派生不出终极符号行的变量 image-20220619175742158 删除不出现在任何句型中的语法符号 image-20220619175910894 依次使用上述算法(先删派生不出终极符号行的变量，再删不出现在任何句型中的语法符号)就可删除无用符号 空产生式 形如 \\(A\\to \\epsilon\\) 求CFG G的可空变量集 image-20220619180121022 去除空产生式 首先求可空变量集U 构造 \\(P&#39;\\) \\(\\forall A \\to X_1X_2\\cdots X_m \\in P\\) 将 \\(A\\to \\alpha_1\\alpha_2\\cdots \\alpha_m\\) 放入 \\(P&#39;\\) ， 如果\\(X_i \\in U,\\quad \\alpha_i = X_i\\text{ or }\\epsilon\\) ；如果 \\(X_i\\notin U\\quad \\alpha_i = X_i\\) image-20220619180650451 单一产生式 形如 \\(A \\to B\\) 消除：用\\(B\\) 的表达式直接代替\\(A \\to B\\) 中的B 如果 \\(A \\to \\alpha\\) 不是单一产生式，就放入 \\(P_2\\) 如果 \\(A \\to_G^+ B\\) 且\\(B \\to \\alpha\\) 不是 单一产生式，那么 \\(A \\to \\alpha\\) 放\\(P_2\\) CFG化简 流程 删除无用符号； 删除E-产生式； 删除单一产生式； 当删除单一产生式后，文法中再出现新的无用符号时，再次进行删除无用符号。 CNF 乔姆斯基范式 形式都为 \\(A \\to BC\\) 或 \\(A \\to a\\) 不允许有空产生式和单一产生式 通过CFG构造CNF 首先将化简后的CFG转化为都为 \\(A \\to B_1B_2\\cdots B_n\\) 和 \\(A\\to a\\) 的形式 对于 \\(A \\to aB\\) 这类转化为 \\(A \\to A_aB \\quad A_a \\to a\\) 将形如 \\(A \\to A_1A_2\\cdots A_n\\) 都替换为 \\[ A \\to A_1B_1 \\\\ B_1 \\to A_2B_2\\\\ \\cdots\\\\ B_{n-2} \\to A_{n-1}A_n \\] GNF 格雷巴赫范式 有如下两种形式 \\(A\\to a\\) \\(A\\to a A_1A_2\\cdots A_m\\) 首先 \\(A \\to \\alpha B \\beta\\) 又 \\(B \\to \\gamma_1|\\gamma_2|\\cdots\\) 那么可以将B替换为\\(\\gamma\\) 递归 如果存在 \\(A \\Rightarrow^n \\alpha A \\beta\\) 则称为递归派生；n&gt;2 称为间接递归；\\(\\alpha = \\epsilon\\) 称为左递归，反之为右递归 引理：对于 \\[ \\left\\{ \\begin{align} A &amp;\\to A\\alpha_1|A\\alpha_2|A\\alpha_3\\cdots\\\\ A &amp;\\to \\beta_1|\\beta_2|\\beta_3|\\cdots \\end{align} \\right. \\] 可以替换为 \\[ \\left\\{ \\begin{align} A &amp;\\to \\beta_1|\\beta_2|\\beta_3|\\cdots\\\\ A &amp;\\to \\beta_1B|\\beta_2B|\\beta_3B|\\cdots\\\\ B &amp;\\to \\alpha_1|\\alpha_2|\\alpha_3|\\cdots\\\\ B &amp;\\to \\alpha_1B|\\alpha_2B|\\alpha_3B|\\cdots \\end{align} \\right. \\] CFG转GNF 首先将产生式化成形式（通过引入变量替换终极符） \\[ A \\to A_1A_2\\ldots A_m\\\\ A\\to a A_1A_2\\ldots A_{m-1} \\\\ A \\to a \\] 将产生式都转化为形式 \\[ A_i \\to A_j \\alpha\\quad i &lt; j\\\\ A_i \\to a \\alpha\\\\ B_i \\to \\alpha \\] 当出现j &lt; i 的情况，就用 \\(A_i\\) 的表达式替换，直到出现左递归: image-20220619193420234 具有最大下标的A已经满足GNF的要求，将这些产生式带入还不满足要求的\\(A_2\\)产生式，使得\\(A_2\\)产生式都满足GNF的要求；之后递归的带入 \\(A_1\\) 下推自动机 CFG都可以化为GNF，最左派生是，句型中变量都以后缀形式出现。 使用下推自动机识别CFG \\[ M = (Q,\\Sigma, \\Gamma, \\delta,q_0,Z_0, F) \\] Q状态集合 \\(\\Sigma\\) 输入字母表 \\(\\Gamma\\) 栈顶符号表 \\(Z_0\\in \\Gamma\\) 开始符号，启动时栈内唯一的符号 \\(q_0\\) 开始状态 F终止状态 \\(\\delta\\) 转移函数，\\(\\delta: Q \\times (\\Sigma\\cup \\{\\epsilon\\} \\times \\Gamma) \\to 2^{Q\\times \\Gamma^*}\\) \\[ \\delta(q,a,Z) = \\{(p_1, \\gamma_1), (p_2, \\gamma_2), \\cdots\\} \\] 表示状态q下，栈顶为Z，读入a，状态可以转移为\\(q_i\\) 并且弹出Z并将 \\(\\gamma_i\\) 从右至左压入栈，读头移动，准备读入下一个字符。 特别的如果\\(a = \\epsilon\\) 那么读头不移动。 同样有 即时描述：\\((q,w,\\gamma)\\) 当前状态q，未处理字符串w，栈内符号串\\(\\gamma\\) （最左侧为栈顶） 接收语言 两种接受方法： 转移到特定终态接收 记作\\(L(M)\\) 空栈接收（栈为空时接收）记作\\(N(M)\\) GNF转PDA 模拟最左派生，对于 \\(A \\to b \\alpha\\)，就是读入b，压栈\\(\\alpha\\) \\[ \\forall A \\in V,\\ a\\in T,\\ \\gamma \\in V^*\\\\ \\delta(q,a,A) = \\{(q,\\gamma)|A\\to a\\gamma \\in P\\} \\] 对于含有空串的语言，再加入识别空串的 \\(\\delta_1(q_0,\\epsilon, Z) = \\{(q_0, \\epsilon), (q,S)\\}\\) 类似的还可以终态接受 image-20220619195359916 还可以直接观察语言结构来设计自动机，常用 image-20220619195513815 终态接受的PDA转空栈接受PDA 状态加入初始状态和清栈状态，栈顶符号加入一个用于放在栈底的符号。 初始状态空移动转移到原PDA初始状态，并将新加的栈符号连同原PDA栈底符号压入栈底 之后所有的转移都模拟原PDA，直到原终止状态 原终止状态转移到请栈状态，开始通过空移动清栈。 image-20220619200515110 空栈接受PDA转终态接受的PDA 加入终止状态和标志栈底的元素，等看到栈底元素后就进入终止状态。 PDA转CFG 使用三元组 \\([q,A,q_{next}]\\) 表示CFG中变量，其中A是栈顶符号。 对于 \\(\\delta(q,a,A) = (q_1,A_1A_2\\cdots A_n)\\) 我们不确定处理完\\(A_1\\) 到 \\(A_n\\) 后状态是什么，那么就遍历 image-20220619201358182 流程： 以该题为例 image-20220619201604339 首先构造S的产生式 \\(S\\to [q_0,Z,q_0]|[q_0,Z,q_1]|[q_0,Z,q_2]\\) 对每个转移函数构造产生式 对于空串的处理 image-20220619202110627 上下文无关语言 CFL的泵引理 $z L $ 当 \\(|z| \\geq N\\) 存在u,v,w,x,y，使得 \\(z = u\\ vwx\\ y\\) 同时满足 \\(|vwx| \\leq N\\) \\(|vx| \\geq 1\\) \\(\\forall i \\in N^+,\\quad uv^i wx^i \\in L\\) 利用CFL泵引理证明一个语言不是CFL的步骤： 首先假设该语言是CFL，则其应该满足泵引理，选任意的N. 找到某一个语言中的句子\\(z\\in L(|z|\\geq N)\\). 分析各种v、x取值，当满足z=uvwxy，且\\(|vwxl\\leq N\\)，\\(|vx|\\geq 1\\)时，均能找到一个\\(i&gt;0\\)，使\\(uv^iwx^iy \\notin L\\). 推出矛盾说明假设不成立，即该语言不是CFL。 需要讨论所有uvwxy的取值 Ogden引理 $z L $ 当z中至少含有N个特异点时， 存在u,v,w,x,y，使得 \\(z = u\\ vwx\\ y\\) 同时满足 \\(|vwx|中特异点个数 \\leq N\\) \\(|vx|中特异点个数 \\geq 1\\) \\(\\forall i \\in N^+,\\quad uv^i wx^i \\in L\\) 同样反证的时候利用该定理 image-20220619205350903 封闭性 在并、乘积、闭包运算下封闭 在交、补运算下不封闭 定理：CFL与RL交是CFL image-20220619210308056 当构造多个语言相关的识别器时可以通过原来的控制器构造，如 \\(M=(Q_1\\times Q_2\\times \\cdots, \\Sigma, \\delta, [q_{10}, q_{20}, \\cdots], F_1\\times F_2\\times \\cdots)\\) 代换运算 封闭，参考正则代换 有CFG G=(V,T,P,S) \\(\\Sigma\\) 是另外的字母表，那么映射 \\(f:T\\to 2^{\\Sigma^*}\\) 称为代换，\\(f(a) , \\forall a \\in T\\) 也是CFL 同态运算、逆同态运算封闭 判定算法 判断是否非空 image-20220619211942800 判断是否有穷 可派生性图 image-20220619212145887 那么对于派生 \\(A \\Rightarrow^+ \\alpha A \\beta\\) 存在的充要条件是：G的可派生性图表示中存在一条从标记为A的顶点到标记为A的顶点的长度非0的有向回路。且回路中的顶点要从S顶点“可达”。 定理：G=(V,T,P,S) 不含无用符号，那么L(G) 为无穷语言的充要条件是：G的可派生性图表示中存在一条有向回路 简化可派生性图 从可派生性图删除终极符号 同样可以判断是否为无穷语言 CFL成员判定问题 x是否为L(G)的句子的判定 CYK算法 基本思想：设给定的文法为CNF文法，对于任意字符串x，如果x的第k个字符a可以由B派生出，并且x的第k+1个字符b可以由C派生出，当\\(A\\to BC\\in P\\)时，ab可以由A派生出 image-20220619212937326 image-20220619213027351 算法具体步骤 image-20220619213109687 k控制字串长度，i控制字串开始位置，j控制将字串切分成两端 image-20220619214550968 图灵机 TM基本模型包括： 一个有穷控制器。 一条含有无穷多个带方格的输入带。 一个读写头。 TM的每次移动与所读符号、所处状态有关。一个移动将完成以下三个动作： 改变有穷控制器的状态； 在当前所读符号所在的带方格中印刷一个符号； 将读写头向右或者向左移一格。 基本的图灵机 \\[ M = (Q,\\Sigma,\\Gamma, q_0, B, F) \\] Q 状态集合 \\(q_0\\) 初始状态 F，终止状态集 \\(\\Gamma\\) 带符号表，可以出现在纸带上的符号集合 \\(B \\in \\Gamma\\)，空白符，含有空白符的带方格被认为是空的 \\(\\Sigma \\subset \\Gamma-{B}\\) 输入字母表，只有 \\(\\Sigma\\) 中的符号才能在M启动时 出现在输入带上 \\(\\delta:Q\\times \\Gamma \\to Q \\times \\Gamma \\times \\{R,L\\}\\) ，RL表示向右向左移动，先改变状态，再将所在的方格中印刷字符Y，最后再移动 特别的，如果遇到转移函数没有定义的情况，图灵机就停机 \\(\\alpha_1 q \\alpha_2\\) 称为即时描述 (ID)，即时描述移动使用 \\(\\vdash_M\\) 接受的语言叫做 递归可枚举语言 如果TM对于每个输入串都停机，接受的语言叫做 递归语言 递归语言是递归可枚举语言的子类，而上下文有关文法是递归语言的子类 相关概念 只要一个问题能够表达成一个有穷字母表上的字符串编码，就可将此问题变成判定一个语言是否是递归语言的问题。 可判定的（decidable）问题，对应于“递归语言” 以问题的实例为输入，并能给出相应的“是”与“否”的判定。 不可判定的（undccidablc）问题没有上述算法，例如， 对于任意给定的上下文无关文法G，判断它的语言L（G）是否二义性 对于任意给定的图灵机的描述M和输入w，判断M是否会停机 P类问题（class of P）：P表示确定的TM在多项式时间（步数）内可判定的问题。这些语言对应的问题称为是P类问题，这种语言称为多项式可判定的。 NP类问题（class of NP）：NP表示不确定的TM在多项式时间（步数）内可计算的问题。对于NP问题，在给定答案时，确定的TM在多项式时间内可验证答案的正确性。（例如，数独问题） NP完全的（NPcomplete problem）：NP类中的一些问题能代表整个NP类的最高复杂性。 如果能找到这些问题中的任何一个的多项式时间判定算法，那么，所有的NP问题都是多项式时间可以判定的。 所有NP问题都可以在多项式时间内转换为NP完全的。 上下文有关文法CSG 0型文法：短语结构文法PSG，也叫递归可枚举集 1型文法：上下文有关文法 具体见乔姆斯基文法体系 图灵机与PSG等价 线性有界自动机 线性有界自动机（linear bounded automaton，LBA） 非确定的TM。 输入字母表包含两个特殊的符号C和$，其中，C作为输入符号串的左端标志，$作为输入符号串的右端标志。 LBA的读头只能在C和$之间移动，它不能在端点符号C和$上面打印另外一个符号。 LBA与CSG等价 image-20220619225114676","categories":[{"name":"Review","slug":"Review","permalink":"https://blog.x-wang.tech/categories/Review/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"https://blog.x-wang.tech/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://blog.x-wang.tech/tags/%E5%A4%8D%E4%B9%A0/"}],"author":"Xav1er"},{"title":"计算机网络期末复习","slug":"Review/计算机网络复习","date":"2022-06-15T16:00:00.000Z","updated":"2022-06-22T01:46:09.776Z","comments":true,"path":"2022/06/16/Review/计算机网络复习/","link":"","permalink":"https://blog.x-wang.tech/2022/06/16/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"计算机网络 网络协议栈各层作用 应用层：通过应用进程间交互完成特定的互联网应用，定义应用进程之间通信和交互的规则。 传输层：进程之间通信的通用数据传输服务。 网络层：网络中不同主机提供通信服务 链路层：两个相邻网络结点之间传送数据 物理层：如何在传输媒介中传输比特流 应用层 C-S和P2P工作特点 客户-服务器是需要服务器打开，客户连接通信；P2P各方之间是对等的。 优缺点 客户-服务器 优点：客户、服务器分离，允许网络分布操作；一个服务器可以服务于多个客户端； 缺点：客户机会比较依赖于服务器工作。 P2P 优点：可扩展性强，传播速度优化； 缺点：用户直连，没有确保安全性，管理困难。 为什么引入域名，DNS缓存作用 方便人们记住主机名标识，同时适应路由器需要定长有层次的IP地址，需要一种从主机名到IP地址的转换服务，因此DNS系统产生了；缓存就是对重复的访问，省去一些重复的解析，节省时间。 传输层 TCP 最大报文段长度( Maximum Segment Size,MSS) 。MSS 通常根据最初确定的由本地发送主机发送的最大链路层 帧 长度（ 即所谓的最大传输单元(Maximum Transmission Unit, MTU)) 来设置 。 设置该 MSS 要保证一个 TCP报文段（当封装在一个 IP 数据报中）加上 TCP/ IP 首部长度（通常 40 字节） 将适合单个链路层帧 。 注意到 MSS 是指在报文段里应用层数据的最大长度，而不是指包括首部的 TCP 报文段的最大长度 。 当 TCP 发送一个大文件 ，例如 某 Web 页面上的一个图像时，TCP 通常是将该文件划分成长度为 MSS 的 若干块（最后一块除外，它通常小于 MSS) 拥塞控制 运行在发送方的 TCP 拥塞控制机制跟踪 一 个额外的变量，即拥塞窗口(congestion window) 。 拥塞窗口表示为 cwnd它对一个 TCP 发送方能向网络中发送流量的速率进行了限制 。 \\[ LastByteSent - LastByteAcked\\leq \\min \\{cwnd,rwnd\\} \\] 网络层 因特网的地址分配策略被称为 无类别域间路由选择(Classless Interdomain Routing,CIDR) [ RFC 4632 ] CIDR 将 子网寻址的概念 一般化了）当使用子网寻址时，32 比特的IP 地址被划分为两部分，并且也具有点分十进制数形式 $ a. b. c. d/x$, 其中x指示了地址的第一部分中的比特数 Best effort service model 为尽力而为服务。 工作特点：尽最大的可能性发送报文，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。 优点：适用于绝大多数网络应用。尽力而为服务模型与适当带宽供给相结合已被证明超过“足够好”，能够用于大量的应用，包括语音、视频等流式视 频服务以及实时会议应用。 不足：对时延、可靠性不提供任何保证。 距离向量路由选择算法 令 \\(d_x (y)\\) 是从节点 x 到节点 y 的最低开销路径的开销 。 则该最低开销与著名的Bellman- Ford 方程相关，即 \\[ d_x (y) = \\min_v \\{c(x,v) + d_v(v)\\} \\] v为x的临近节点， \\(c(x,v)\\) 意为cost 总结常见的传统路由协议，并指出其使用的是什么路由算法。传统路由协议有什么弊端？ OSPF：Dijkstra RIP：距离向量路由算法 弊端：拓扑维护，影响路由器性能和效率；流量路径缺乏灵活调整能力；网络协议实现复杂，运维难度大等。 什么是SDN，它有哪些特点？ 软件定义网络，是在数据平面和控制平面作明确分割的网络设计理念 特点：基于流的转发；数据平面与控制平面分离；网络控制功能位于数据平面交换外部；可编程网络 相较于传统路由协议，SDN的优势是什么？ 数据控制解耦合，将控制器，交换机分离，开放生态； 基于流的转发更加灵活 可编程网络便于开发 控制逻辑中心化，集中式便于管理 链路层 CRC纠错 所有计算（加减乘除）都是模2运算，没有进位借位，相当于直接异或 发送方需要选择长度为r的bits附加到数据D后，然后会构造一个长度为r+1的生成多项式G（同样是二进制数） 发送的数据为 \\[ D\\cdot 2^r \\ \\text{XOR} \\ R \\] 并且要求该数据能够正好被G整除 \\[ D\\cdot 2^r \\ \\text{XOR} \\ R = nG \\] 可以推导 \\[ D\\cdot 2^r =nG \\text{XOR} \\ R \\\\ R = \\text{remainder} \\frac{D\\cdot 2^r}{G} \\] 每个 CRC 标准都能检测小于 r + 1 比特的 突发差错 。此外，在适当的假设下，长度大于 r + 1 比特的突发 差错 以概率 $1 -0. 5^r $ 被检测到。每个 CRC 标准也都能检测任何奇数个比特差错 。 随机接入协议 时隙 ALOHA 分为一个个时隙，每个时隙为 \\(L/R\\) 秒，其中L为帧的长度，则每个时隙够发一帧。 如果没碰撞，正常，有碰撞，则节点在之后的每个时隙中按照 \\(p\\) 的概率重传直至成功。 一 个给定节点传输的概率是 p; 剩余节点不传输的概率是\\((1 -p)^{N-1}\\) 。因此，一个给定节点成功传送的概率是 \\(p(1 -p)^{N-1}\\) 因为有 N 个节点 ，任意一个节点成功传送的概率是 \\[ Np(1 -p)^{N-1} \\] 找到最大化的\\(p^*\\) 可以计算当 \\(N \\to \\infty\\) 时，效率为 \\(1/e = 0.37\\) ALOHA 纯ALOHA，不分割时隙，任何时间都能传，没碰撞正常，有碰撞就在碰撞传输完后每帧时间按照p概率重传，各个节点时间都不同步，最大效率 \\(1/(2e)\\) 载波侦听多路访问(CSMA) 载波侦听(carrier sensing) ，即一个节点在传输前先听信道 。 如果来自另 一个节点的帧正向信道上发送，节点则等待直到检测到 一 小段时间没有传输，然后开始传输 。 碰撞检测(collision detection ) , 即当 一个传输节点在传输时 一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧， 它就停止传输，在重复“侦听-当 空 闲时传输”循环之前等待一段随机时间 。 中止传输后，适配器等待一个随机时间量，之后传输。 随机时间量执行二进制指数后退(binary exponenlial backoff )算法 ：在该帧经历了 一连串的 n 次碰撞后，节点随机地从 \\(\\{0,1,2,\\cdots, 2^n-1\\}\\) 中选择一个 K 值 。对于以太网，一个节点等待的实际时间量是 $ K $ 比特时间，即发送 512 比特进入以 网所需时间的K倍","categories":[{"name":"Review","slug":"Review","permalink":"https://blog.x-wang.tech/categories/Review/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://blog.x-wang.tech/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Xav1er"},{"title":"React学习笔记","slug":"Tech/React","date":"2022-03-24T16:00:00.000Z","updated":"2022-06-22T01:43:50.656Z","comments":true,"path":"2022/03/25/Tech/React/","link":"","permalink":"https://blog.x-wang.tech/2022/03/25/Tech/React/","excerpt":"","text":"组件类型和定义 react组件首字母应当大写，因为使用时以标签形式使用，如果首字母小写会认为是html的内置标签，报错 1234567891011121314151617181920// 函数式组件function Welcome(props) &#123; // props是传入的参数 // 如果使用时不传参，也可以没有参数 return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;// 使用ReactDOM.render( &lt;Welcome name=&#x27;wx&#x27;/&gt;,document.getElementById(&#x27;xxx&#x27;))// 类式组件class Welcome extends React.Component &#123; // 继承 React.Component render() &#123; // 必须要有render函数，返回需要渲染的内容 return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 组件三大属性 state 箭头函数()=&gt;&#123;&#125; 和function 区别：箭头函数没有this，其中出现this会去找外侧的this，function自身有this。可以利用该点在类中使用箭头函数，其中用this改变类中的属性. react自定义方法一般用复制加箭头函数的方法 12345class Foo extends React.Component&#123; myMethod = ()=&gt;&#123; /*TODO*/ &#125;&#125; 组件对象有state属性用于表示组件状态，同时在不同事件后使用setState改变state的值实现不同状态的转化。注意setState会把相同的键合并，不同的键保留，不会覆盖 12345678910111213141516171819class Foo extends React.Component&#123; constructor(props) &#123; this.state = &#123;time:111&#125; this.myMethod = this.myMethod.bind(this) // 由于在调用myMethod 的时候，没用通过实例调用，是直接传入的函数 // 函数在类的原型对象上，因此其中的this指向不正确 // 因此使用bind在实例中加入属性myMethod &#125; myMethod() &#123; const time = this.state.time this.setState(&#123;time:time+1&#125;) &#125; render() &#123; return &lt;h1 onClick=&#123;this.myMethod&#125;&gt;现在的时间是&#123;this.state.time&#125;&lt;/h1&gt; &#125;&#125; 同时上述代码可以不需要构造器，简写如下 123456789101112class Foo extends React.Component&#123; state = &#123;time:111&#125; myMethod = ()=&gt;&#123; const time = this.state.time this.setState(&#123;time:time+1&#125;) &#125; render() &#123; return &lt;h1 onClick=&#123;this.myMethod&#125;&gt;现在的时间是&#123;this.state.time&#125;&lt;/h1&gt; &#125; // 相当于直接在类中追加state和myMethod的属性&#125; props 类组件中的props react 的props：我们在创建组件对象时不想用constructor，如何给组件传参？利用props属性，在使用对象标签时给标签参数就可以反映到props属性上 123456789class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt; &#125;&#125;ReactDOM.render(&lt;Person name=&#x27;wx&#x27; age=&#x27;18&#x27; gender=&#x27;M&#x27;/&gt;, document.getElementById(&#x27;xxx&#x27;)) react批量传props：使用对象传参数 12345678910111213class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt; &#125;&#125;let infos = &#123;name:&#x27;wx&#x27;, age:18, gender:&#x27;M&#x27;&#125;ReactDOM.render(&lt;Person &#123;...infos&#125;/&gt;, document.getElementById(&#x27;xxx&#x27;))// 注意此处不是对象的展开，因为外层的&#123;&#125;是表示这是一个js表达式// 这是Babel+react的特性，不是原生js语法// 直接console.log(...infos) 不会输出内容// 仅适用于传标签属性 拷贝时可以修改其中的某项参数 1234let a = &#123;name:&#x27;wx&#x27;, age:18, gender:&#x27;M&#x27;&#125;let copy = &#123;...a, name:&#x27;wx2&#x27;&#125;console.log(copy)// 结果为 &#123;name:&#x27;wx2&#x27;, age:18, gender:&#x27;M&#x27;&#125; 当直接使用标签属性的形式传递props时，形式为key=value此时value只能时字符串，如果想传递其它类型需要加&#123;&#125;表示这是js表达式 12345678910&lt;Person name=&#x27;wx&#x27; age=&#x27;19&#x27; gender=&#x27;M&#x27;/&gt;// 此处的age为字符串，但我们想传入数字// &lt;Person name=&#x27;wx&#x27; age=19 gender=&#x27;M&#x27;/&gt;// 这样会报错，19仅当为js变量时才具有意义，因此改用&lt;Person name=&#x27;wx&#x27; age=&#123;19&#125; gender=&#x27;M&#x27;/&gt;// 或者直接使用对象传入参数let a = &#123;name:&#x27;wx&#x27;, age:19, gender:&#x27;M&#x27;&#125;&lt;Person &#123;...a&#125;/&gt; 接上述内容，传入标签有不同类型，我们对不同类型标签需要有不同的操作，需要对不同标签的数据类型做限制。同时某些参数不传的时候，也需要参数的默认值。（参考函数传参需要限制参数类型和参数默认值）。组件类中使用属性propTypes 指定各个属性的限制，使用defaultProps指定默认值。具体使用如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import PropTypes from &#x27;prop-types&#x27;;// 15.5之前PropTypes在React核心库中，使用React.PropTypes，之后单独写在prop-types.js中class Person extends React.Component&#123; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt;; &#125;&#125;// 类型和必要性限制Person.propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func&#125;// 默认值的指定Person.defaultProps = &#123; gender:&quot;未知&quot;, age:18&#125;// 给类加入属性，可以在类内定义static属性class Person extends React.Component&#123; // 类型和必要性限制 static propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func &#125; // 默认值的指定 static defaultProps = &#123; gender:&quot;未知&quot;, age:18 &#125; render() &#123; return &lt;p&gt;这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁&lt;/p&gt;; &#125;&#125; props是只读的，不能修改 函数组件中的props 函数式组件通过参数的形式可以有props，但没有state 和refs，除非使用最新的hooks 1234567891011121314151617181920212223function Person(props)&#123; const &#123;name, age, gender&#125; = props return &lt;p&gt;这个人是&#123;name&#125;，&#123;gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;age&#125;岁&lt;/p&gt;;&#125;// 由于没有了类，只能在外部指定限制和默认值Person.propTypes = &#123; name:PropTypes.string.isRequired, // 使用React内置的规则PropTypes，限制name为string，同时是必须的参数 gender:PropTypes.string, age:PropTypes.number, action:PropTypes.func // string、number开头小写是为了不和内部的String、Number冲突 // 同样的，指定函数类型为了不和function冲突使用func&#125;// 默认值的指定Person.defaultProps = &#123; gender:&quot;未知&quot;, age:18&#125;ReactDOM.render(&lt;Person name=&#x27;wx&#x27;/&gt;, document.getElementById(&#x27;xxx&#x27;)) refs 字符串形式的ref(不推荐) 组件内的标签可以通过ref 来标识自己，组件会把ref和标签组成一对key-value放入属性refs中 12345678910111213141516171819class Person extends React.Component&#123; showData= ()=&gt; &#123; // 直接通过this.refs获取到&lt;input&gt;标签 // 注意此时获取到的是真实DOM标签，不是虚拟DOM console.log(this.refs.input1.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#x27;input1&#x27; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;input type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;/div&gt; ) &#125;&#125; 回调函数形式的ref 当ref为函数时，该函数作为回调函数使用，将ref所在节点作为参数传入函数中。一般会利用回调函数，把当前节点赋值给组件属性 12345678910111213141516171819202122232425class Person extends React.Component&#123; showData1= ()=&gt; &#123; // 直接通过this.refs获取到&lt;input&gt;标签 // 注意此时获取到的是真实DOM标签，不是虚拟DOM console.log(this.refs.input1.value) &#125; showData2= ()=&gt; &#123; console.log(this.refs.input2.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;(currentNode)=&gt;&#123;this.input1 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;(currentNode)=&gt;&#123;this.input2 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27; /&gt; &lt;/div&gt; ) // 由于回调函数简单，只有1个参数和一句，还可简写为 // ref = currentNode =&gt; this.input1 = currentNode &#125;&#125; 有关内联函数(函数体直接定义在ref后面的函数)的问题： 当组件更新的时候（state改变，react重新调用render函数，重新渲染），会调用两次ref回调函数，第一次传入参数null 第二次才真正传入当前节点 原因：每次重新调用render 都会重新生成回调函数，不确定之前调用的回调函数有什么影响，为了消除影响，第一次先传入null消除之前可能的效果，之后再次调用，传入当前节点。 只是细节，基本不会产生影响 如果想改，可以把回调函数改为类中定义的函数 123456789101112131415161718192021222324252627282930313233class Person extends React.Component&#123; state = &#123;s:True&#125; showData1= ()=&gt; &#123; console.log(this.refs.input1.value) &#125; change= ()=&gt; &#123; const &#123;s&#125; = this.state this.setState(&#123;s:!s&#125;) &#125; refCallback=()=&gt; &#123; this.input1 = currentNode; console.log(&#x27;@&#x27;, currentNode) &#125; // 如果使用这个，控制台就只会出现 @ &lt;input ...&gt; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;(currentNode)=&gt;&#123;this.input1 = currentNode;console.log(&#x27;@&#x27;, currentNode)&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;button onClick=&#123;this.showData1&#125;&gt; 点击显示内容 &lt;/button&gt; &lt;button onClick=&#123;this.change&#125;&gt; 点击改变状态 &lt;/button&gt; &lt;/div&gt; ) &#125; // 当点击change后，可以看到控制台上输出 // @ null // @ &lt;input ...&gt; // 两个结果&#125; createRef 可以使用react内部的createRef来定义一个ref，createRef相当于创建一个容器，装ref对应的标签，每个createRef对应一个标签，createRef创建的ref是一个对象，其中有一个key为currrent 通过myRef.current获取到对应的标签 12345678910111213class Person extends React.Component&#123; state = &#123;s:True&#125; myRef1 = React.createRef() // ... render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;this.myRef1&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; &lt;/div&gt; ) &#125; React事件处理 React中的事件都被封装了一层 通过 onXxx 指定事件处理函数，如onClick、onBlur等 使用的是React自定义事件，而不是原生DOM事件 （为了更好的兼容性） 事件都是通过事件委托的方式处理的（委托给组件最外层元素） （为了高效） 通过event.target得到发生事件的DOM元素对象 （减少ref使用） 避免过度使用ref： 发生事件的元素正好是需要操作的元素，可以不用ref 利用事件的回调函数传入的event参数直接获取DOM元素对象 例： 123456789101112131415class Demo extends React.Component&#123; showOnBlur=(event)=&gt;&#123; // 回调该函数时会传入event参数，使用event.target获得该事件的DOM对象 // 这样可以避免ref的频繁使用 alert(event.target.value) &#125; render() &#123; return ( &lt;div&gt; &lt;input onBlur=&#123;this.showOnBlur&#125; type=&#x27;text&#x27; placeholder=&#x27;失去焦点显示内容&#x27;/&gt; &lt;/div&gt; ) &#125; React 受控和非受控组件 非受控组件 12345678910111213141516171819202122class Login extends React.Component&#123; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this alert(`用户名：$&#123;username.value&#125; 密码：$&#123;passwd.value&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input ref=&#123;(c)=&gt;this.username=c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input ref=&#123;(c)=&gt;this.passwd=c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) // form中action表示提交表单数据的地址 &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) form表单不提供参数时，默认发起GET请求同时带有query参数 原生js中表单具有事件 onsubmit， React中为 onSubmit 避免表单提交刷新页面，可以使用 event.preventDefault() 阻止默认事件不提交表单 非受控组件：页面中所有输入类DOM的值现用现取（点击登录后，回调函数获取表单值）属于非受控组件 受控组件 原生js 有事件onchange 在改变时调用onchange 的回调函数，React中同样有 onChange 使用onChange 回调函数将输入内容直接存入状态中 123456789101112131415161718192021222324252627282930class Login extends React.Component&#123; state = &#123;username:&quot;NoName&quot;, passwd:&quot;NoPasswd&quot;&#125; readUserName = (event)=&gt; &#123; this.setState(&#123;username:event.target.value&#125;) &#125; readPasswd = (event)=&gt; &#123; this.setState(&#123;passwd:event.target.value&#125;) &#125; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this.state alert(`用户名：$&#123;username&#125; 密码：$&#123;passwd&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;this.readUserName&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input onChange=&#123;this.readPasswd&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) 关于受控和非受控： 非受控可以理解为拿到数据的行为不受程序控制，而受用户控制，只有用户进行提交等行为，组件才能最终拿到数据； 受控可以理解为拿数据的行为受程序控制，用户只要输入，不用提交，随着输入组件就能就拿到数据 更建议使用受控组件，因为非受控组件有几个输入，就有几个ref，受控组件可以减少ref 的使用 上述代码有重复实现的功能，可以改善，代码如下，具体使用了函数的柯里化 123456789101112131415161718192021222324252627282930class Login extends React.Component&#123; state = &#123;username:&quot;&quot;, passwd:&quot;&quot;&#125; changeFormData=(dataType)=&gt; &#123; return (event)=&gt; &#123; this.setState(&#123;[dataType]:event.target.value&#125;) &#125; // 将函数作为返回值供回调使用，同时利用传入参数实现不同功能 &#125; subCallback=(event)=&gt; &#123; event.preventDefault() const &#123;username, passwd&#125; = this.state alert(`用户名：$&#123;username&#125; 密码：$&#123;passwd&#125;`) &#125; render() &#123; return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;this.changeFormData(&quot;username&quot;)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码：&lt;input onChange=&#123;this.changeFormData(&quot;passwd&quot;)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ) &#125;&#125;ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#x27;root&#x27;)) 不用柯里化函数，也可以实现 123456789// 修改changeFormData，接受dataType和需要的参数changeFormData=(dataType, value)=&gt;&#123;/*do something*/&#125;// ...return( &lt;form action=&quot;localhost&quot; onSubmit=&#123;this.subCallback&#125;&gt; 用户名：&lt;input onChange=&#123;(event)=&gt;&#123;this.changeFormData(&quot;username&quot;, event.target.value)&#125;&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt;) 直接利用回调函数给changeFormData传入不同的参数实现代码复用 组件生命周期（重要） 旧版本 组件第一次被渲染到页面上时，React中称之为挂载 (mount) ，从页面移除时称之为 卸载 (unmount) 挂载组件使用render() ，卸载使用ReactDOM.unmountComponentAtNode() 希望在组件挂载到页面上时执行一些操作，比如设置定时器等。可以使用 componentDidMount()进行操作，该函数在组件挂载时调用，并仅调用这一次。 例：希望组件中的文本周期性的透明度减小，到0时恢复为1。点击按钮使组件消失 12345678910111213141516171819202122232425262728293031323334353637383940class Life extends React.Component&#123; state=&#123;opacity:1&#125; delEle=()=&gt; &#123; ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;)) // 删除组件 // 测试中发现只能删除该组件外部的容器，而不能删除组件内部的标签 &#125; // componentDidMoun调用：只在挂载时调用 componentDidMount() &#123; setInterval( ()=&gt; &#123; let &#123;opacity&#125; = this.state opacity -= 0.1 if (opacity&lt;=0) &#123; opacity = 1 &#125; this.setState(&#123;opacity:opacity&#125;) &#125;,200 ) // 设置定时器，每200ms透明度减小0.1 &#125; // render调用：初始化渲染，更新调用 // 如果定时器设置在render中，每次更新都会创建新的定时器，造成混乱 render() &#123; return( &lt;div&gt; &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;测试文本&lt;/h2&gt; &lt;button onClick=&#123;this.delEle&#125;&gt;点我消失&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 以上代码会出现新的问题，在点击删除节点后，控制台报错：不能更新一个未挂载的组件(unmounted component)的状态 解决以上问题： 先把定时器绑定到this 上，即初始定义为this.timer = setInterval() ，之后在删除组件时加上删除定时器clearInterval(this.timer) 使状态停止更新 直接使用componentWillUnmount 做这项工作，在组件将要被卸载时执行的操作 12345678910111213141516// ...delEle=()=&gt;&#123; clearInterval(this.timer) // 提前清除定时器 ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;))&#125;componentDidMount()&#123; this.timer=setInterval( ()=&gt;&#123; /*TODO*/ &#125;,200 )&#125;// ... 1234componentWillUnmount()&#123; clearInterval(this.timer)&#125; 组件的生命周期实际就是组件从创建、挂载到卸载，其中重要的函数（如render、componentDidMount、componentWillUnmount 等）被称为：生命周期钩子函数、生命周期函数等 组件从创建到死亡有一些特定的阶段 组件包含一系列钩子函数会在特定阶段调用 定义组件时会在特定的生命周期回调函数中，做特定的工作。 对于上图：左侧好理解，不做赘述 右侧： setState 流程 调用后，首先会通过shouldComponentUpdate 阀门，检查是否应当更新当前组件，若返回true则能够进行下去，反之会被阻拦，无法调用后面的函数。如果该函数未定义，永远返回true 检查返回true后会依次调用componentWillUpdate 、 render 、componentDidUpdate 表示组件更新前、更新、更新后的操作 forceUpdate 流程 跳过shouldComponentUpdate 强制更新 直接调用componentWillUpdate 、 render 、componentDidUpdate 一般用做不更改状态数据，强制更新一下 通过this.forceUpdate 调用 父组件调用 render 首先组件要形成父子关系：在A组件中调用B组件，则A为B的父组件 父组件状态改变，重新render后，调用子组件钩子 componentWillReceiveProps （组件将要接收props） 注意！ 上述钩子在第一次传入props 时不会调用！只有更新传入新的props时才会调用（可以认为父组件重新render后调用） 1234567891011121314151617181920212223242526272829303132333435363738394041// 父组件调用render展示// 父组件class A extends React.Component&#123; state = &#123;s:true&#125;; changeState = () =&gt; &#123; const &#123;s&#125; = this.state; this.setState(&#123;s:!s&#125;); &#125;; render() &#123; const &#123;s&#125; = this.state; let st = s? &quot;状态1&quot;:&quot;状态2&quot;; return( &lt;div&gt; &lt;p&gt;这是A组件&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变状态&lt;/button&gt; &lt;B show=&#123;st&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// 子组件class B extends React.Component &#123; componentWillReceiveProps() &#123; console.log(&quot;B---componentWillReceiveProps&quot;); &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;这是B组件，展示状态：&#123;this.props.show&#125;&lt;/p&gt; &lt;/div&gt;); &#125;&#125;// 在页面初始时，控制台不会显示B---componentWillReceiveProps// 之后每点击一次button，控制台就多显示一个B---componentWillReceiveProps 以上都为旧版本的生命周期，做如下总结 初始化阶段，由ReactDOM.render() 触发 （初次渲染） constructor componentWillMount render componentDidMount 常用，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息 更新阶段，由this.setState 或父组件 render 触发 shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载组件，通常由 ReactDOM.unmountComponentAtNode 触发 componentWillUnmount 常用，通常做一些收尾工作，例：关闭定时器、取消订阅 新版本 componentWillMount 、componentWillReceiveProps 、 componentWillUpdate 前都需要加上UNSAFE_ 记忆：除了 componentWillUnmount，所有带will 的钩子都需要加UNSAFE_ unsafe：未来版本后加入异步渲染后，这三个钩子可能带来一些bug（现在不会），因此加入UNSAFE标志，同时提醒减少这三个钩子的使用 新生命周期如下图 生命周期新 对于新生命周期，可以理解为： 废弃componentWillMount 、componentWillReceiveProps 、 componentWillUpdate三个旧的钩子 提出 getDerivedStateFromProps 、 getSnapshotBeforeUpdate 两个新的钩子 注：实际使用中，两个新的钩子使用情况极其罕见 对于getDerivedStateFromProps： 定义在类上，因此需要是静态方法 static getDerivedStateFromProps ；同时返回值也必须是状态对象或null 接受参数props和state ，得到标签参数 当返回null时，不会产生影响 当返回状态对象，会将返回的对象设置为当前的state 理解：从props中得到派生的状态，即通过props的值得到状态，state的值在任何时候都取决于props，修改就没作用了 注意：容易造成代码冗余并且难以维护 123456789101112131415161718192021222324252627282930313233343536class A extends React.Component&#123; state = &#123;s:0&#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; // return null // 返回null不会有任何影响 console.log(nextProps, prevState); // 第一次输出 &#123;s:100&#125; &#123;s:0&#125; // 之后输出 &#123;s:100&#125; &#123;s:101&#125; return &#123;s:nextProps.s&#125; &#125; // 从props中得到数据，并强行指定state值 changeState = () =&gt; &#123; const &#123;s&#125; = this.state; this.setState(&#123;s:s+1&#125;); // 每次点击+1 &#125;; render() &#123; const &#123;s&#125; = this.state; return( &lt;div&gt; &lt;p&gt;这是A组件&lt;/p&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;改变状态&lt;/button&gt; &lt;p&gt;当前状态值为&#123;s&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;A s=&#123;100&#125;/&gt;, document.getElementById(&#x27;root&#x27;)); 对于getSnapshotBeforeUpdate： 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。 说明： componentDidUpdate 实际有三个参数 componentDidUpdate(preProps, preState, snapshot) 接收更新前的props、更新前的state和getSnapshotBeforeUpdate 传递进来的快照 snapshot 案例说明： 需求：有一新闻列表，长度固定；不断有新的新闻刷新，新的新闻在列表最上方；超出列表长度，使用滚动条。 问题：当内容不断刷新出现时，滚动条相对于最高点位置是固定的，反映到内容上，旧的内容会被新的内容挤到下方 解决：需要固定内容相对不动，即每次更新内容时，需要滚动条相对顶部的高度加上新内容的高度 提前定义好列表和新闻样式为 12345678910.newsList&#123; width: 200px; height:150px; background:skyblue; overflow: auto;&#125;.news&#123; height: 30px;&#125; 代码 为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class NewsList extends React.Component&#123; state = &#123;newsArr:[]&#125; // state中保存新闻列表 componentDidMount() &#123; setInterval(() =&gt; &#123; // 获取原状态 const &#123;newsArr&#125; = this.state // 模拟生成新闻消息 const news = &quot;新闻&quot; + (newsArr.length+1) // 更新状态，把新的新闻信息放到第一个 this.setState(&#123;newsArr:[news,...newsArr]&#125;) &#125;, 1000); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; return this.NewsList.scrollHeight // 拿到更新之前内容区的高度，以和更新后比较，计算更新前后差值 // 将高度留下快照 // 快照传给componentDidUpdate &#125; componentDidUpdate(prevProps, prevState, heightSnapshot) &#123; // 获取更新后的高度 let currentHeight = this.NewsList.scrollHeight // scrollTop即规定滚动条到顶部的距离 // 每次距离要加上增加的内容长度 // 注意不要=，直接=相当于固定滚动条高度，内容还是会被挤下去 this.NewsList.scrollTop += currentHeight-heightSnapshot &#125; render() &#123; return ( &lt;div className=&#x27;newsList&#x27; ref=&#123;(cNode)=&gt;&#123;this.NewsList = cNode&#125;&#125;&gt; &#123; this.state.newsArr.map( (n,index)=&gt;&#123; return &lt;div className=&#x27;news&#x27; key=&#123;index&#125;&gt;&#123;n&#125;&lt;/div&gt; &#125; ) // 回想：react会自动展开可迭代的一系列标签 &#125; &lt;/div&gt; ); // 注：中间有key属性是因为要求列表中每一个子节点都有一个unique key // 为简单因此将index作为key // 实际这样使用会出现一些问题，之后再做探讨 &#125;&#125; 新版本生命周期总结如下 初始化阶段，由ReactDOM.render() 触发 （初次渲染） constructor getDerivedStateFromProps render componentDidMount 常用，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息 更新阶段，由this.setState 或父组件 render 触发 getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate 卸载组件，通常由 ReactDOM.unmountComponentAtNode 触发 componentWillUnmount 常用，通常做一些收尾工作，例：关闭定时器、取消订阅 Diffing算法 React每次更新不是直接更新真实DOM，而是修改虚拟DOM，比较修改前后的虚拟DOM，只找不同的地方在真实DOM修改，不用真实DOM每次都全部更新，效率高 Diffing算法最小更新粒度是标签，但是会比较多层，比如 1234&lt;span&gt; 现在的时间是：&#123;this.state.time&#125; &lt;input type=&quot;text&quot;/&gt;&lt;/span&gt; 其中this.state.time 一秒钟更新一次，表示当前时间，span 标签内容改变，但是内部的input标签并没有改变，react只更新改变的内容，内部的 input 不会更新。 虚拟DOM中key的作用 简单：key是虚拟DOM对象的标识，更新显示时key起着极其重要的作用 详细： 当状态数据发生变化时，react会根据新数据生成新的虚拟DOM，随后React将【新虚拟DOM】与【旧虚拟DOM】的diff比较，规则如下： 旧DOM找到了与新DOM相同的key，： 若虚拟DOM内容不变，则仍用原本的真实DOM 若虚拟DOM内容改变了，则根据改变的虚拟DOM生成真实DOM，替换页面内容 未找到相同的key：根据数据创建真实DOM并渲染到页面 之前的代码 提到用index作为key 会产生一些问题，下分析其低效原因 代码示例： 12345678910111213141516171819202122232425262728293031class Person extends React.Component &#123; state = &#123; persons:[ &#123;id:0, name:&quot;小王&quot;, age:18&#125;, &#123;id:1, name:&quot;小李&quot;, age:19&#125;, ] &#125;; add = () =&gt; &#123; const &#123;persons&#125; = this.state; const p = &#123;id:persons.length+1, name:&quot;小张&quot;, age:20&#125; this.setState(&#123;persons:[p,...persons]&#125;) // 注意此处将信息系加入到了前面 &#125;; render() &#123; return( &lt;div&gt; &lt;h2&gt;信息展示&lt;/h2&gt; &lt;button onClick=&#123;this.add&#125;&gt;添加小张&lt;/button&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj, index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;;&#125; 分析其中的更新步骤： 1. 初始化创建， state 内为 1234[ &#123;id:1, name:&quot;小王&quot;, age:18&#125;, &#123;id:2, name:&quot;小李&quot;, age:19&#125;] 那么虚拟DOM中标签为 12&lt;li key=0&gt;小王---18&lt;/li&gt;&lt;li key=1&gt;小李---19&lt;/li&gt; 更新后，数据变为 12345[ &#123;id:3, name:&quot;小张&quot;, age:20&#125;, &#123;id:1, name:&quot;小王&quot;, age:18&#125;, &#123;id:2, name:&quot;小李&quot;, age:19&#125;] 新生成的虚拟DOM标签为 123&lt;li key=0&gt;小张---20&lt;/li&gt;&lt;li key=1&gt;小王---18&lt;/li&gt;&lt;li key=2&gt;小李---19&lt;/li&gt; 按照之前的diffing比较步骤： 1. 首先取 key=0 旧虚拟和新虚拟比较：有该key，但内容不同，则重新渲染到真实DOM中 2. 再取 key=1 旧虚拟和新虚拟比较：有该key，但内容不同，则重新渲染到真实DOM中 3. 取 key=2 旧虚拟和新虚拟比较：无该key，直接渲染到真实DOM中 可以发现，实际将三个标签全部重新渲染，但是我们可以看出，两个标签是重复的，不必要再次渲染，这样冗余的渲染造成了效率低下 进一步看造成冗余的原因：使用index作为key，在数据列表等顺序改变时，会直接改变已有数据的key，导致新加入数据后，原本数据对应标签的key 也发生变化，造成多余的真实DOM渲染，没有复用之前的标签 最好不要使用index，而是用数据的唯一标识，如id等作为key的值 以上的问题，不只会带来效率降低，当有输入框等嵌套结构时，还会造成数据错位： 123456789101112131415161718192021222324252627282930313233343536373839404142class Person extends React.Component &#123; state = &#123; persons:[ &#123;id:0, name:&quot;小王&quot;, age:18&#125;, &#123;id:1, name:&quot;小李&quot;, age:19&#125;, ] &#125;; add = () =&gt; &#123; const &#123;persons&#125; = this.state; const p = &#123;id:persons.length+1, name:&quot;小张&quot;, age:20&#125; this.setState(&#123;persons:[p,...persons]&#125;) // 注意此处将信息系加入到了前面 &#125;; render() &#123; return( &lt;div&gt; &lt;h2&gt;信息展示&lt;/h2&gt; &lt;h3&gt;使用index为key&lt;/h3&gt; &lt;button onClick=&#123;this.add&#125;&gt;添加小张&lt;/button&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj, index)=&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;hr/&gt; &lt;hr/&gt; &lt;h3&gt;使用id为key&lt;/h3&gt; &lt;ul&gt; &#123; this.state.persons.map((personObj)=&gt;&#123; return &lt;li key=&#123;personObj.id&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=&quot;text&quot;/&gt; &lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;;&#125; 上述代码，上半部分在输入后点击“添加小张” 会造成输入框数据的错位；下半部分则不会 原因： * 在用index作为key的部分，由于相同的key内部值不同，节点都做了更新，但因为虚拟DOM中 input 没有 value 属性，直接比较内部 input 标签都一样，因此没有更新 input 标签，这样相当于保留输入但改变前面内容，造成了最终的错位 * 使用id为key，比较后id相同不做更新，直接在最前方加入 li 标签，输入框和文本信息统一后移，不会有错位 总结：用index作为key可能的问题 1. 若对数据进行排序、逆序、删除、插入等操作破坏原本顺序：会造成不必要的真实DOM更新，降低效率 2. 如果结构中还包含输入类DOM：会产生错误的DOM更新造成信息的错误显示 3. 如果不对数据进行排序、逆序、删除、插入等操作，仅用于渲染展示信息，可以使用index作为key React脚手架 文件介绍 punlic/index.html head部分内容解释 123456&lt;!-- 以链接形式指定图标，%PUBLIC_URL%为public文件夹 --&gt;&lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;&lt;!-- 开启理想视口，适配移动端 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;&lt;!-- 指定地址栏和标签页的主题颜色（仅针对安卓手机） --&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; punlic/manifest.json 如果网页用作应用加壳，使用的配置文件（即，直接使用网页套壳作为安卓、iOS应用等） src/App.js 存放最外层App组件，用脚手架开发之后，所有小组件都作为App的子组件，最后只加载App组件到页面 src/App.test.js 对App组件做测试的脚本，几乎不用 src/index.js webpack的入口文件 其中加载App组件，用&lt;React.StrictMode&gt; 包裹：这样会检查App组件中不合理的部分（比如使用字符串形式的ref会弹出警告等） src/reportWebVital.js 用于分析、记录、显示页面性能 src/setupTests.js 用于模块的整体测试 编写方式 不同组件放到 src 统一的文件夹下，文件夹内部，一个组件一个文件夹，用于存放组件使用的外部js和样式等 将不同组件在App中进行组合 区分组件和业务逻辑文件： 组件文件名大写 组件文件后缀可以使用 jsx 多层文件引入麻烦，可以不同组件文件夹不同，但定义组件的文件都叫 index.jsx ，这样只要引入文件夹即可 样式模块化 避免不同模块之间样式冲突（不同模块指定相同名字的class不同样式，后引入的会覆盖之前引入的），要使用样式的模块化 模块化css：文件名改为 xxx.module.css 这样引入时可以将样式作为模块引入，使用时按照模块使用（xxx.class 等形式） 1234/* xxx.module.css */.title&#123; background-color:skyblue;&#125; 12345678910import xxx from &#x27;./xxx.module.css&#x27;export default class Hello extends React.Component&#123; render() &#123; return ( &lt;h1 className=&#123;xxx.title&#125;&gt;Hello&lt;/h1&gt; ); &#125;&#125; 应用案例 TodoList 上方Header组件为一个输入框，接受用户输入需要完成的任务，将任务加入到列表中 中间List展示已经有的任务，并且每个任务可以标志是否完成、可以删除 下方Footer展示已完成可全部任务数量，可以删除所有已完成任务，可以给所有任务打勾 困难：Header和List之间为兄弟，Header的数据无法传给List，也就无法新加入任务 解决：Header用某种方式将数据传给父组件App，再由App用props的形式将数据传给List 子组件向父组件传递数据 将父组件类内部的处理、显示数据的函数传给子组件，子组件将数据作为函数参数传入并调用，相当于给父组件传入了参数，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// App.jsclass App extends React.Component&#123; state=&#123;todos:[ &#123;id:&#x27;001&#x27;, name:&quot;aaa&quot;, done:true&#125;, &#123;id:&#x27;002&#x27;, name:&quot;bbb&quot;, done:false&#125;, &#123;id:&#x27;003&#x27;, name:&quot;ccc&quot;, done:false&#125;, ]&#125;; // 添加todo，接受一个todo对象（包含id、name、done等参数） addTodo = (todoObj) =&gt; &#123; const &#123;todos&#125; = this.state; // 追加todo const newTodos=[todoObj,...todos]; // 更新状态 this.setState(&#123;todos:newTodos&#125;) &#125;; render() &#123; return ( &lt;Header addTodo=&#123;this.addTodo&#125;/&gt; &lt;List/&gt; &lt;Footer/&gt; ); &#125;&#125;// =======================================// Header.jsclass Header extends React.Component &#123; handleKeyUp = (event) =&gt; &#123; // onKeyUp: 只要键盘按下就调用该事件 const &#123;keyCode, target&#125; = event; // keyCode 为按下去的按键编码，value为输入框内容 if (keyCode!== 13) return // 当按下的键不是回车直接返回，不处理 // 构造todo对象 // id需要不同，可以用库构造uuid，uuid库过大，可以使用nanoid // 每次调用都生成唯一的id // npm i nanoid const todoObj=&#123;id:nanoid(), name:target.value, done:false&#125; // 调用addTodo函数 加入新的任务 this.props.addTodo(todoObj) &#125;; render() &#123; return ( &lt;div&gt; &lt;input onKeyUp=&#123;this.handleKeyUp&#125; type=&quot;text&quot; placeholder=&quot;请输入任务名，按回车确认&quot;/&gt; &lt;/div&gt; ); &#125;&#125; 具体实现见：Todo_src React 和 axios 跨域请求和代理配置 当出现以下情况，都属于跨域访问 跨域原因 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 我们在测试请求数据时：在不同端口实现前端(3000)和后端服务器(5000)，造成跨域访问，导致数据获取失败。 Ajax 对于跨域请求：请求可以发出，后端服务器能够接收到，但是后端服务器发往前端的数据会被ajax阻止 对于跨域，我们可以设置代理： 代理将前端请求转发给后端，将后端响应返回给前端 代理与前端端口和域名一致：前端仅与代理通信，不会造成跨域，请求不会被阻拦 代理访问后端实际为跨域，但是由于没有ajax阻拦所以可以实现 做法：在package.json 中最后加入 \"proxy\":\"后端服务器地址\" 发送数据时就直接给前端端口（不会产生跨域）发送数据，代理自动将数据转发 注意：请求会首先在真正的前端端口下寻找资源，如果找到是不会转发给后端服务器的 附 原生js基础 展开运算符：...用于展开可迭代的变量，如数组等，但字面量对象(可以理解为字典)无法直接展开 123456789let a = [1,2,3,4]let b = [5,8,7]console.log(...a)// 输出1 2 3 4let c = [...a,...b]// 用于拼接数组// let b = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;&#125;// console.log(...b) // 会报错 对象相关 对象的复制：形式类似于展开运算符，但需要在外层加上&#123;&#125; 12345678910let a = &#123;name:&#x27;ccc&#x27;, age:&#x27;3&#x27;&#125;let b = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;, nigger: true&#125;let c = &#123;...a&#125;// 复制a到c// 注意，直接赋值 c=a 相当于直接返回a的指针，修改a，c也改变let merged = &#123;...a, ...b&#125;// 合并a、b，其中相同的key被后者覆盖，不同的key加上// merged = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;, nigger: true&#125; 所有对象中key:value 表达式，默认key 为字符串，name:\"wx\" 等价于 \"name\":\"wx\"。如果想使变量作为key 可以使用方括号[] 123456let dataType = &quot;username&quot;;console.log(&#123;dataType:&quot;wx&quot;&#125;);// 输出结果为&#123;dataType:&quot;wx&quot;&#125;console.log(&#123;[dataType]:&quot;wx&quot;&#125;);// 输出结果为&#123;username:&quot;wx&quot;&#125; 当对象key和value相同时，有简写形式 12345opacity = 0.5style1 = &#123;opacity:opacity&#125;style2 = &#123;opacity&#125;// 两种写法效果相同// 都会得到 &#123;opacity:0.5&#125; 常用 setInterval 定时器，两个参数，第一个参数为函数，为执行的操作；第二个参数为执行函数间隔的时间 12time = 200 //mssetInterval(()=&gt;&#123;&#125;, time) 特殊概念 高阶函数 如果一个函数接受一个函数作为参数，那么就是高阶函数 如果一个函数将一个函数作为返回值，也是高阶函数 函数的柯里化：通过函数调用最终返回函数的方式，实现多次接收参数，最后统一处理的函数编码形式。如受控和非受控组件中的代码 资源 库的js可以通过官网找到，下载 还可以在BootCDN 找到，该网站提供了常用js库的加速访问","categories":[{"name":"Tech","slug":"Tech","permalink":"https://blog.x-wang.tech/categories/Tech/"},{"name":"前端","slug":"Tech/前端","permalink":"https://blog.x-wang.tech/categories/Tech/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.x-wang.tech/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.x-wang.tech/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://blog.x-wang.tech/tags/%E5%89%8D%E7%AB%AF/"}],"author":"Xav1erW"}],"categories":[{"name":"Review","slug":"Review","permalink":"https://blog.x-wang.tech/categories/Review/"},{"name":"Course","slug":"Course","permalink":"https://blog.x-wang.tech/categories/Course/"},{"name":"ML","slug":"ML","permalink":"https://blog.x-wang.tech/categories/ML/"},{"name":"Tech","slug":"Tech","permalink":"https://blog.x-wang.tech/categories/Tech/"},{"name":"snippet","slug":"Tech/snippet","permalink":"https://blog.x-wang.tech/categories/Tech/snippet/"},{"name":"git","slug":"Tech/git","permalink":"https://blog.x-wang.tech/categories/Tech/git/"},{"name":"前端","slug":"Tech/前端","permalink":"https://blog.x-wang.tech/categories/Tech/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"课内","slug":"课内","permalink":"https://blog.x-wang.tech/tags/%E8%AF%BE%E5%86%85/"},{"name":"复习","slug":"复习","permalink":"https://blog.x-wang.tech/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"机器人","slug":"机器人","permalink":"https://blog.x-wang.tech/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://blog.x-wang.tech/tags/Deep-Learning/"},{"name":"CV","slug":"CV","permalink":"https://blog.x-wang.tech/tags/CV/"},{"name":"CNN","slug":"CNN","permalink":"https://blog.x-wang.tech/tags/CNN/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.x-wang.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"图像处理","slug":"图像处理","permalink":"https://blog.x-wang.tech/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"python","slug":"python","permalink":"https://blog.x-wang.tech/tags/python/"},{"name":"snippet","slug":"snippet","permalink":"https://blog.x-wang.tech/tags/snippet/"},{"name":"git","slug":"git","permalink":"https://blog.x-wang.tech/tags/git/"},{"name":"git-.submodule","slug":"git-submodule","permalink":"https://blog.x-wang.tech/tags/git-submodule/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"https://blog.x-wang.tech/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.x-wang.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"React","slug":"React","permalink":"https://blog.x-wang.tech/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.x-wang.tech/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"https://blog.x-wang.tech/tags/%E5%89%8D%E7%AB%AF/"}]}