<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="rYU2l4qPpd455yi7TLJRRf-nPk6MjH70RM044kFyp0w">
    
    
    
    
    <title>计算机组成原理复习 | Xav1er Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="课内,复习,计算机组成原理">
    <meta name="description" content="计算机系统概论 数字计算机与模拟计算机    比较内容 电子数字计算机 电子模拟计算机     数据表示方式 0，1 电压   计算方式 数字技术 电压组合或测量值   控制方式 程序控制 盘上连线   精度 高 低   数据存储量 大 小   逻辑判断能力 强 无    冯诺依曼机  由运算器、存储器、控制">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理复习">
<meta property="og:url" content="https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Xav1er Blog">
<meta property="og:description" content="计算机系统概论 数字计算机与模拟计算机    比较内容 电子数字计算机 电子模拟计算机     数据表示方式 0，1 电压   计算方式 数字技术 电压组合或测量值   控制方式 程序控制 盘上连线   精度 高 低   数据存储量 大 小   逻辑判断能力 强 无    冯诺依曼机  由运算器、存储器、控制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201531458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201538497.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201542880.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201551771.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201556033.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201557607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201602310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201609372.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201707854.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201708216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201709257.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201751840.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201802839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201817114.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201844159.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201849021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201857079.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201950729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201959278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202106203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202111661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202117888.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202123291.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202126098.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202130085.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202133732.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202228777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202232668.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202246529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202248599.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202255904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202252578.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210904391.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210925911.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210939620.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210946334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210947669.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210948331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210950724.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953558.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211003449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211013972.png">
<meta property="article:published_time" content="2022-06-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-21T09:25:24.613Z">
<meta property="article:author" content="Xav1er">
<meta property="article:tag" content="课内">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201531458.png">
    
        <link rel="alternate" type="application/atom+xml" title="Xav1er Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Xav1er</h5>
          <a href="mailto:xavierwang035@gmail.com" title="xavierwang035@gmail.com" class="mail">xavierwang035@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Xav1erW" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">计算机组成原理复习</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">计算机组成原理复习</h1>
        <h5 class="subtitle">
            
                <time datetime="2022-06-19T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2022-06-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Review/">Review</a></li></ul>

            
        </h5>
    </div>

    


</header>

<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA"><span class="post-toc-number">1.</span> <span class="post-toc-text">计算机系统概论</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%97%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E6%A8%A1%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数字计算机与模拟计算机</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">冯诺依曼机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">控制器</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8"><span class="post-toc-number">2.</span> <span class="post-toc-text">运算方法和运算器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">定点数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8E%9F%E7%A0%81"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">原码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0"><span class="post-toc-number">2.1.1.1.</span> <span class="post-toc-text">定点小数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0"><span class="post-toc-number">2.1.1.2.</span> <span class="post-toc-text">定点整数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A5%E7%A0%81"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">补码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0-1"><span class="post-toc-number">2.1.2.1.</span> <span class="post-toc-text">定点小数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0-1"><span class="post-toc-number">2.1.2.2.</span> <span class="post-toc-text">定点整数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8E%9F%E7%A0%81%E6%B1%82%E8%A1%A5%E7%A0%81"><span class="post-toc-number">2.1.2.3.</span> <span class="post-toc-text">原码求补码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B8%E5%8F%8D%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81"><span class="post-toc-number">2.1.2.4.</span> <span class="post-toc-text">相反数的补码</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A7%BB%E7%A0%81"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">移码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">浮点数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">规格化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ieee754"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">IEEE754</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">补码加法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A5%E7%A0%81%E5%87%8F%E6%B3%95"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">补码减法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="post-toc-number">2.4.3.</span> <span class="post-toc-text">溢出问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%A4%E5%88%AB%E6%B3%95"><span class="post-toc-number">2.4.3.1.</span> <span class="post-toc-text">直接判别法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E5%BD%A2%E8%A1%A5%E7%A0%81%E5%88%A4%E5%88%AB%E6%B3%95"><span class="post-toc-number">2.4.3.2.</span> <span class="post-toc-text">变形补码判别法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%9B%E4%BD%8D%E5%88%A4%E5%88%AB%E6%B3%95"><span class="post-toc-number">2.4.3.3.</span> <span class="post-toc-text">进位判别法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E4%B9%98%E6%B3%95"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">定点乘法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8E%9F%E7%A0%81%E5%B9%B6%E8%A1%8C%E4%B9%98%E6%B3%95"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">原码并行乘法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%98%B5%E5%88%97%E4%B9%98%E6%B3%95%E5%99%A8"><span class="post-toc-number">2.5.1.1.</span> <span class="post-toc-text">阵列乘法器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="post-toc-number">2.5.1.2.</span> <span class="post-toc-text">有符号乘法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E9%99%A4%E6%B3%95"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">定点除法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">浮点数加减运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AF%B9%E9%98%B6"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">对阶</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%9C%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96%E5%A4%84%E7%90%86"><span class="post-toc-number">2.7.2.</span> <span class="post-toc-text">结果的规格化处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%9C%E7%9A%84%E8%88%8D%E5%85%A5%E5%A4%84%E7%90%86"><span class="post-toc-number">2.7.3.</span> <span class="post-toc-text">结果的舍入处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%9C%E7%9A%84%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD"><span class="post-toc-number">2.7.4.</span> <span class="post-toc-text">结果的溢出判断</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%AE%E7%82%B9%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">浮点乘除法运算</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="post-toc-number">3.</span> <span class="post-toc-text">内部存储器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#sram"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">SRAM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%85%83%E9%98%B5%E5%88%97"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">基本的静态存储元阵列</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#dram"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">DRAM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%8Esram%E5%AF%B9%E6%AF%94"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">与SRAM对比</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%B7%E6%96%B0"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">刷新</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E6%89%A9%E5%B1%95"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">存储扩展</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">位扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%97%E6%89%A9%E5%B1%95"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">字扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E4%BD%8D%E6%89%A9%E5%B1%95%E6%89%80%E9%9C%80%E7%9A%84%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">计算字位扩展所需的存储芯片的数目</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rom"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">ROM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%89%E5%85%B3%E5%AD%98%E5%82%A8%E5%99%A8%E9%80%89%E6%8B%A9"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">有关存储器选择</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%A6%81%E7%82%B9"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">存储器设计的连接要点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">并行存储器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%AD%98%E5%82%A8%E5%99%A8"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">双端口存储器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%A4%E5%8F%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">多模块交叉存储器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="post-toc-number">3.5.2.1.</span> <span class="post-toc-text">顺序方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%A4%E5%8F%89%E6%96%B9%E5%BC%8F"><span class="post-toc-number">3.5.2.2.</span> <span class="post-toc-text">交叉方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8C%E8%80%85%E5%B8%A6%E5%AE%BD%E8%AE%A1%E7%AE%97"><span class="post-toc-number">3.5.2.3.</span> <span class="post-toc-text">二者带宽计算</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#cache"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">Cache</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="post-toc-number">3.6.1.</span> <span class="post-toc-text">读操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="post-toc-number">3.6.2.</span> <span class="post-toc-text">写操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#cache%E7%9A%84%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="post-toc-number">3.6.3.</span> <span class="post-toc-text">cache的命中率</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="post-toc-number">3.6.4.</span> <span class="post-toc-text">地址映射</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="post-toc-number">3.6.4.1.</span> <span class="post-toc-text">全相联映射方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="post-toc-number">3.6.4.2.</span> <span class="post-toc-text">直接映射</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="post-toc-number">3.6.4.3.</span> <span class="post-toc-text">组相联映射</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="post-toc-number">3.6.5.</span> <span class="post-toc-text">替换策略：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8lfu%E7%AE%97%E6%B3%95"><span class="post-toc-number">3.6.5.1.</span> <span class="post-toc-text">最不经常使用(LFU)算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%91%E6%9C%9F%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8lru%E7%AE%97%E6%B3%95"><span class="post-toc-number">3.6.5.2.</span> <span class="post-toc-text">近期最少使用(LRU)算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="post-toc-number">3.6.5.3.</span> <span class="post-toc-text">随机替换算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%99%E7%AD%96%E7%95%A5"><span class="post-toc-number">3.6.6.</span> <span class="post-toc-text">写策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%99%E5%9B%9E%E5%BC%8F"><span class="post-toc-number">3.6.6.1.</span> <span class="post-toc-text">写回式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%A8%E5%86%99%E5%BC%8F"><span class="post-toc-number">3.6.6.2.</span> <span class="post-toc-text">全写式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%99%E4%B8%80%E6%AC%A1%E6%B3%95"><span class="post-toc-number">3.6.6.3.</span> <span class="post-toc-text">写一次法</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="post-toc-number">4.</span> <span class="post-toc-text">指令系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">操作码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E6%89%A9%E5%B1%95"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">操作码扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E5%BA%A6"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">指令字长度</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">寻址方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">指令寻址</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">操作数的寻址方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="post-toc-number">4.2.2.1.</span> <span class="post-toc-text">偏移寻址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AE%B5%E5%AF%BB%E5%9D%80"><span class="post-toc-number">4.2.2.2.</span> <span class="post-toc-text">段寻址</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="post-toc-number">5.</span> <span class="post-toc-text">中央处理器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#cpu%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">CPU的功能</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">指令周期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mov-r1-r2"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">MOV R1, R2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lad-r1-addr"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">LAD R1, ADDR</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#add-r1-r2"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">ADD R1 , R2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sto-r2-r3"><span class="post-toc-number">5.2.4.</span> <span class="post-toc-text">STO R2 , (R3)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jmp"><span class="post-toc-number">5.2.5.</span> <span class="post-toc-text">JMP</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">微指令和微程序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cpu%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%85%B3%E7%B3%BB"><span class="post-toc-number">5.3.0.1.</span> <span class="post-toc-text">CPU周期与微指令周期关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="post-toc-number">5.3.0.2.</span> <span class="post-toc-text">机器指令与微指令的关系</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">微程序设计技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BE%AE%E5%91%BD%E4%BB%A4%E7%BC%96%E7%A0%81"><span class="post-toc-number">5.3.1.1.</span> <span class="post-toc-text">微命令编码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BE%AE%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90%E6%96%B9%E6%B3%95"><span class="post-toc-number">5.3.1.2.</span> <span class="post-toc-text">微地址的形成方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="post-toc-number">5.3.1.3.</span> <span class="post-toc-text">微指令格式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B5%81%E6%B0%B4cpu"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">流水CPU</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F"><span class="post-toc-number">6.</span> <span class="post-toc-text">总线系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%80%BB%E7%BA%BF%E7%9A%84%E4%BB%B2%E8%A3%81"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">总线的仲裁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">集中式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">分布式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87"><span class="post-toc-number">7.</span> <span class="post-toc-text">外围设备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">磁盘存储设备</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8A%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E5%B8%83"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">磁盘上信息的分布</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">技术指标</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="post-toc-number">8.</span> <span class="post-toc-text">输入输出系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">程序查询方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%9F%E4%B8%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.1.1.</span> <span class="post-toc-text">统一编址方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.1.2.</span> <span class="post-toc-text">独立编址方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">程序中断</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="post-toc-number">8.2.1.</span> <span class="post-toc-text">流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="post-toc-number">8.2.2.</span> <span class="post-toc-text">中断服务程序入口地址的获取</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC-io-%E6%8E%A5%E5%8F%A3"><span class="post-toc-number">8.2.3.</span> <span class="post-toc-text">程序中断方式的基本 I&#x2F;O 接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E7%BA%A7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="post-toc-number">8.2.4.</span> <span class="post-toc-text">单级中断系统</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%9A%E7%BA%A7%E4%B8%AD%E6%96%AD"><span class="post-toc-number">8.2.5.</span> <span class="post-toc-text">多级中断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%ADnmi"><span class="post-toc-number">8.2.6.</span> <span class="post-toc-text">不可屏蔽中断NMI</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%AF%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%ADintr"><span class="post-toc-number">8.2.7.</span> <span class="post-toc-text">可屏蔽中断INTR</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E4%B8%AD%E6%96%ADintn"><span class="post-toc-number">8.2.8.</span> <span class="post-toc-text">指令中断INTN</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD"><span class="post-toc-number">8.2.9.</span> <span class="post-toc-text">异常中断</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">直接内存访问</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%81%9C%E6%AD%A2cpu%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.3.1.</span> <span class="post-toc-text">停止CPU访问方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%91%A8%E6%9C%9F%E6%8C%AA%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.3.2.</span> <span class="post-toc-text">周期挪用方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dma%E4%B8%8Ecpu%E4%BA%A4%E6%9B%BF%E8%AE%BF%E5%AD%98%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.3.3.</span> <span class="post-toc-text">DMA与CPU交替访存方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dma%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E8%BF%87%E7%A8%8B"><span class="post-toc-number">8.3.4.</span> <span class="post-toc-text">DMA数据传送过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%92%8C%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">8.3.5.</span> <span class="post-toc-text">和中断控制方式的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%9A%E9%81%93%E6%96%B9%E5%BC%8F"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">通道方式</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Review/计算机组成原理复习"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">计算机组成原理复习</h1>
        <div class="post-meta">
            <time class="post-time" title="2022-06-20 00:00:00" datetime="2022-06-19T16:00:00.000Z"  itemprop="datePublished">2022-06-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Review/">Review</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="计算机系统概论">计算机系统概论</h1>
<h2 id="数字计算机与模拟计算机">数字计算机与模拟计算机</h2>
<table>
<thead>
<tr class="header">
<th>比较内容</th>
<th>电子数字计算机</th>
<th>电子模拟计算机</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据表示方式</td>
<td>0，1</td>
<td>电压</td>
</tr>
<tr class="even">
<td>计算方式</td>
<td>数字技术</td>
<td>电压组合或测量值</td>
</tr>
<tr class="odd">
<td>控制方式</td>
<td>程序控制</td>
<td>盘上连线</td>
</tr>
<tr class="even">
<td>精度</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="odd">
<td>数据存储量</td>
<td>大</td>
<td>小</td>
</tr>
<tr class="even">
<td>逻辑判断能力</td>
<td>强</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="冯诺依曼机">冯诺依曼机</h2>
<ul>
<li><p>由运算器、存储器、控制器、输入设备和输出设备五个部分组成；</p></li>
<li><p>存储器以二进制形式存储指令和数据；</p></li>
<li><p>指令和数据放在同一个存储器；</p></li>
<li><p>指令由操作码和地址码组成；</p></li>
<li><p>存储程序并按地址顺序执行；</p></li>
<li><p>冯·诺依曼机的核心设计思想，机器自动化工作 的关键；</p></li>
<li><p>以运算器为中心。</p></li>
</ul>
<h3 id="控制器">控制器</h3>
<p>工作周期：取指周期，执行周期</p>
<ul>
<li>数据字：该字代表要处理的数据；</li>
<li>指令字：该字为一条指令；</li>
<li>指令流：取指周期中，从内存读出的信息流；</li>
<li>数据流：执行周期中，从内存读出的信息流。</li>
</ul>
<p><strong>区分数据和指令</strong>：取指周期拿出来的是指令，执行周期拿出来的是数据。</p>
<h1 id="运算方法和运算器">运算方法和运算器</h1>
<h2 id="定点数">定点数</h2>
<p>假设用n+1位保存一个定点数</p>
<p>纯小数：</p>
<ul>
<li>有符号：<span class="math inline">\(x = x_sx_{-1}\cdots x_{-n}\)</span> 范围 <span class="math inline">\(0 \leq |x| \leq 1-2^{-n}\)</span></li>
<li>无符号：<span class="math inline">\(x = x_{-1}x_{-2}\cdots x_{-n-1}\)</span> 范围 <span class="math inline">\(0\leq x \leq 1-2^{-n-1}\)</span></li>
</ul>
<p>纯整数：</p>
<ul>
<li>有符号：范围 <span class="math inline">\(|x|\leq 2^{n}-1\)</span></li>
<li>无符号：范围 <span class="math inline">\(0 \leq x \leq 2^{n+1}-1\)</span></li>
</ul>
<h3 id="原码">原码</h3>
<h4 id="定点小数">定点小数</h4>
<p><span class="math display">\[
[x]_原 = \left\{
\begin{align}
&amp;x \quad &amp;1 &gt; x \geq 0\\
&amp;1-x = 1+|x| \quad &amp;0 \geq x &gt;-1
\end{align}
\right.
\]</span></p>
<h4 id="定点整数">定点整数</h4>
<p><span class="math display">\[
[x]_原 = \left\{
\begin{align}
&amp;x \quad &amp;2^n &gt; x \geq 0\\
&amp;2^n-x = 2^n+|x| \quad &amp;0 \geq x &gt;-2^n
\end{align}
\right.
\]</span></p>
<p><strong>特点</strong>：0有两种表示方法</p>
<p><strong>整体范围</strong>：</p>
<ul>
<li>小数： <span class="math inline">\(-1 &lt; x &lt; 1\)</span></li>
<li>整数： <span class="math inline">\(-2^n &lt; x &lt; 2^n\)</span></li>
</ul>
<h3 id="补码">补码</h3>
<h4 id="定点小数-1">定点小数</h4>
<p><span class="math display">\[
[x]_补 = \left\{
\begin{align}
&amp;x \quad &amp;1 &gt; x \geq 0\\
&amp;2+x = 2-|x| \quad &amp;0 \geq x \geq-1
\end{align}
\right.
\]</span></p>
<h4 id="定点整数-1">定点整数</h4>
<p><span class="math display">\[
[x]_补 = \left\{
\begin{align}
&amp;x \quad &amp;2^n &gt; x \geq 0\\
&amp;2^{n+1}+x = 2^{n+1}-|x| \quad &amp;0 \geq x \geq -2^n
\end{align}
\right.
\]</span></p>
<p>0有唯一表示方法</p>
<p>补码的补码就是原码</p>
<p>除2可以直接通过右移</p>
<p>最小值是 <span class="math inline">\(100000\cdots\)</span></p>
<h4 id="原码求补码">原码求补码</h4>
<blockquote>
<ul>
<li>方法1：除符号位各位取反加一</li>
<li>方法2：从最低位开始，遇到的第一个1以前的各位保持不变，之后各位取反。</li>
</ul>
</blockquote>
<h4 id="相反数的补码">相反数的补码</h4>
<p>已知 [x]<sub>补</sub>求[-x]<sub>补</sub></p>
<blockquote>
<p>连符号位一起各位求反，末位加1。</p>
</blockquote>
<h2 id="移码">移码</h2>
<p>把真值平移<span class="math inline">\(2^n\)</span> 个单位<br />
<span class="math display">\[
[x]_移 = 2^n+x
\]</span><br />
与补码符号位相反</p>
<ul>
<li>可以比较直观地判断两个数据的大小</li>
<li>表示浮点数阶码时，容易判断是否下溢；</li>
</ul>
<table>
<colgroup>
<col style="width: 62%" />
<col style="width: 16%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th>真值 x(十进制)</th>
<th>真值 x(二进制)</th>
<th>[x]原</th>
<th>[x]反</th>
<th>[x]补</th>
<th>[x]移</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>–127</td>
<td>–0 1 1 1 1 1 1 1</td>
<td><strong>1</strong> 1 1 1 1 1 1 1</td>
<td><strong>1</strong> 0 0 0 0 0 0 0</td>
<td><strong>1</strong> 0 0 0 0 0 0 1</td>
<td><strong>0</strong> 0 0 0 0 0 0 1</td>
</tr>
<tr class="even">
<td>–1</td>
<td>–0 0 0 0 0 0 0 1</td>
<td><strong>1</strong> 0 0 0 0 0 0 1</td>
<td><strong>1</strong> 1 1 1 1 1 1 0</td>
<td><strong>1</strong> 1 1 1 1 1 1 1</td>
<td><strong>0</strong> 1 1 1 1 1 1 1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0 0 0 0 0 0 0 0</td>
<td><strong>1</strong> 0 0 0 0 0 0 0</td>
<td><strong>0</strong> 0 0 0 0 0 0 0</td>
<td><strong>1</strong> 1 1 1 1 1 1 1</td>
<td><strong>0</strong> 0 0 0 0 0 0 0</td>
</tr>
<tr class="even">
<td>+1</td>
<td>+ 0 0 0 0 0 0 0 1</td>
<td><strong>0</strong> 0 0 0 0 0 0 1</td>
<td><strong>0</strong> 0 0 0 0 0 0 1</td>
<td><strong>0</strong> 0 0 0 0 0 0 1</td>
<td><strong>1</strong> 0 0 0 0 0 0 1</td>
</tr>
<tr class="odd">
<td>+127</td>
<td>+ 0 1 1 1 1 1 1 1</td>
<td><strong>0</strong> 1 1 1 1 1 1 1</td>
<td><strong>0</strong> 1 1 1 1 1 1 1</td>
<td><strong>0</strong> 1 1 1 1 1 1 1</td>
<td><strong>1</strong> 1 1 1 1 1 1 1</td>
</tr>
</tbody>
</table>
<h2 id="浮点数">浮点数</h2>
<p><span class="math display">\[
N = R^e \times M
\]</span></p>
<ul>
<li>M尾数，纯小数</li>
<li>R基数，默认是2</li>
<li>e阶码，指定小数点位置</li>
</ul>
<h3 id="规格化">规格化</h3>
<p>保证表示唯一</p>
<p><strong>要求</strong>： <span class="math inline">\(1/R \leq M &lt; 1\)</span></p>
<ul>
<li>尾数向左移n位(小数点右移)，同时阶码减n；</li>
<li>尾数向右移n位(小数点左移)，同时阶码加n。</li>
</ul>
<p>尾数用原码表示时：尾数数值最高数值位为1； 尾数用补码表示时：尾数最高数值位和尾数符号位相反；</p>
<h3 id="ieee754">IEEE754</h3>
<p>32位：1位数符，8位阶码（包括符号），23位尾数</p>
<p>64位：1位数符，11位阶码（包括符号），52位尾数</p>
<p>尾数原码表示，由于规格化最高位为1，因此隐藏最高位的1.</p>
<p><strong>32位</strong>阶码为移127码：<span class="math inline">\(E = e+127\)</span> ，真值为<br />
<span class="math display">\[
N = (-1)^S \times (1.M) \times 2^{E-127}
\]</span><br />
<strong>64位</strong><br />
<span class="math display">\[
N = (-1)^S \times (1.M) \times 2^{E-1023}
\]</span><br />
<strong>特殊值：</strong></p>
<p>正负零：<span class="math inline">\(E = 0;\ M=0\)</span> 正负由符号决定</p>
<p>正负无穷： <span class="math inline">\(E = 1111\cdots; \  M = 0\)</span> 正负由符号决定</p>
<p>真正指数的范围：-126~+127</p>
<table>
<thead>
<tr class="header">
<th>符号位S</th>
<th>阶码E</th>
<th>尾数M</th>
<th>数值N</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0/1</td>
<td>0</td>
<td>=0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0/1</td>
<td>0</td>
<td>≠0</td>
<td><span class="math inline">\((-1)^S\times(0.M)×2^{-126}\)</span></td>
</tr>
<tr class="odd">
<td>0/1</td>
<td>1~254</td>
<td>≠0</td>
<td><span class="math inline">\((-1)^S\times(1.M)×2^{E-127}\)</span></td>
</tr>
<tr class="even">
<td>0/1</td>
<td>255</td>
<td>≠0</td>
<td>NaN（非数值）</td>
</tr>
<tr class="odd">
<td>0/1</td>
<td>255</td>
<td>=0</td>
<td><span class="math inline">\((-1)^S\times \infty\)</span></td>
</tr>
</tbody>
</table>
<h2 id="运算">运算</h2>
<h3 id="补码加法">补码加法</h3>
<p>整数 <span class="math inline">\([x+y] = [x]+[y] (\mod 2^{n+1})\)</span></p>
<p>小数 <span class="math inline">\([x+y] = [x]+[y] (\mod 2)\)</span></p>
<h3 id="补码减法">补码减法</h3>
<p>整数 <span class="math inline">\([x-y] = [x]-[y] = [x]+[-y] (\mod 2^{n+1})\)</span></p>
<p>小数 <span class="math inline">\([x-y] = [x]-[y] = [x]+[-y] (\mod 2)\)</span></p>
<blockquote>
<p><span class="math inline">\([-y]\)</span> 等于 <span class="math inline">\([y]\)</span> 按位取反（包括符号位）再+1</p>
</blockquote>
<h3 id="溢出问题">溢出问题</h3>
<h4 id="直接判别法">直接判别法</h4>
<ul>
<li><p>同号补码相加，结果符号位与被加数相反；溢出</p></li>
<li><p>异号补码相减，结果符号位与被减数相反；溢出</p></li>
</ul>
<blockquote>
<p>硬件实现复杂</p>
</blockquote>
<h4 id="变形补码判别法">变形补码判别法</h4>
<p><strong>变形补码</strong>：也叫模4补码：采用双符号位表示补码</p>
<table>
<thead>
<tr class="header">
<th>双符号位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>00</td>
<td>正</td>
</tr>
<tr class="even">
<td>01</td>
<td>上溢</td>
</tr>
<tr class="odd">
<td>10</td>
<td>下溢</td>
</tr>
<tr class="even">
<td>11</td>
<td>负</td>
</tr>
</tbody>
</table>
<blockquote>
<p>硬件实现简单，只需对结果符号位进行异或</p>
</blockquote>
<h4 id="进位判别法">进位判别法</h4>
<p>判别方法：最高数值位的进位与符号位的进位是否相同；</p>
<p>溢出标志<br />
<span class="math display">\[
V = C_f \oplus C_{n-1}
\]</span><br />
其中 <span class="math inline">\(C_f\)</span> 为符号位进位；<span class="math inline">\(C_{n-1}\)</span> 为数值最高位进位。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201531458.png" alt="image-20220620153117043" title="">
                </div>
                <div class="image-caption">image-20220620153117043</div>
            </figure>
<p>加减法电路统一：</p>
<p>加入控制信号M，M和输入B的每一位为异或关系，当M为1的时候，<span class="math inline">\(B&#39; = \neg B\)</span> ；同时M作为进位输入，完成求-B的补码操作。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201538497.png" alt="image-20220620153801436" title="">
                </div>
                <div class="image-caption">image-20220620153801436</div>
            </figure>
<p>多位加法器延迟时间<br />
<span class="math display">\[
t_a = n\cdot 2T+9T = (2n+9)T
\]</span><br />
如果不考虑溢出就为<br />
<span class="math display">\[
t_a= [2(n-1)+9]T
\]</span></p>
<h2 id="定点乘法">定点乘法</h2>
<p>分析手算乘法步骤</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201542880.png" alt="image-20220620154257830" title="">
                </div>
                <div class="image-caption">image-20220620154257830</div>
            </figure>
<blockquote>
<p>乘法 = 加法+位移</p>
</blockquote>
<h3 id="原码并行乘法">原码并行乘法</h3>
<p><span class="math display">\[
a = \sum_{i=1}^{m-1} a_i 2^i \qquad b = \sum_{j=0}^{n-1}b_j2^j
\]</span></p>
<p>相乘得到<br />
<span class="math display">\[
p = ab =\left(\sum_{i=1}^{m-1} a_i 2^i\right) \left(\sum_{j=0}^{n-1}b_j2^j\right) = \sum_{i=1}^{m-1}\sum_{j=0}^{n-1}(a_ib_j)2^{i+j}
\]</span><br />
<span class="math inline">\(A_i\cdot b_j\)</span>部分乘积项（位积）叫做一个被加数。<span class="math inline">\(M\times N\)</span>个被加数用与门并行产生(a AND b)</p>
<p>时间<br />
<span class="math display">\[
t_m = (8n-4)T
\]</span></p>
<h4 id="阵列乘法器">阵列乘法器</h4>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201551771.png" alt="image-20220620155108703" title="">
                </div>
                <div class="image-caption">image-20220620155108703</div>
            </figure>
<h4 id="有符号乘法">有符号乘法</h4>
<p><span class="math display">\[
A \cdot B = (a_n \oplus b_n) (a_{n-1}\cdots a_0 \times b_{n-1}\cdots b_0)
\]</span></p>
<p>使用3个求补器，分别用对应的符号位控制：</p>
<ul>
<li>2个算前求补器：将两个操作数真值绝对值送入运算器；</li>
<li>1个算后求补器：乘积为负时把结果变成带符号数；</li>
</ul>
<p>两相反数的补码特征： 自右向左，第一个“1”的右侧所有数据位，均相同； 左侧所有数据位，均相反。</p>
<p>对2求补器电路逻辑：采用按位扫描技术来执行求补操作；E为控制信号线，可由数据a的符号位来控制；</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201556033.png" alt="image-20220620155610968" title="">
                </div>
                <div class="image-caption">image-20220620155610968</div>
            </figure>
<p>乘法器结构：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201557607.png" alt="image-20220620155745544" title="">
                </div>
                <div class="image-caption">image-20220620155745544</div>
            </figure>
<h2 id="定点除法">定点除法</h2>
<p>可控加法/减法(CAS)单元：用于加减交替法的除法器中；由控制端P选择运算类型：P=0，作加法运算；P=1，作减法运算</p>
<p>四个输入：</p>
<ul>
<li>被加/减数Ai</li>
<li>减数Bi</li>
<li>低 位进/借位Ci</li>
<li>控制端P</li>
</ul>
<p>四个输出：</p>
<ul>
<li>加/减数Bi</li>
<li>当位和/差Si</li>
<li>向高位的进/借位Ci+1</li>
<li>控制端P</li>
</ul>
<p>除法器结构：（被除数6位，除数3位）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201602310.png" alt="image-20220620160215240" title="">
                </div>
                <div class="image-caption">image-20220620160215240</div>
            </figure>
<p>执行时间<br />
<span class="math display">\[
t_d = 3(n+1)^2T
\]</span></p>
<blockquote>
<p>在加减交替的除法阵列中，每一行所执行的操作究竟是加法还是减法，取决于前一行输出的符号与被除数的符号是否一致。当出现不够减时，部分余数相对于被除数来说要改变符号。这时应该产生一个商位“0”，除数首先沿对角线右移，然后加到下一行的部分余数上。当部分余数不改变它的符号时，即产生商位“1”，下一行的操作应该是减法。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201609372.png" alt="image-20220620160943308" title="">
                </div>
                <div class="image-caption">image-20220620160943308</div>
            </figure>
<h2 id="浮点数加减运算">浮点数加减运算</h2>
<p>步骤：</p>
<ul>
<li>零操作数检查 <em>一个操作数为0，则不必运算，节省运算时间</em></li>
<li>两操作数对阶 <em>使小数点位置对齐，为加减运算做准备</em></li>
<li>尾数相加减 <em>以双符号位的补码形式进行加减法操作</em></li>
<li>结果的规格化</li>
<li>结果的舍入处理</li>
<li>结果的溢出判断</li>
</ul>
<h3 id="对阶">对阶</h3>
<p>以较大的阶码为标准，调整阶码较小的数据；</p>
<ul>
<li>求阶差<span class="math inline">\(\Delta E ＝ E_X－E_Y\)</span></li>
<li>调整阶码较小的数据
<ul>
<li>若<span class="math inline">\(\Delta E &gt;0\)</span>，则MY右移<span class="math inline">\(\Delta E\)</span>位，结果的阶码为<span class="math inline">\(E_X\)</span></li>
<li>若<span class="math inline">\(\Delta E &lt;0\)</span>，则MX右移<span class="math inline">\(|\Delta E|\)</span>位，结果的阶码为<span class="math inline">\(E_Y\)</span></li>
</ul></li>
</ul>
<h3 id="结果的规格化处理">结果的规格化处理</h3>
<p>两尾数加减的结果有两种情况:</p>
<ul>
<li>尾数溢出：两符号位为01或10，则<strong>右规</strong> ；尾数右移1位，阶码加1</li>
<li>尾数为非规格化数据，则<strong>左规</strong> ；尾数左移1位，阶码减１，直至数值位最高位与符号位相反。</li>
</ul>
<h3 id="结果的舍入处理">结果的舍入处理</h3>
<p>在对阶或右规操作时，会使加数或结果的尾数低若干位移出， 影响精度，常用两种舍入处理方法：</p>
<ul>
<li><p>方法1：0舍1入法</p>
<blockquote>
<p>保留右移时的移出位，若最高位为１，则尾数加１；否则舍去；</p>
<p>特点：精度较高，但需要记录所有的移出位。</p>
</blockquote></li>
<li><p>方法2：恒置1法</p>
<blockquote>
<p>若之前步骤有右移操作，则直接将结果的最低位置1;</p>
<p>特点：精度较0舍1入法较低，但应用简单。</p>
</blockquote></li>
</ul>
<h3 id="结果的溢出判断">结果的溢出判断</h3>
<ul>
<li>尾数溢出
<ul>
<li>在规格化处理时，通过完成右规完成；</li>
</ul></li>
<li>阶码溢出
<ul>
<li>上溢(结果绝对值太大)——置上溢标志，结束；</li>
<li>下溢(结果绝对值太小)——置机器零；</li>
<li>正常——运算结束；</li>
</ul></li>
</ul>
<h2 id="浮点乘除法运算">浮点乘除法运算</h2>
<p>浮点数乘除运算的步骤</p>
<ul>
<li>0操作数检查；</li>
<li>阶码加/减操作；</li>
<li>尾数乘/除操作；</li>
<li>结果规格化、舍入和溢出处理；</li>
</ul>
<h1 id="内部存储器">内部存储器</h1>
<ul>
<li><p>存储容量：存储单元个数×存储字长</p></li>
<li><p>存储速度：</p>
<ul>
<li>存取时间(访问时间)：从启动一次访问操作到完成该操作为止所经历的时间；以ns为单位，存取时间又分读出时间、写入时间两种。</li>
<li>存取周期：存储器<strong>连续启动两次独立的访问操作</strong>所需的最小间隔时间。以ns为单位，<strong>存取周期=存取时间+复原时间</strong></li>
<li>存储器带宽：每秒从存储器进出信息的最大数量；单位为位/秒或者字节/秒。</li>
</ul></li>
</ul>
<blockquote>
<p>只读存储器又分为掩膜 ROM、一次可编程 ROM(PROM)和可擦除PROM(EPROM)，后者又分为紫外线擦除EPROM(UV-EPROM)、电擦除EPROM(EEPROM或 E2PROM)和闪速(Flash)只读存储器。</p>
</blockquote>
<blockquote>
<p>当一个存储字的字长高于八位时，就存在一个存储字内部的多字节的排列顺序问题，其排列方式称为<strong>端模式</strong>。<strong>大端</strong>(big-endian)模式将一个字的高有效字节放在内存的低地址端，低有效字节放在内存的高地址端，而<strong>小端</strong>(little-endian)模式则将一个字的低有效字节放在内存的低地址端，高有效字节放在内存的高地址端。</p>
</blockquote>
<h2 id="sram">SRAM</h2>
<p>静态RAM（SRAM）：由MOS电路构成的双稳触发器保存二进制信息；</p>
<ul>
<li>优点：访问速度快，只要不掉电可以永久保存信息；</li>
<li>缺点：集成度低，功耗大，价格高；</li>
</ul>
<p>动态RAM（DRAM）：由MOS电路中的栅极电容保存二进制信息；</p>
<ul>
<li>优点：集成度高，功耗约为SRAM的1/6，价格低；</li>
<li>缺点：访问速度慢，电容的放电作用会使信息丢失，要长期保存数据必须定期刷新存储单元；主要种类有：SDRAM、DDR SDRAM</li>
</ul>
<h3 id="基本的静态存储元阵列">基本的静态存储元阵列</h3>
<p>芯片封装后，3种外部信号线：</p>
<ul>
<li>地址线：2n个单元，对应有n根地址线； 地址信号经过译码电路，产生每个单元的字线选通信号；</li>
<li>数据线：每个单元m位，对应有m根数据线；</li>
<li>控制线：读写控制信号：R/W =1，为读操作； R/W=0，为写操作；</li>
</ul>
<p>地址：单译码和双译码</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201707854.png" alt="image-20220620170725756" title="">
                </div>
                <div class="image-caption">image-20220620170725756</div>
            </figure>
<h2 id="dram">DRAM</h2>
<p>存储的信息 1 或 0 则是由电容器上的电荷量来体现——当电容器充满电荷时，代表存储了 1，当电容器放电没有电荷时，代表存储了 0。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201708216.png" alt="image-20220620170816151" title="">
                </div>
                <div class="image-caption">image-20220620170816151</div>
            </figure>
<p>1M×4 位 DRAM 芯片的外部引脚图。</p>
<p>与 SRAM 不同的是，图中增加了行地址锁存器和列地址锁存器。由于 DRAM 容量很大，地址线的数目相当多，为减少芯片引脚的数量，将地址分为行、列两部分<strong>分时传送</strong>。存储容量为 1M 字，共需 20 位地址线。此芯片地址引脚的数量为 10 位，先传送行地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器；然后传送列地址码 A10～A19，由列选通信号CAS 打入到列地址锁存器。片选信号的功能也由增加的 RAS 和 CAS 信号实现。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201709257.png" alt="image-20220620170905183" title="">
                </div>
                <div class="image-caption">image-20220620170905183</div>
            </figure>
<h3 id="与sram对比">与SRAM对比</h3>
<ul>
<li>外部地址引脚比SRAM减少一半：送地址信息时，分行地址和列地址分别传送；</li>
<li>内部结构：比SRAM复杂
<ul>
<li>刷新电路：用于存储元的信息刷新；</li>
<li>行、列地址锁存器：用于保存完整的地址信息：行选通信号 （Row Address Strobe）、列选通信号 （Columns Address Strobe）</li>
</ul></li>
<li>DRAM的读写周期：与SRAM的读写周期相似，只是地址总线上的信号有所不同；在同一个读写周期内发生变化，分别为行地址、列地址；</li>
</ul>
<h3 id="刷新">刷新</h3>
<p>DRAM 存储位元是基于电容器上的电荷量存储信息的，DRAM 的读操作是破坏性的，读操作会使电容器上的电荷流失，因而读出后必须刷新。而未读写的存储元也要定期刷新，因为电荷量会逐渐泄漏而减少。</p>
<p>在固定时间内对所有存储单元，通过“读出(不输出)—写入” 的方式恢复信息的操作过程；</p>
<p>当前主流的 DRAM 器件的刷新间隔时间(<strong>刷新周期</strong>)为 64ms</p>
<p>自动刷新：刷新计数器的宽度等于行地址锁存器的宽度。由于自动刷新不需要给出列地址，而行地址由片内刷新计数器自动生成，故可利用 CAS 信号先于 RAS 信号有效来启动一次刷新操作，此时地址线上的地址无效。</p>
<blockquote>
<p>刷新过程中存储 器不能进行正常的读写访问</p>
</blockquote>
<p><strong>集中式刷新策略</strong>中，每一个刷新周期中集中一段时间对 DRAM 的所有行进行刷新。由于刷新操作的优先级高，刷新操作时正常的读/写操作被暂停，数据线输出被封锁。等所有行刷新结束后，又开始正常的读/写周期。由于在刷新的过程中不允许读/写操作，集中式刷新策略存在“死时间”。</p>
<p><strong>分散式刷新策略</strong>中，每一行的刷新操作被均匀地分配到刷新周期时间内。将每个系统工作周期分为两部分，前半部分用于DRAM读/写/ 保持，后半部分用于刷新存储器的一行；</p>
<h2 id="存储扩展">存储扩展</h2>
<h3 id="位扩展">位扩展</h3>
<p>例如：由1K×4的存储芯片构成1K×8的存储器</p>
<p>存储芯片与CPU的引脚连接方法：</p>
<ul>
<li>地址线：各芯片的地址线<strong>直接</strong>与CPU地址线连接；</li>
<li>数据线：各芯片的数据线<strong>分别与CPU数据线的不同位连接</strong>；</li>
<li>片选及读写线：各芯片的片选及读写信号<strong>直接</strong>与CPU的访存及读写信号连接；</li>
</ul>
<h3 id="字扩展">字扩展</h3>
<p>字扩展：每个单元位数不变，总的单元个数增加。例如：用1K×8的存储芯片构成2K×8的存储器</p>
<p>存储芯片与CPU的引脚连接方法：</p>
<ul>
<li>地址线：各芯片的地址线与CPU的<strong>低位地址线直接连接</strong>；</li>
<li>数据线：各芯片的数据线<strong>直接</strong>与CPU数据线连接；</li>
<li>读写线：各芯片的读写信号直接与CPU的读写信号连接；</li>
<li>片选信号：各芯片的片选信号<strong>由CPU的高位地址和访存信号产生</strong>；</li>
</ul>
<h3 id="计算字位扩展所需的存储芯片的数目">计算字位扩展所需的存储芯片的数目</h3>
<p>用L×K的芯片构成M×N的存储系统：所需芯片总数为<br />
<span class="math display">\[
M/L \times N/K
\]</span><br />
扩展的时候可以使用74LS138等选择器</p>
<h2 id="rom">ROM</h2>
<p>其访问速度比 RAM 稍低，可以按地址随机访问并在线执行程序，因而在计算机中用于储存固件、引导加载程序、监控程序及不变或很少改变的数据。“只读”的意思是在其工作时只能读出，不能写入。</p>
<ul>
<li>掩模式ROM
<ul>
<li>定义：数据在芯片制造过程中写入，不能更改；</li>
<li>优点：可靠性、集成度高，价格便宜；</li>
<li>缺点：通用性差，不能改写内容；</li>
</ul></li>
<li>一次编程ROM（PROM）
<ul>
<li>定义：用户第一次使用时写入确定内容；</li>
<li>优点：用户可根据需要对ROM编程；</li>
<li>缺点：只能写入一次，不能更改；</li>
</ul></li>
<li>多次编程ROM
<ul>
<li>定义：可用紫外光照射（EPROM）或电擦除（E2PROM） 多次改写其中内容；</li>
<li>优点：通用性较好，可反复使用；</li>
</ul></li>
<li>闪速存储器（Flash Memory）
<ul>
<li>定义：一种高密度、非易失性的读/写半导体存储器，它突破了 传统的存储器体系，改善了现有存储器的特性。</li>
<li>在EPROM功能基础上，增加了电路的电擦除 和重新编程能力；也叫快擦型存储器。</li>
</ul></li>
</ul>
<h3 id="有关存储器选择">有关存储器选择</h3>
<p>系统程序区默认为写死的，因此使用ROM，用户程序需要修改因此使用RAM。</p>
<h3 id="存储器设计的连接要点">存储器设计的连接要点</h3>
<p>参考<a href="#存储扩展">存储扩展</a></p>
<ul>
<li>片选线的连接
<ul>
<li>一般使用CPU的高位地址线的和CPU的访存允许控制信号 线/MREQ，经译码器译码后产生各芯片的片选信号。</li>
<li>关键点，也是最容易出错的地方。</li>
</ul></li>
</ul>
<h2 id="并行存储器">并行存储器</h2>
<h3 id="双端口存储器">双端口存储器</h3>
<p>双端口存储器采用空间并行技术：同一个存储体使用两组相互独立的读写控制线路，可并行操作。</p>
<p>显卡上的存储器一般都是双端口存储器。</p>
<p>读写特点</p>
<ul>
<li>无冲突读写：访问的存储单元不同，可并行读写存储体；</li>
<li>有冲突读写：访问同一存储单元，可使用/BUSY信号控制读写优先顺序；</li>
</ul>
<h3 id="多模块交叉存储器">多模块交叉存储器</h3>
<h4 id="顺序方式">顺序方式</h4>
<p>访问地址按顺序分配给一个模块后，接着又按顺序为下一个模块分配访问地址。这样，存储器的 32个字可由 5 位地址寄存器指示，其中高 2 位选择 4 个模块中的一个，低 3 位选择每个模块中的 8 个字。</p>
<p>在顺序方式中某个模块进行存取时，其他模块不工作。而某一模块出现故障时，其他模块可以照常工作。另外通过增添模块来扩充存储器容量也比较方便。但顺序方式的缺点是各模块一个接一个<strong>串行工作</strong>，因此存储器的带宽受到了限制。</p>
<h4 id="交叉方式">交叉方式</h4>
<p>每个模块的单元地址是 不连续的；连续地址分 布在相邻的不同模块内。</p>
<blockquote>
<p>对于数据的成块传送， 各模块可以实现多模块 流水式并行存取；</p>
</blockquote>
<p>当存储器寻址时，用地址寄存器的低 2 位选择 4 个模块中的一个，而用高 3 位选择模块中的 8 个字。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201751840.png" alt="image-20220620175154754" title="">
                </div>
                <div class="image-caption">image-20220620175154754</div>
            </figure>
<h4 id="二者带宽计算">二者带宽计算</h4>
<p>模块数为m，存储周期为T，总线周期 <span class="math inline">\(\tau\)</span></p>
<p>连续传送m个字：</p>
<p><strong>顺序</strong>： <span class="math inline">\(m*T\)</span></p>
<p><strong>交叉</strong>：<span class="math inline">\(T+(m-1)*\tau\)</span></p>
<h2 id="cache">Cache</h2>
<p>Cache的作用：</p>
<ul>
<li>在CPU和主存之间加一块高速的SRAM（Cache）；</li>
<li>主存中将要被访问的数据提前送到Cache中；</li>
<li>CPU访存时，先访问Cache，若没有再进行数据调度。</li>
</ul>
<p>使用Cache的依据：在一段时间内，CPU所执行的程序和访问的数据大部分都在 某一段地址范围内，而该段范围外的地址访问很少；（程序访问的局部性原理）</p>
<p>CPU 与 cache 之间的数据交换是以字为单位，而 cache 与主存之间的数据交换是以块为单位。一个块由若干字组成，是定长的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201802839.png" alt="image-20220620180201780" title="">
                </div>
                <div class="image-caption">image-20220620180201780</div>
            </figure>
<p>当 CPU 读取内存中一个字时，便发出此字的内存地址到 cache 和主存。此时 cache 控制逻辑依据地址判断此字当前是否在 cache 中：若是，则 <strong>cache 命中</strong>，此字立即传送给 CPU；若非，则 <strong>cache 缺失(未命中)</strong>，用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到cache 中。</p>
<h3 id="读操作">读操作</h3>
<p>CPU发出有效的主存地址：</p>
<ol type="1">
<li>经地址变换机构，变换为可能的Cache地址；</li>
<li>查找块表，判断所要访问的信息是否在Cache中；
<ol type="1">
<li>若在，则CPU直接读取Cache获取数据；</li>
<li>若不在，则CPU访问主存，并判断Cache是否已满；
<ol type="1">
<li>若Cache未满，将该数据所在块从主存中调入Cache；</li>
<li>若Cache已满，使用某种替换机制，使用当前数据块替换 掉Cache中的某些块。</li>
</ol></li>
</ol></li>
</ol>
<h3 id="写操作">写操作</h3>
<p>CPU发出有效的主存地址：</p>
<ol type="1">
<li>经地址变换机构，变换为可能的Cache地址；</li>
<li>找对应的相联存储器，判断所要访问的信息是否在Cache中；
<ol type="1">
<li>若不在，则使CPU直接写主存数据；</li>
<li>若在，则使用某种写策略将数据写入Cache。</li>
</ol></li>
</ol>
<h3 id="cache的命中率">cache的命中率</h3>
<p>命中率 = 访问信息在Cache中的次数 / 访问总次数</p>
<p>影响命中率的主要因素</p>
<ul>
<li>Cache 容量：
<ul>
<li>过小时，局部信息装不完，命中率低。</li>
<li>过大时，对提高效率不明显，且成本高。</li>
</ul></li>
<li>Cache中块的大小： 一般用一个主存周期所能调出的单元数（字或字节）作 为一个块大小。</li>
</ul>
<p>Cache/主存系统的平均访问时间<span class="math inline">\(t_a\)</span>为<br />
<span class="math display">\[
t_a = ht_c + (1-h)t_m
\]</span></p>
<ul>
<li><p>tc ——命中时的cache访问时间</p></li>
<li><p>tm ——未命中时的主存访问时间</p></li>
<li><p>h ——命中率</p></li>
</ul>
<p>设 <span class="math inline">\(r = t_m/t_c\)</span> 访问效率为<br />
<span class="math display">\[
e = \frac{t_c}{t_a} = \frac{t_c}{ht_c + (1-h)t_m} = \frac{1}{h + (1-h)r} = \frac{1}{r + (1-r)h}
\]</span><br />
平均访问时间同样也可以计算为<br />
<span class="math display">\[
t_a = t_c/e
\]</span></p>
<h3 id="地址映射">地址映射</h3>
<p>cache 与主存的数据交换是以块为单位。为了把主存块放到 cache 中，必须应用某种方法把主存地址定位到 cache 中，称为<strong>地址映射</strong>。“映射”一词的物理含义是确定位置的对应关系，并用硬件来实现。这样当 CPU 访问存储器时，它所给出的一个字的内存地址会自动变换成 cache 的地址，即 <strong>cache 地址变换</strong>。</p>
<h4 id="全相联映射方式">全相联映射方式</h4>
<p>cache 的数据块大小称为行，用 <span class="math inline">\(L_i\)</span> 表示，其中 <span class="math inline">\(i=0,1,2,…,m–1\)</span>，共有 $m=2^r $行。主存的数据块大小称为块，用 $B_j $ 表示，其中 $ j=0,1,2,…,n–1$ ，共有 $n=2^s $块。行与块是等长的，每个块(行)由 <span class="math inline">\(k=2^w\)</span> 个连续的字组成，字是 CPU 每次访问存储器时可存取的最小单位。</p>
<p>主存中的任意字块可调进cache的任一行中；</p>
<p>当主存的数据块调入Cache中时，该块的块号（主存标记） 保存于调入Cache行的对应标记位（即块表中）</p>
<blockquote>
<p>块表的大小应为<span class="math inline">\(2^c×m\)</span>位，c为行地址长度，m为块地址长度</p>
</blockquote>
<p>在全相联映射中，将主存中一个块的地址(块号)与块的内容(字)一起存于 cache 的行<br />
中，其中块地址存于 cache 行的标记(tag)部分中。这种带全部块地址一起保存的方法，可使主存的一个块直接复制到 cache 中的任意一行上，非常灵活。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201817114.png" alt="image-20220620181718030" title="">
                </div>
                <div class="image-caption">image-20220620181718030</div>
            </figure>
<p>特点：</p>
<ul>
<li>优点：
<ul>
<li>灵活性好(最理想)，Cache中只要有空行，就可以调入所需要的主存数据块；</li>
</ul></li>
<li>缺点：
<ul>
<li>成本高：标记位为m位，使cache标记容量变大；</li>
<li>速度太慢：访问cache时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在cache中；</li>
</ul></li>
<li>一般较少使用。</li>
</ul>
<h4 id="直接映射">直接映射</h4>
<p>主存中的每一块数据只能调入Cache的特定行中；</p>
<p>地址映射函数为<br />
<span class="math display">\[
i = j\mod 2^c
\]</span><br />
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201844159.png" alt="image-20220620184431080" title="">
                </div>
                <div class="image-caption">image-20220620184431080</div>
            </figure></p>
<p>地址格式：</p>
<ul>
<li>主存共<span class="math inline">\(2^n\)</span>个单元，分成<span class="math inline">\(2^m\)</span>个块，每块单元数为<span class="math inline">\(2^b\)</span>个：主存地址为m+b位；</li>
<li>Cache空间分成<span class="math inline">\(2^c\)</span>行，每行大小也应为<span class="math inline">\(2^b\)</span>单元：Cache地址为c+b位；</li>
<li>直接映射中主存块与Cache行的关系：
<ul>
<li>主存的<span class="math inline">\((2^m/ 2^c)= 2^{m-c}\)</span>个块映射于Cache的同一行；</li>
<li>主存地址中的c位决定该主存块对应的Cache行，m-c位为 主存标记；</li>
<li>块表的大小应为<span class="math inline">\(2^c×(m-c)\)</span>位；</li>
<li>主存的地址格式为：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201849021.png" alt="image-20220620184925945" title="">
                </div>
                <div class="image-caption">image-20220620184925945</div>
            </figure></li>
</ul></li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>一个主存块只能调入cache的一个特定行中 。</li>
<li>优点：该映射函数实现简单，查找速度快；
<ul>
<li>主存地址的中间c位即为Cache的行地址；</li>
<li>在对应的块表中使用高t位地址进行比较，决定是否命中；</li>
</ul></li>
<li>缺点：灵活性差；
<ul>
<li>主存的2t个字块只能对应唯一的Cache字块，即使Cache 中别的字块空着也不能占用。</li>
</ul></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201857079.png" alt="image-20220620185701996" title="">
                </div>
                <div class="image-caption">image-20220620185701996</div>
            </figure>
<p>若CPU发出的主存地址为0000 01 001；</p>
<ol type="1">
<li>先取高4位地址（主存标记0000）送往比较器的一端；</li>
<li>再用中间的2位地址（Cache行号01），在块表中取出该单 元中保存的主存标记送往比较器的另一端；</li>
<li>若二者相等，则为命中，直接访问Cache的第01行中地址 为001的单元，读取数据；</li>
<li>若二者不相等，则为未命中；</li>
</ol>
<h4 id="组相联映射">组相联映射</h4>
<p>组相联映射是直接映射和全相联映射的一种折中方案。</p>
<p>映射关系：将Cache中的行等分为若干组，主存中的每一块只能映射 到Cache的特定组中，但是可调入到该组的任一行中；</p>
<p>组间为直接映射，组内为全相联映射。</p>
<p>设Cache共u组，每组v行，则映射函数如下<br />
<span class="math display">\[
q = j \mod u
\]</span><br />
当Cache的一组包含r行时，通常称为<strong>r路组相联映射</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201950729.png" alt="image-20220620195000670" title="">
                </div>
                <div class="image-caption">image-20220620195000670</div>
            </figure>
<p>特点：</p>
<ul>
<li>灵活性：比直接映射灵活（主存可映射到组内任一块）；</li>
<li>快速性：比全相联比较次数少，只需组内全部比较；</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201959278.png" alt="image-20220620195959199" title="">
                </div>
                <div class="image-caption">image-20220620195959199</div>
            </figure>
<h3 id="替换策略">替换策略：</h3>
<h4 id="最不经常使用lfu算法">最不经常使用(LFU)算法</h4>
<ul>
<li>替换原则：将<strong>一段时间内</strong>被访问次数最少的那行数据替换出去；</li>
<li>使用方法
<ul>
<li>每行设置一个计数器，从0开始计数;</li>
<li><strong>每访问一次， 被访行的计数器增1;</strong></li>
<li>当需要替换时，将计数值最小的行换出，同时将这些行的计数器都清零。</li>
</ul></li>
<li>特点：这种算法将计数周期限定在对这些特定行两次替换之间的间 隔时间内，<strong>不能严格反映近期访问情况。</strong></li>
</ul>
<h4 id="近期最少使用lru算法">近期最少使用(LRU)算法</h4>
<ul>
<li>替换原则：将近期内长久未被访问过的行替换出去。</li>
<li>使用方法
<ul>
<li>每行也设置一个计数器;</li>
<li>每访问一次，被访行的计数器清零，其它各行计数值1；</li>
<li>当需要替换时，将计数值最大的行换出。</li>
</ul></li>
<li>特点：这种算法保护了刚拷贝到cache中的新数据行，使Cache的使用率较高。</li>
</ul>
<h4 id="随机替换算法">随机替换算法</h4>
<ul>
<li>替换原则：从特定的行位置中随机地选取一行换出。</li>
<li>特点：在硬件上容易实现，且速度也比前两种策略快。但降低了命中率和cache工作效率。</li>
</ul>
<h3 id="写策略">写策略</h3>
<h4 id="写回式">写回式</h4>
<ul>
<li>写入策略：只修改cache的内容，而不立即写入主存；只有当此行被换出时才写回主存。</li>
<li>优点：减少了访问主存的次数</li>
<li>缺点：存在Cache与主存不一致性的隐患。</li>
</ul>
<blockquote>
<p>实现该方法时，cache行必须配置一个修改位，以反映此行是否被CPU修改过。</p>
</blockquote>
<h4 id="全写式">全写式</h4>
<blockquote>
<p>这种策略又称写透式</p>
</blockquote>
<ul>
<li>写入策略：cache与主存同时发生写修改，因而较好地维护了cache与主存的内容的一致性。cache中每行无需设置一个修改位以及相应的判断逻辑。</li>
<li>缺点：降低了cache的功效。</li>
</ul>
<h4 id="写一次法">写一次法</h4>
<ul>
<li>写入策略：
<ul>
<li>基于写回法，并结合全写法的写策略;</li>
<li>写命中与写未命中的处理方法与写回法基本相同， 只是第一次写命中时要同时写入主存。</li>
</ul></li>
</ul>
<blockquote>
<p>第一次写命中时，启动一个主存的写周期，其目的是 使其它Cache可以及时更新或废止该块内容，这便于 维护系统全部cache的一致性</p>
</blockquote>
<h1 id="指令系统">指令系统</h1>
<h2 id="操作码">操作码</h2>
<p>两地址指令的分类：</p>
<ul>
<li>SS（存储器-存储器）</li>
<li>RR 这种指令结构常用于<strong>算术逻辑运算</strong>类指令</li>
<li>RS</li>
</ul>
<h3 id="操作码扩展">操作码扩展</h3>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202106203.png" alt="image-20220620210635102" title="">
                </div>
                <div class="image-caption">image-20220620210635102</div>
            </figure>
<h3 id="指令字长度">指令字长度</h3>
<p><strong>机器字长</strong>：运算器一次能处理的二进制数的位数。机器指令的长度直接决定着CPU运算的精度和直接寻址能 力的大小；</p>
<p><strong>指令字长</strong>：一个指令字中包含二进制代码的位数； ¡指令字长由操作码长度、操作数长度和个数共同决定。指令有半<strong>字长、单字长、双字长、多字长</strong>等不同的长度类型；指令系统可分为等长指令字结构、变长指令字结构两种。</p>
<h2 id="寻址方式">寻址方式</h2>
<h3 id="指令寻址">指令寻址</h3>
<ul>
<li>顺序寻址方式：当程序按顺序执行时的指令寻址方式；
<ul>
<li>必须用程序计数器记录所要执行指令的存放单元地址；</li>
<li>一般做顺序加1的操作；</li>
<li>程序计数器又称指令指针寄存器；</li>
</ul></li>
<li>跳跃寻址方式：当程序转移执行时的指令寻址方式；程序计数器的内容由本条指令给出，而不是顺序改变。</li>
</ul>
<h3 id="操作数的寻址方式">操作数的寻址方式</h3>
<ul>
<li>隐含寻址</li>
<li>立即寻址</li>
<li>直接寻址</li>
<li>间接寻址</li>
<li>寄存器寻址</li>
<li>寄存器间接寻址</li>
<li>偏移寻址</li>
<li>堆栈寻址；</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202111661.png" alt="image-20220620211148581" title="">
                </div>
                <div class="image-caption">image-20220620211148581</div>
            </figure>
<h4 id="偏移寻址">偏移寻址</h4>
<p><strong>相对寻址</strong>： 隐含引用的专用寄存器是程序计数器(PC)，即 EA=A+(PC)，它是当前 PC<br />
的内容加上指令地址字段中 A 的值。一般来说，地址字段的值在这种操作下被看成 2 的补码数的值。因此有效地址是对当前指令地址的一个上下范围的偏移，它基于程序的局部性原理。使用相对寻址可节省指令中的地址位数，也便于程序在内存中成块搬动。<br />
<strong>基址寻址</strong> ：被引用的专用寄存器含有一个存储器地址，地址字段含有一个相对于该地<br />
址的偏移量(通常是无符号整数)。寄存器的引用可以是显式的，也可以是隐式的。基址寻址也利用了存储器访问的局部性原理。后面讲到的段寻址方式中，就采用了段基址寄存器，它提供了一个范围很大的存储空间。</p>
<p><strong>变址寻址</strong> ：地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，<strong>与基址寻址刚好相反</strong>。但是二者有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如，主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时值 A 存入指令地址字段，再用一个变址寄存器(初始化为 0)。每次操作之后，变址寄存器内容增 1。此时，EA=A+(R)，R←(R+1)。</p>
<blockquote>
<p>基址寻址把 <strong>寄存器</strong>中的作为基础，指令中给出偏移量</p>
<p>变址寻址把 <strong>指令中的地址</strong>作为基础，寄存器给出偏移量</p>
</blockquote>
<h4 id="段寻址">段寻址</h4>
<p>微型机中采用了段寻址方式，例如，它们可以给定一个20 位的地址，从而有 220=1MB 存储空间的直接寻址能力。为此将整个 1MB 空间存储器按照最大长度 64KB 划分成若干段。在寻址一个内存具体单元时，由一个基地址再加上某些寄存器提供的 16 位偏移量来形成实际的 20 位物理地址。这个基地址就是 CPU 中的段寄存器。在形成 20 位物理地址时，段寄存器中的 16 位数会自动左移 4 位，然后与 16 位偏移量相加，即可形成所需的内存地址。<strong>这种寻址方式的实质还是基址寻址。</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202117888.png" alt="image-20220620211746817" title="">
                </div>
                <div class="image-caption">image-20220620211746817</div>
            </figure>
<h1 id="中央处理器">中央处理器</h1>
<h2 id="cpu的功能">CPU的功能</h2>
<p>CPU（中央处理器）：控制程序按设定方式执行；</p>
<p>CPU的主要功能：</p>
<ul>
<li>指令控制：控制程序的执行顺序；<em>顺序寻址、跳跃寻址</em></li>
<li>操作控制：产生和发送各操作信号；<em>对指令操作码译码后产生控制信号</em></li>
<li>时间控制：控制指令、或操作的实施时间；<em>维持各类操作的时序关系</em></li>
<li>数据加工：对数据进行算术逻辑运算；<em>由ALU完成具体的运算</em></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202123291.png" alt="image-20220620212327176" title="">
                </div>
                <div class="image-caption">image-20220620212327176</div>
            </figure>
<h2 id="指令周期">指令周期</h2>
<ul>
<li>指令周期：CPU从内存中取出一条指令，并执行的时间总和</li>
<li>CPU周期：又称机器周期，一般为从内存读取一条指令字的最短时间；一个CPU周期可以完成CPU的一个基本操作。</li>
<li>时钟周期：也叫节拍脉冲或T周期，是计算机处理操作的基本时间单位。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202126098.png" alt="image-20220620212637023" title="">
                </div>
                <div class="image-caption">image-20220620212637023</div>
            </figure>
<blockquote>
<p>不同指令的指令周期所包含的 时钟周期个数不一定相同。</p>
</blockquote>
<h3 id="mov-r1-r2">MOV R1, R2</h3>
<p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202130085.png" alt="image-20220620212746096" style="zoom:100%" align="center"/></p>
<h3 id="lad-r1-addr">LAD R1, ADDR</h3>
<p>从数据存储器单元取出数据装入通用寄存器R</p>
<p>三个CPU周期：</p>
<ol type="1">
<li><p>取指周期</p></li>
<li><p>间址周期：从IR的地址码字段获 取操作数地址；（或 者通过计算获得EA）</p></li>
<li><p>执行周期：访存获取操作数送入 通用寄存器R1；</p></li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202133732.png" alt="image-20220620213324658" title="">
                </div>
                <div class="image-caption">image-20220620213324658</div>
            </figure>
<h3 id="add-r1-r2">ADD R1 , R2</h3>
<p>取指周期（略）</p>
<p>执行周期</p>
<ul>
<li>从寄存器R1、R2中取出数据，作为源操作数；</li>
<li>将两数据送往ALU，并使ALU进行加运算；</li>
<li>结果保存到R1中</li>
</ul>
<h3 id="sto-r2-r3">STO R2 , (R3)</h3>
<p>STO指令是RS型指令，需要3个CPU周期。存数指令 R2 -&gt; [R3]</p>
<p>取指周期（略）</p>
<p>间址周期：根据R3中的地址寻址所要访问的存储单元；</p>
<p>执行周期：将寄存器R2中的数据送入指定的存储单元；</p>
<h3 id="jmp">JMP</h3>
<p>两个周期：</p>
<p>取指</p>
<p>执行：直接给PC赋值</p>
<h2 id="微指令和微程序">微指令和微程序</h2>
<ul>
<li><p>控制存储器（CM）：存放实现全部指令系统的微指令；由只读存储器构成，要求速度快，读出周期短。</p></li>
<li><p>微指令寄存器：存放由控制存储器读出的一条微指令信息；</p>
<ul>
<li>微地址寄存器：决定将要访问的下一条微指令的地址；</li>
<li>微命令寄存器：保存一条微指令的操作控制字段和判别测试字 段的信息。</li>
</ul></li>
<li><p>地址转移逻辑</p></li>
</ul>
<p>顺序控制部分的P1、P2为判别测试标志；</p>
<ul>
<li>若为00，则顺序寻址微指令；</li>
<li>若为01、10，则跳跃寻址微指令。</li>
</ul>
<p>微操作在执行部件中是最基本的操作。由于数据通路的结构关系，微操作可分为相容<br />
性和相斥性两种。所谓<strong>相容性的微操作</strong>，是指在同时或同一个 CPU 周期内可以并行执行的微操作。所谓<strong>相斥性的微操作</strong>，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。</p>
<h4 id="cpu周期与微指令周期关系">CPU周期与微指令周期关系</h4>
<p><strong>微指令周期</strong>：读出微指令的时间加上执行该条微指令的时间；串行方式的微程序控制器中的概念；</p>
<p>一般来讲，一个微指令周期时间设计得<strong>恰好和CPU 周期时间相等</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202228777.png" alt="image-20220620222820709" title="">
                </div>
                <div class="image-caption">image-20220620222820709</div>
            </figure>
<h4 id="机器指令与微指令的关系">机器指令与微指令的关系</h4>
<p>一条机器指令对应一个微程序，一个微程序由若干条微指 令序列组成的；一条机器指令所完成的操作划分成若干条微指令来完成， 由微指令进行解释和执行。</p>
<p>从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者与内存有关，后者与控制存储器有关。</p>
<p>每一个CPU周期对应一条微指令。</p>
<h3 id="微程序设计技术">微程序设计技术</h3>
<h4 id="微命令编码">微命令编码</h4>
<p><strong>直接表示法</strong>：操作控制字段中的每一位代表一个微命令；</p>
<ul>
<li><p>优点：简单直观，其输出可直接用于控制，执行速度快；</p></li>
<li><p>缺点：微指令字较长，因而使控制存储器容量较大。</p></li>
</ul>
<p><strong>编码表示法</strong>：将微指令操作控制字段划分为若干个子字段；每个子字段的所有微命令进行统一编码；每个子字段的不同编码表示不同的微命令；</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202232668.png" alt="image-20220620223233590" title="">
                </div>
                <div class="image-caption">image-20220620223233590</div>
            </figure>
<ul>
<li>遵循原则：
<ul>
<li>把<strong>相斥的微命令</strong>划分在同一个字段中，相容的微命令划分 在不同字段；</li>
<li>字段的划分应与数据通路结构相适应；</li>
<li>每个子字段应留出一个<strong>空操作</strong>状态；</li>
<li>每个子字段所定义的微命令不宜太多；</li>
</ul></li>
<li>优点：可大大缩短微指令字长；</li>
<li>缺点：需要微命令译码，故微程序的执行速度稍稍减慢。</li>
</ul>
<h4 id="微地址的形成方法">微地址的形成方法</h4>
<p><strong>计数器方式</strong>：同CPU中程序计数器产生机器指令地址的方法相类似。</p>
<ul>
<li>优点：微指令的顺序控制字段较短，微地址产生机构简单。</li>
<li>缺点：多路并行转移功能较弱，速度较慢，灵活性较差。</li>
</ul>
<p><strong>多路转移方式</strong>：可根据“判别测试”标志和“状态条件”信息选定某 一个候选微地址的方法。</p>
<ul>
<li>特点：能以较短的顺序控制字段配合，实现多路并行转移， 灵活性好，速度较快；</li>
<li>但转移地址逻辑需要用组合逻辑方法设计</li>
</ul>
<h4 id="微指令格式">微指令格式</h4>
<p><strong>水平型微指令</strong>：一次能定义并执行多个并行操作微命令的微指令；一般由操作控制字段、判别测试字段、下地址字段三部分构成；根据控制字段编码方式的不同，可分为全水平型、字段译码法水平型、直接和译码相混合的水平型三种微指令。</p>
<p><strong>垂直型微指令</strong>：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能；垂直型微指令的结构类似于机器指令的结构。在一条微指令中只有 1～2 个微操作命令，每条微指令的功能简单，因此，实现一条机器指令的微程序要比水平型微指令编写的微程序长得多。它是采用较长的微程序结构去换取较短的微指令结构。</p>
<ol type="1">
<li>水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。</li>
<li>水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。</li>
<li>由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反，微指令字较短而微程序长。</li>
<li>水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。</li>
</ol>
<h2 id="流水cpu">流水CPU</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202246529.png" alt="image-20220620224644452" title="">
                </div>
                <div class="image-caption">image-20220620224644452</div>
            </figure>
<h1 id="总线系统">总线系统</h1>
<p>构成计算机系统的互联机构，是系统内各功能部件之间进行 信息传送的公共通路。</p>
<p><strong>总线宽度</strong>：一次总线操作中，最多可传送的数据位数。</p>
<p><strong>总线周期</strong>：一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T=1/f</p>
<p><strong>总线带宽</strong>：单位时间内通过总线的数据位数，总线的数据传输率；单位一般为MB/s。</p>
<p><strong>单总线结构</strong>：系统内的所有部件均由系统总线连接；</p>
<p><strong>双总线结构</strong>：系统内的所有部件均由系统总线连接；在CPU和主存之间再 专门设置了一组高速的存储总线。</p>
<p><strong>三总线结构</strong>：系统总线负责连接CPU、主存、I/O通道；存储总线负责连接 CPU与主存；I/O总线负责连接各I/O适配器。</p>
<h2 id="总线的仲裁">总线的仲裁</h2>
<ul>
<li><p>集中式：由中央仲裁器决定总线使用权的归属。</p></li>
<li><p>分布式：多个仲裁器竞争使用总线。</p></li>
</ul>
<h3 id="集中式">集中式</h3>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202248599.png" alt="image-20220620224812519" title="">
                </div>
                <div class="image-caption">image-20220620224812519</div>
            </figure>
<blockquote>
<p>计数器定时查询方式：设备的优先权由计数值决定，计数值为0时同链式查询方式；</p>
<p>每次计数可以从“0”开始，也可以从中止点开始。如果从“0”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。计数器的初值也可用程序来设置，这就可以方便地改变优先次序，显然这种灵活性是以增加线数为代价的。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202255904.png" alt="image-20220620225551800" title="">
                </div>
                <div class="image-caption">image-20220620225551800</div>
            </figure>
<h3 id="分布式">分布式</h3>
<p>分布式仲裁不需要中央仲裁器，由分布在各部件中的多个仲裁 器竞争使用总线。</p>
<p>每个潜在的主模块都有自己的仲裁器和唯一的仲裁号，通过仲 裁总线上仲裁号的比较，决定可占用总线的部件。</p>
<ol type="1">
<li>某部件有总线请求时，将其仲裁号发送到共享仲裁总线上；</li>
<li>每个仲裁器将仲裁总线上得到的号与自己的号进行比较；</li>
<li>如果仲裁总线上的号大，则它的总线请求不予响应，并撤 消它的仲裁号；</li>
<li>最后，获胜者的仲裁号保留在仲裁总线上。</li>
</ol>
<p>分布式仲裁是以<strong>优先级仲裁策略</strong>为基础。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202252578.png" alt="image-20220620225243489" title="">
                </div>
                <div class="image-caption">image-20220620225243489</div>
            </figure>
<h1 id="外围设备">外围设备</h1>
<h2 id="磁盘存储设备">磁盘存储设备</h2>
<p>在磁表面存储器中，信息的读写是利用磁头来进行的；</p>
<ul>
<li>磁头：由软磁材料做铁芯，绕有读写线圈的电磁铁。</li>
<li>写操作：原理：电-磁变换；利用磁头写线圈中的脉冲电流，在磁表面每个存储元上形 成不同的磁化状态；</li>
<li>读操作：原理：磁-电变换；利用磁头读线圈， 将磁表面每个存储 元上的不同剩磁状 态转换成电信号读出；</li>
</ul>
<blockquote>
<p>硬磁盘按盘片结构，分成可换盘片式与固定盘片式两种；磁头也分为可移动磁头和固定磁头两种。</p>
</blockquote>
<p><strong>可移动磁头固定盘片的磁盘机</strong> 特点是一片或一组盘片固定在主轴上，盘片不可更换。盘片每面只有一个磁头，存取数据时磁头沿盘面径向移动。</p>
<p><strong>固定磁头磁盘机</strong> 特点是磁头位置固定，磁盘的每一个磁道对应一个磁头，盘片不可更换。优点是存取速度快，省去磁头找道时间，缺点是结构复杂。</p>
<p><strong>可移动磁头可换盘片的磁盘机</strong> 盘片可以更换，磁头可沿盘面径向移动。优点是盘片可以脱机保存，同种型号的盘片具有互换性。</p>
<p><strong>温彻斯特磁盘机</strong> 温彻斯特磁盘简称<strong>温盘</strong>，是一种采用先进技术研制的可移动磁头固定盘片的磁盘机。它是一种密封组合式的硬磁盘，即磁头、盘片、电机等驱动部件乃至读写电路等组装成一个不可随意拆卸的整体。工作时，高速旋转在盘面上形成的气垫将磁头平稳浮起。优点是防尘性能好，可靠性高，对使用环境要求不高，成为最有代表性的硬磁盘存储器。而普通的硬磁盘要求具有超净环境，只能用于大型计算机中。</p>
<h3 id="磁盘上信息的分布">磁盘上信息的分布</h3>
<ul>
<li>记录面：磁盘片表面；一个盘片有上下两个记录面。</li>
<li>磁道：记录面上一系列同心圆；
<ul>
<li>最外圈为0磁道 ，依次为1、2、……、N磁道；</li>
<li>每个磁道的存储容量均相同；</li>
<li>不同盘片的相同磁道构成一个柱面；</li>
</ul></li>
<li>扇区：同心圆上的一段磁道区域；每个扇区的存储容量也相同。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210904391.png" alt="image-20220621090432994" title="">
                </div>
                <div class="image-caption">image-20220621090432994</div>
            </figure>
<h3 id="技术指标">技术指标</h3>
<ul>
<li><p>存储密度</p>
<ul>
<li><p>道密度：沿磁盘半径方向单位长度上的磁道数；单位：道/英寸。</p></li>
<li><p>位密度：磁道单位长度上能记录的二进制代码位数；单位：位/英寸。注意：每个磁道的位密度均不相同，有最高、最低位密度。</p>
<blockquote>
<p>0磁道的位密度为最低位密度；</p>
</blockquote></li>
<li><p>面密度：位密度和道密度的乘积；单位：位/平方英寸。</p></li>
</ul></li>
<li><p>存储容量：一个磁盘存储器所能存储的字节总数；</p>
<blockquote>
<p>存储容量=记录面数×每面磁道数×磁道容量</p>
</blockquote>
<ul>
<li>非格式化容量：磁记录表面可以利用的磁化单元总数。</li>
<li>格式化容量：按照某种特定的记录格式所能存储信息的总量，也就是用户可以真正使用的容量。格式化容量一般是非格式化容量的60%—70%。</li>
</ul></li>
<li><p>平均存取时间：从读/写指令发出到开始第一笔数据读/写时所用的平均时间</p>
<ul>
<li><p>平均访问时间近似等于平均寻道时间+平均等待时间，即平均寻址时间。</p></li>
<li><p>平均等待时间：与磁盘转速有关，是磁盘旋转一周时间的一半。</p></li>
<li><p><span class="math display">\[
T_a = T_s + \frac{1}{2r} + \frac{b}{rN}
\]</span></p>
<p>Ts平均寻道时间，b传送字节数，N每磁道字节数，r转速。</p>
<p>1/2r 平均等待时间；b/rN 数据<strong>传输时间</strong></p></li>
</ul></li>
<li><p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数；</p>
<ul>
<li>设磁盘旋转速度为每秒n转，磁道容量为N个字节：数据传输率Dr= n × N（字节/秒）</li>
<li>设某磁道位密度为D字节/英寸，磁盘转速为v英寸/秒，则数据传输率Dr= D × v （字节/秒）</li>
</ul></li>
</ul>
<p>有关描述</p>
<ul>
<li>内外径说的都是 <strong>直径</strong></li>
</ul>
<p>编址例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210925911.png" alt="image-20220621092504834" title="">
                </div>
                <div class="image-caption">image-20220621092504834</div>
            </figure>
<h1 id="输入输出系统">输入输出系统</h1>
<h2 id="程序查询方式">程序查询方式</h2>
<p><strong>工作过程</strong>：CPU传送数据之前先检查外设的状态，若没有准备好，则继续查询等待，直至外设就绪即进行数据传送。</p>
<p><strong>硬件要求</strong>：只需接口电路的状态、数据口，不需增加其他控制电路。</p>
<p><strong>特点</strong>：CPU主动查询，程序控制数据传送过程，简单易行；每次查询之后只能传送一个字或一个字节的数据，数据传输率不高，CPU时间浪费较多。</p>
<p><strong>适用场合</strong>：CPU不太忙且对传送速度要求不高的系统。</p>
<h3 id="统一编址方式">统一编址方式</h3>
<p>将I/O系统与主存系统作为一个整体进行编址</p>
<p><strong>优点</strong>：访问I/O端口可使用访存指令，操作类型多样使用灵活；I/O端口有较大的编址空间；</p>
<p><strong>缺点</strong>：占用主存空间，使实际主存容量减小；I/O访问的指令字长较长，执行速度慢。</p>
<h3 id="独立编址方式">独立编址方式</h3>
<p>将/O系统与主存系统分别编址；</p>
<p><strong>特点</strong>：I/O端口地址不占用主存空间；使用专用的I/O指令，指令字长短，执行速度快；与主存空间区分容易。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210939620.png" alt="image-20220621093936528" title="">
                </div>
                <div class="image-caption">image-20220621093936528</div>
            </figure>
<blockquote>
<p>可通过改变查询顺序修改设 备的优先权；CPU工作效率低；</p>
</blockquote>
<h2 id="程序中断">程序中断</h2>
<p><strong>工作过程</strong>：CPU有传送要求时，启动外设后可处理其他事件，当外设准就绪后，通过中断的方式和CPU完成数据传送工作。</p>
<p><strong>硬件要求</strong>：需要附加的中断控制电路。</p>
<p><strong>特点</strong>：一定程度上实现了CPU和外设的并行工作；中断操作过程增加了软硬件的开销，且每次数据传送只能传送一个字或一个字节的数据，数据传送效率低</p>
<p><strong>适用场合</strong>：CPU与慢速外设之间的数据传送。</p>
<blockquote>
<p>机器内部原因导致出错引起的中断叫内中断，也叫<strong>异常</strong>。外部设备请求服务的中断叫<strong>外中断</strong>。</p>
</blockquote>
<h3 id="流程">流程</h3>
<ol type="1">
<li>中断请求：CPU在结束一个指令周期后，检测中断请求信号；</li>
<li>中断响应
<ol type="1">
<li>关中断；</li>
<li>保护断点现场；</li>
<li>判断中断源，获取中断向量；</li>
<li>根据中断向量转入中断服务程序执行；</li>
</ol></li>
<li>中断服务
<ol type="1">
<li>保护CPU现场；</li>
<li>执行中断服务程序；</li>
<li>开中断；</li>
<li>恢复CPU现场；</li>
</ol></li>
<li>中断返回：恢复断点现场，返回主程序继续执</li>
</ol>
<h3 id="中断服务程序入口地址的获取">中断服务程序入口地址的获取</h3>
<p><strong>向量中断 </strong>：中断机构自动将相应中断源的中断向量地址送入 CPU，包括段地址和段内偏移地址， 共4个字节的内容</p>
<p>CPU响应中断时，将中断源对应的中断向量送入CS（段地 址）、IP（段内偏移地址）寄存器中，以跟踪中断服务程序 的执行。</p>
<p>一般而言，系统中所有的中断向量都按顺序存放在内存指定位置的一张<strong>中断向量表</strong>中，当 CPU 识别出某中断源时，由硬件直接产生一个与该中断源对应的中断向量地址，以便能快速在中断向量表中找到并转入中断服务程序入口。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210946334.png" alt="image-20220621094643232" title="">
                </div>
                <div class="image-caption">image-20220621094643232</div>
            </figure>
<blockquote>
<p>上图可知，中断类型号(n) × 4 ＝ 中断向量在表中的偏移地址</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210947669.png" alt="image-20220621094754589" title="">
                </div>
                <div class="image-caption">image-20220621094754589</div>
            </figure>
<h3 id="程序中断方式的基本-io-接口">程序中断方式的基本 I/O 接口</h3>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210948331.png" alt="image-20220621094845232" title="">
                </div>
                <div class="image-caption">image-20220621094845232</div>
            </figure>
<h3 id="单级中断系统">单级中断系统</h3>
<p>所有的中断源都属于同一个级别，不允许有中断嵌套；</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210950724.png" alt="image-20220621095013634" title="">
                </div>
                <div class="image-caption">image-20220621095013634</div>
            </figure>
<ol type="1">
<li><p>向量中断：由硬件直接产生一个与该中断源对应的向量地址；</p>
<p>向量地址——中断源的中断服务程序入口地址；</p>
<p>要求：在硬件设计时考虑所有中断源的向量地址。</p></li>
<li><p>位移量中断：由硬件直接产生一个位移量，该位移量加上CPU中某寄存器中的基地址，得到中断处理程序的入口地址。</p></li>
<li><p>向量地址转移：由硬件直接产生一个该中断源对应的固定地址码，该地址码中存放可转入中断服务程序的入口地址。</p></li>
</ol>
<h3 id="多级中断">多级中断</h3>
<p>根据各中断事件的轻重缓急程度不同而分成若干级别，每一中断级分配给一个优先权。一般说来，优先权高的中断级可以打断优先权低的中断服务程序，以程序嵌套方式进行工作。</p>
<blockquote>
<p>多级中断中需要进行优先权的控制和判断。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953108.png" alt="image-20220621095303010" title="">
                </div>
                <div class="image-caption">image-20220621095303010</div>
            </figure>
<p>改变优先级的方法：<strong>修改屏蔽字</strong></p>
<p>欲使第2级中断的优先权高于第3级：则可设置第3级中的屏蔽字设为：00001011第2级中的屏蔽字设为：00001111</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206210953558.png" alt="image-20220621095351474" title="">
                </div>
                <div class="image-caption">image-20220621095351474</div>
            </figure>
<h3 id="不可屏蔽中断nmi">不可屏蔽中断NMI</h3>
<p>由CPU的NMI引脚引入该中断请求，CPU得到该中断请求立即响应，不需要CPU发响应信号；</p>
<p>中断类型号固定为2；</p>
<p>中断优先权高于可屏蔽中断INTR，一般用于系统对紧急情况的处理，用户不能使用；</p>
<p>常见的NMI中断：</p>
<ul>
<li>系统RAM奇偶校验错、</li>
<li>I/O通道校验错、</li>
<li>协处理器出错等。</li>
</ul>
<h3 id="可屏蔽中断intr">可屏蔽中断INTR</h3>
<p>由CPU的INTR引脚引入该中断请求；</p>
<ul>
<li>该中断请求只有在CPU的中断允许标志位IF=1时，CPU才会通过发回响应信号的方式响应；</li>
<li>CPU对INTR中断的响应控制可由STI（允许响应INTR中断）、CLI（禁止响应INTR中断）两条指令完成。</li>
</ul>
<p>此类中断的中断类型号由<strong>中断源</strong>提供；</p>
<p>常见的INTR中断：</p>
<ul>
<li>外部设备的中断请求，如I/O设备的数据传送请求，用户可自行设计；</li>
</ul>
<h3 id="指令中断intn">指令中断INTN</h3>
<p>由CPU执行在程序中预先安排好的中断指令引起的；该中断是可预期的、且不可屏蔽的；</p>
<p>处理该中断时，<strong>CPU不需要发响应信号</strong>；</p>
<p>指令的操作数字段（n）即为中断类型号；</p>
<ul>
<li>中断类型号的范围为5≤n≤255；</li>
</ul>
<p>这类中断包括BIOS中断、DOS中断以及一些未定义的自由中断（可由系统扩充或根据应用需要自定义）。</p>
<h3 id="异常中断">异常中断</h3>
<p>由CPU内部的突发事件引起的中断，是不可屏蔽中断；</p>
<p>其中断类型号固定；</p>
<ul>
<li>除法错中断一一类型号为0；执行除法指令时，除数为0，或除得的商大于规定位数；</li>
<li>单步中断——类型号为1；</li>
<li>断点中断——类型号为3；</li>
<li>溢出中断——类型号为4；</li>
</ul>
<p>该类中断的实质：由CPU运行过程中的突发事件引起系统在适当位置<strong>自动添加一条中断指令</strong>，然后由CPU执行该指令引起的中断；</p>
<p>同指令中断一样，处理该中断时，<strong>CPU不需要发响应信号</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211003449.png" alt="image-20220621100318360" title="">
                </div>
                <div class="image-caption">image-20220621100318360</div>
            </figure>
<h2 id="直接内存访问">直接内存访问</h2>
<p><strong>工作过程</strong>：CPU分配总线使用权之后，在硬件DMA控制器（DMAC）的控制下完成存储器与高速外设之间的大量数据的传送。</p>
<p><strong>硬件要求</strong>：需要相应的DMA控制器及数据通路，电路结构复杂，硬件开销大。</p>
<p><strong>特点</strong>：数据传送不需要经过CPU，直接由硬件控制；外设与存储器之间的数据传送量大。</p>
<p><strong>适用场合</strong>：：包含有高速外设的系统中。</p>
<p>DMA（直接内存访问）方式磁盘与主存之间的数据传送，完全由硬件控制执行I/O交换的工作方式；DMAC完全接管系统总线的控制权，利用总线控制数据在主存和外设之间的直接传送，所交换的数据不经过CPU。</p>
<p><strong>特点</strong>：速度快，但硬件复杂度高。</p>
<p>DMA方式中，DMAC的工作：接受外设的DMA请求，并提交给CPU；接管总线的控制权，控制主存和外设之间的数据传送；完成数据传送后，交还总线使用权。</p>
<p>DMA传送时，<strong>CPU不能使用总线</strong>，会影响CPU的工作效率； 当CPU需要访存，或者访问外设时，程序会阻塞； 可使DMAC与CPU<strong>分时复用总线</strong>；</p>
<h3 id="停止cpu访问方式">停止CPU访问方式</h3>
<p>工作过程：DMA传送期间，由DMAC长期占用总线，CPU不能访存，只有DMA传送结束时才将总线归还给CPU使用；</p>
<p>特点：控制简单，适于高速外设的数据成组传送；内存使用效率不高。（一般外设的读写周期远大于主存的存取周期）</p>
<h3 id="周期挪用方式">周期挪用方式</h3>
<p>工作过程：每次DMA传送，都是通过外设挪用一个或几个主存周期， 分别完成数据的成块传送。</p>
<p>特点：主存使用效率较高，常用；</p>
<p>I/O 设备要求 DMA 传送时可能遇到两种情况：一种是此时 CPU 不需要访内，如 CPU<br />
正在执行乘法指令。由于乘法指令执行时间较长，此时 I/O 访内与 CPU 访内没有冲突，即I/O 设备挪用一两个内存周期对 CPU 执行程序没有任何影响。另一种是 I/O 设备要求访内时CPU 也要求访内，这就产生了访内冲突，在这种情况下 I/O 设备访内优先，因为 I/O 访内有时间要求，前一个 I/O 数据必须在下一个访内请求到来之前存取完毕。显然，在这种情况下I/O 设备挪用一两个内存周期，意味着 CPU 延缓了对指令的执行，或者更明确地说，在 CPU执行访内指令的过程中插入 DMA 请求，挪用了一两个内存周期。</p>
<h3 id="dma与cpu交替访存方式">DMA与CPU交替访存方式</h3>
<p>如果 CPU 的工作周期比内存存取周期长很多，则采用交替访内的方法可以使 DMA 传<br />
送和 CPU 同时发挥最高的效率；</p>
<p>假设 CPU 工作周期为1.2μs，内存存取周期小于 0.6μs，那么一个 CPU 周期可分为 C1 和 C2 两个分周期，其中 C1专供 DMA 控制器访内，C2 专供 CPU 访内。这种方式<strong>不需要总线使用权的申请、建立和归还过程</strong>，总线使用权是通过 C1 和 C2 分时控制的。</p>
<blockquote>
<p>CPU 和 DMA 控制器各自有自己的访内地址寄存器、数据寄存器和读/写信号等控<br />
制寄存器。</p>
</blockquote>
<p>工作过程：将CPU的工作周期一分为二，分别用于DMA和CPU访存；</p>
<p>特点：对主存的访问时间不会发生冲突，也不需要总线控制权的申请建立和归还过程；</p>
<p>也称为“透明DMA方式”；DMA传送不影响CPU的工作；</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206211013972.png" alt="image-20220621101304899" title="">
                </div>
                <div class="image-caption">image-20220621101304899</div>
            </figure>
<h3 id="dma数据传送过程">DMA数据传送过程</h3>
<ol type="1">
<li><p>DMA请求<br />
DMAC向CPU请求总线使用权；</p></li>
<li><p>DMA响应<br />
CPU给DMAC分配总线使用权；</p></li>
<li><p>DMA传送<br />
DMAC寻址外设和存储器；</p>
<p>DMAC控制外设与主存之间的数据传送，并检测是否传送结束；</p></li>
<li><p>DMA结束<br />
ODMAC归还总线使用权。</p></li>
</ol>
<h3 id="和中断控制方式的区别">和中断控制方式的区别</h3>
<ul>
<li>数据传送的实现方式<br />
中断——程序传送；DMA——硬件实现；</li>
<li>CPU响应请求的时间<br />
中断——一个指令周期结束；DMA——一个总线周期结束；</li>
<li>请求的目的<br />
中断——CPU的服务；DMA——总线的使用权；</li>
<li>是否需要保护现场<br />
中断——需要；DMA——不需要（CPU不参与数据传送）；</li>
<li>DMA的优先权高于中断的优先权。</li>
</ul>
<h2 id="通道方式">通道方式</h2>
<p><strong>工作过程</strong>：CPU将IO控制的权利下放给通道，由通道统一管理所有的输入输出操作。</p>
<p><strong>硬件要求</strong>：需要IO通道（也称IO处理器，IOP）；通道是一个具有特殊功能的处理器。</p>
<p><strong>特点</strong>：硬件代价较高；lO传送的效率高，并且减轻了CPU的工作负担。</p>
<p><strong>适用场合</strong>：高性能要求的系统中。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2022-06-21T09:25:24.613Z" itemprop="dateUpdated">2022-06-21 17:25:24</time>
</span><br>


        
        感谢浏览
        
    </div>
    
    <footer>
        <a href="https://xav1erw.github.io">
            <img src="/img/avatar.jpg" alt="Xav1er">
            Xav1er
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag">复习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E5%86%85/" rel="tag">课内</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&title=《计算机组成原理复习》 — Xav1er Blog&pic=https://xav1erw.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&title=《计算机组成原理复习》 — Xav1er Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《计算机组成原理复习》 — Xav1er Blog&url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&via=https://xav1erw.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2022/06/18/Review/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">形式语言与自动机复习</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/alipay.jpg" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Xav1er &copy; 2015 - 2022</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&title=《计算机组成原理复习》 — Xav1er Blog&pic=https://xav1erw.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&title=《计算机组成原理复习》 — Xav1er Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《计算机组成原理复习》 — Xav1er Blog&url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/&via=https://xav1erw.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://xav1erw.github.io/2022/06/20/Review/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/" alt="微信分享二维码">
</div>




  <script src='/js/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'default'});
    }
  </script>

    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '离开了哟！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)回来啦！';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
