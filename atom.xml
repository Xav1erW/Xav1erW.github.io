<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xav1er Blog</title>
  
  
  <link href="https://xav1erw.github.io/atom.xml" rel="self"/>
  
  <link href="https://xav1erw.github.io/"/>
  <updated>2022-06-20T15:00:09.914Z</updated>
  <id>https://xav1erw.github.io/</id>
  
  <author>
    <name>Xav1er</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理复习</title>
    <link href="https://xav1erw.github.io/2022/06/20/Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://xav1erw.github.io/2022/06/20/Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-06-20T15:00:09.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理复习">计算机组成原理复习</h1><h2 id="计算机系统概论">计算机系统概论</h2><h3 id="数字计算机与模拟计算机">数字计算机与模拟计算机</h3><table><thead><tr class="header"><th>比较内容</th><th>电子数字计算机</th><th>电子模拟计算机</th></tr></thead><tbody><tr class="odd"><td>数据表示方式</td><td>0，1</td><td>电压</td></tr><tr class="even"><td>计算方式</td><td>数字技术</td><td>电压组合或测量值</td></tr><tr class="odd"><td>控制方式</td><td>程序控制</td><td>盘上连线</td></tr><tr class="even"><td>精度</td><td>高</td><td>低</td></tr><tr class="odd"><td>数据存储量</td><td>大</td><td>小</td></tr><tr class="even"><td>逻辑判断能力</td><td>强</td><td>无</td></tr></tbody></table><h3 id="冯诺依曼机">冯诺依曼机</h3><ul><li><p>由运算器、存储器、控制器、输入设备和输出设备五个部分组成；</p></li><li><p>存储器以二进制形式存储指令和数据；</p></li><li><p>指令和数据放在同一个存储器；</p></li><li><p>指令由操作码和地址码组成；</p></li><li><p>存储程序并按地址顺序执行；</p></li><li><p>冯·诺依曼机的核心设计思想，机器自动化工作 的关键；</p></li><li><p>以运算器为中心。</p></li></ul><h4 id="控制器">控制器</h4><p>工作周期：取指周期，执行周期</p><ul><li>数据字：该字代表要处理的数据；</li><li>指令字：该字为一条指令；</li><li>指令流：取指周期中，从内存读出的信息流；</li><li>数据流：执行周期中，从内存读出的信息流。</li></ul><p><strong>区分数据和指令</strong>：取指周期拿出来的是指令，执行周期拿出来的是数据。</p><h2 id="运算方法和运算器">运算方法和运算器</h2><h3 id="定点数">定点数</h3><p>假设用n+1位保存一个定点数</p><p>纯小数：</p><ul><li>有符号：<span class="math inline">\(x = x_sx_{-1}\cdots x_{-n}\)</span> 范围 <span class="math inline">\(0 \leq |x| \leq 1-2^{-n}\)</span></li><li>无符号：<span class="math inline">\(x = x_{-1}x_{-2}\cdots x_{-n-1}\)</span> 范围 <span class="math inline">\(0\leq x \leq 1-2^{-n-1}\)</span></li></ul><p>纯整数：</p><ul><li>有符号：范围 <span class="math inline">\(|x|\leq 2^{n}-1\)</span></li><li>无符号：范围 <span class="math inline">\(0 \leq x \leq 2^{n+1}-1\)</span></li></ul><h4 id="原码">原码</h4><h5 id="定点小数">定点小数</h5><p><span class="math display">\[[x]_原 = \left\{\begin{align}&amp;x \quad &amp;1 &gt; x \geq 0\\&amp;1-x = 1+|x| \quad &amp;0 \geq x &gt;-1\end{align}\right.\]</span></p><h5 id="定点整数">定点整数</h5><p><span class="math display">\[[x]_原 = \left\{\begin{align}&amp;x \quad &amp;2^n &gt; x \geq 0\\&amp;2^n-x = 2^n+|x| \quad &amp;0 \geq x &gt;-2^n\end{align}\right.\]</span></p><p><strong>特点</strong>：0有两种表示方法</p><p><strong>整体范围</strong>：</p><ul><li>小数： <span class="math inline">\(-1 &lt; x &lt; 1\)</span></li><li>整数： <span class="math inline">\(-2^n &lt; x &lt; 2^n\)</span></li></ul><h4 id="补码">补码</h4><h5 id="定点小数-1">定点小数</h5><p><span class="math display">\[[x]_补 = \left\{\begin{align}&amp;x \quad &amp;1 &gt; x \geq 0\\&amp;2+x = 2-|x| \quad &amp;0 \geq x \geq-1\end{align}\right.\]</span></p><h5 id="定点整数-1">定点整数</h5><p><span class="math display">\[[x]_补 = \left\{\begin{align}&amp;x \quad &amp;2^n &gt; x \geq 0\\&amp;2^{n+1}+x = 2^{n+1}-|x| \quad &amp;0 \geq x \geq -2^n\end{align}\right.\]</span></p><p>0有唯一表示方法</p><p>补码的补码就是原码</p><p>除2可以直接通过右移</p><p>最小值是 <span class="math inline">\(100000\cdots\)</span></p><h5 id="原码求补码">原码求补码</h5><blockquote><ul><li>方法1：除符号位各位取反加一</li><li>方法2：从最低位开始，遇到的第一个1以前的各位保持不变，之后各位取反。</li></ul></blockquote><h5 id="相反数的补码">相反数的补码</h5><p>已知 [x]<sub>补</sub>求[-x]<sub>补</sub></p><blockquote><p>连符号位一起各位求反，末位加1。</p></blockquote><h3 id="移码">移码</h3><p>把真值平移<span class="math inline">\(2^n\)</span> 个单位<br /><span class="math display">\[[x]_移 = 2^n+x\]</span><br />与补码符号位相反</p><ul><li>可以比较直观地判断两个数据的大小</li><li>表示浮点数阶码时，容易判断是否下溢；</li></ul><table><colgroup><col style="width: 62%" /><col style="width: 16%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th>真值 x(十进制)</th><th>真值 x(二进制)</th><th>[x]原</th><th>[x]反</th><th>[x]补</th><th>[x]移</th></tr></thead><tbody><tr class="odd"><td>–127</td><td>–0 1 1 1 1 1 1 1</td><td><strong>1</strong> 1 1 1 1 1 1 1</td><td><strong>1</strong> 0 0 0 0 0 0 0</td><td><strong>1</strong> 0 0 0 0 0 0 1</td><td><strong>0</strong> 0 0 0 0 0 0 1</td></tr><tr class="even"><td>–1</td><td>–0 0 0 0 0 0 0 1</td><td><strong>1</strong> 0 0 0 0 0 0 1</td><td><strong>1</strong> 1 1 1 1 1 1 0</td><td><strong>1</strong> 1 1 1 1 1 1 1</td><td><strong>0</strong> 1 1 1 1 1 1 1</td></tr><tr class="odd"><td>0</td><td>0 0 0 0 0 0 0 0</td><td><strong>1</strong> 0 0 0 0 0 0 0</td><td><strong>0</strong> 0 0 0 0 0 0 0</td><td><strong>1</strong> 1 1 1 1 1 1 1</td><td><strong>0</strong> 0 0 0 0 0 0 0</td></tr><tr class="even"><td>+1</td><td>+ 0 0 0 0 0 0 0 1</td><td><strong>0</strong> 0 0 0 0 0 0 1</td><td><strong>0</strong> 0 0 0 0 0 0 1</td><td><strong>0</strong> 0 0 0 0 0 0 1</td><td><strong>1</strong> 0 0 0 0 0 0 1</td></tr><tr class="odd"><td>+127</td><td>+ 0 1 1 1 1 1 1 1</td><td><strong>0</strong> 1 1 1 1 1 1 1</td><td><strong>0</strong> 1 1 1 1 1 1 1</td><td><strong>0</strong> 1 1 1 1 1 1 1</td><td><strong>1</strong> 1 1 1 1 1 1 1</td></tr></tbody></table><h3 id="浮点数">浮点数</h3><p><span class="math display">\[N = R^e \times M\]</span></p><ul><li>M尾数，纯小数</li><li>R基数，默认是2</li><li>e阶码，指定小数点位置</li></ul><h4 id="规格化">规格化</h4><p>保证表示唯一</p><p><strong>要求</strong>： <span class="math inline">\(1/R \leq M &lt; 1\)</span></p><ul><li>尾数向左移n位(小数点右移)，同时阶码减n；</li><li>尾数向右移n位(小数点左移)，同时阶码加n。</li></ul><p>尾数用原码表示时：尾数数值最高数值位为1； 尾数用补码表示时：尾数最高数值位和尾数符号位相反；</p><h4 id="ieee754">IEEE754</h4><p>32位：1位数符，8位阶码（包括符号），23位尾数</p><p>64位：1位数符，11位阶码（包括符号），52位尾数</p><p>尾数原码表示，由于规格化最高位为1，因此隐藏最高位的1.</p><p><strong>32位</strong>阶码为移127码：<span class="math inline">\(E = e+127\)</span> ，真值为<br /><span class="math display">\[N = (-1)^S \times (1.M) \times 2^{E-127}\]</span><br /><strong>64位</strong><br /><span class="math display">\[N = (-1)^S \times (1.M) \times 2^{E-1023}\]</span><br /><strong>特殊值：</strong></p><p>正负零：<span class="math inline">\(E = 0;\ M=0\)</span> 正负由符号决定</p><p>正负无穷： <span class="math inline">\(E = 1111\cdots; \  M = 0\)</span> 正负由符号决定</p><p>真正指数的范围：-126~+127</p><table><thead><tr class="header"><th>符号位S</th><th>阶码E</th><th>尾数M</th><th>数值N</th></tr></thead><tbody><tr class="odd"><td>0/1</td><td>0</td><td>=0</td><td>0</td></tr><tr class="even"><td>0/1</td><td>0</td><td>≠0</td><td><span class="math inline">\((-1)^S\times(0.M)×2^{-126}\)</span></td></tr><tr class="odd"><td>0/1</td><td>1~254</td><td>≠0</td><td><span class="math inline">\((-1)^S\times(1.M)×2^{E-127}\)</span></td></tr><tr class="even"><td>0/1</td><td>255</td><td>≠0</td><td>NaN（非数值）</td></tr><tr class="odd"><td>0/1</td><td>255</td><td>=0</td><td><span class="math inline">\((-1)^S\times \infty\)</span></td></tr></tbody></table><h3 id="运算">运算</h3><h4 id="补码加法">补码加法</h4><p>整数 <span class="math inline">\([x+y] = [x]+[y] (\mod 2^{n+1})\)</span></p><p>小数 <span class="math inline">\([x+y] = [x]+[y] (\mod 2)\)</span></p><h4 id="补码减法">补码减法</h4><p>整数 <span class="math inline">\([x-y] = [x]-[y] = [x]+[-y] (\mod 2^{n+1})\)</span></p><p>小数 <span class="math inline">\([x-y] = [x]-[y] = [x]+[-y] (\mod 2)\)</span></p><blockquote><p><span class="math inline">\([-y]\)</span> 等于 <span class="math inline">\([y]\)</span> 按位取反（包括符号位）再+1</p></blockquote><h4 id="溢出问题">溢出问题</h4><h5 id="直接判别法">直接判别法</h5><ul><li><p>同号补码相加，结果符号位与被加数相反；溢出</p></li><li><p>异号补码相减，结果符号位与被减数相反；溢出</p></li></ul><blockquote><p>硬件实现复杂</p></blockquote><h5 id="变形补码判别法">变形补码判别法</h5><p><strong>变形补码</strong>：也叫模4补码：采用双符号位表示补码</p><table><thead><tr class="header"><th>双符号位</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>00</td><td>正</td></tr><tr class="even"><td>01</td><td>上溢</td></tr><tr class="odd"><td>10</td><td>下溢</td></tr><tr class="even"><td>11</td><td>负</td></tr></tbody></table><blockquote><p>硬件实现简单，只需对结果符号位进行异或</p></blockquote><h5 id="进位判别法">进位判别法</h5><p>判别方法：最高数值位的进位与符号位的进位是否相同；</p><p>溢出标志<br /><span class="math display">\[V = C_f \oplus C_{n-1}\]</span><br />其中 <span class="math inline">\(C_f\)</span> 为符号位进位；<span class="math inline">\(C_{n-1}\)</span> 为数值最高位进位。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201531458.png" alt="image-20220620153117043" title="">                </div>                <div class="image-caption">image-20220620153117043</div>            </figure><p>加减法电路统一：</p><p>加入控制信号M，M和输入B的每一位为异或关系，当M为1的时候，<span class="math inline">\(B&#39; = \neg B\)</span> ；同时M作为进位输入，完成求-B的补码操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201538497.png" alt="image-20220620153801436" title="">                </div>                <div class="image-caption">image-20220620153801436</div>            </figure><p>多位加法器延迟时间<br /><span class="math display">\[t_a = n\cdot 2T+9T = (2n+9)T\]</span><br />如果不考虑溢出就为<br /><span class="math display">\[t_a= [2(n-1)+9]T\]</span></p><h3 id="定点乘法">定点乘法</h3><p>分析手算乘法步骤</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201542880.png" alt="image-20220620154257830" title="">                </div>                <div class="image-caption">image-20220620154257830</div>            </figure><blockquote><p>乘法 = 加法+位移</p></blockquote><h4 id="原码并行乘法">原码并行乘法</h4><p><span class="math display">\[a = \sum_{i=1}^{m-1} a_i 2^i \qquad b = \sum_{j=0}^{n-1}b_j2^j\]</span></p><p>相乘得到<br /><span class="math display">\[p = ab =\left(\sum_{i=1}^{m-1} a_i 2^i\right) \left(\sum_{j=0}^{n-1}b_j2^j\right) = \sum_{i=1}^{m-1}\sum_{j=0}^{n-1}(a_ib_j)2^{i+j}\]</span><br /><span class="math inline">\(A_i\cdot b_j\)</span>部分乘积项（位积）叫做一个被加数。<span class="math inline">\(M\times N\)</span>个被加数用与门并行产生(a AND b)</p><p>时间<br /><span class="math display">\[t_m = (8n-4)T\]</span></p><h5 id="阵列乘法器">阵列乘法器</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201551771.png" alt="image-20220620155108703" title="">                </div>                <div class="image-caption">image-20220620155108703</div>            </figure><h5 id="有符号乘法">有符号乘法</h5><p><span class="math display">\[A \cdot B = (a_n \oplus b_n) (a_{n-1}\cdots a_0 \times b_{n-1}\cdots b_0)\]</span></p><p>使用3个求补器，分别用对应的符号位控制：</p><ul><li>2个算前求补器：将两个操作数真值绝对值送入运算器；</li><li>1个算后求补器：乘积为负时把结果变成带符号数；</li></ul><p>两相反数的补码特征： 自右向左，第一个“1”的右侧所有数据位，均相同； 左侧所有数据位，均相反。</p><p>对2求补器电路逻辑：采用按位扫描技术来执行求补操作；E为控制信号线，可由数据a的符号位来控制；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201556033.png" alt="image-20220620155610968" title="">                </div>                <div class="image-caption">image-20220620155610968</div>            </figure><p>乘法器结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201557607.png" alt="image-20220620155745544" title="">                </div>                <div class="image-caption">image-20220620155745544</div>            </figure><h3 id="定点除法">定点除法</h3><p>可控加法/减法(CAS)单元：用于加减交替法的除法器中；由控制端P选择运算类型：P=0，作加法运算；P=1，作减法运算</p><p>四个输入：</p><ul><li>被加/减数Ai</li><li>减数Bi</li><li>低 位进/借位Ci</li><li>控制端P</li></ul><p>四个输出：</p><ul><li>加/减数Bi</li><li>当位和/差Si</li><li>向高位的进/借位Ci+1</li><li>控制端P</li></ul><p>除法器结构：（被除数6位，除数3位）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201602310.png" alt="image-20220620160215240" title="">                </div>                <div class="image-caption">image-20220620160215240</div>            </figure><p>执行时间<br /><span class="math display">\[t_d = 3(n+1)^2T\]</span></p><blockquote><p>在加减交替的除法阵列中，每一行所执行的操作究竟是加法还是减法，取决于前一行输出的符号与被除数的符号是否一致。当出现不够减时，部分余数相对于被除数来说要改变符号。这时应该产生一个商位“0”，除数首先沿对角线右移，然后加到下一行的部分余数上。当部分余数不改变它的符号时，即产生商位“1”，下一行的操作应该是减法。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201609372.png" alt="image-20220620160943308" title="">                </div>                <div class="image-caption">image-20220620160943308</div>            </figure><h3 id="浮点数加减运算">浮点数加减运算</h3><p>步骤：</p><ul><li>零操作数检查 <em>一个操作数为0，则不必运算，节省运算时间</em></li><li>两操作数对阶 <em>使小数点位置对齐，为加减运算做准备</em></li><li>尾数相加减 <em>以双符号位的补码形式进行加减法操作</em></li><li>结果的规格化</li><li>结果的舍入处理</li><li>结果的溢出判断</li></ul><h4 id="对阶">对阶</h4><p>以较大的阶码为标准，调整阶码较小的数据；</p><ul><li>求阶差<span class="math inline">\(\Delta E ＝ E_X－E_Y\)</span></li><li>调整阶码较小的数据<ul><li>若<span class="math inline">\(\Delta E &gt;0\)</span>，则MY右移<span class="math inline">\(\Delta E\)</span>位，结果的阶码为<span class="math inline">\(E_X\)</span></li><li>若<span class="math inline">\(\Delta E &lt;0\)</span>，则MX右移<span class="math inline">\(|\Delta E|\)</span>位，结果的阶码为<span class="math inline">\(E_Y\)</span></li></ul></li></ul><h4 id="结果的规格化处理">结果的规格化处理</h4><p>两尾数加减的结果有两种情况:</p><ul><li>尾数溢出：两符号位为01或10，则<strong>右规</strong> ；尾数右移1位，阶码加1</li><li>尾数为非规格化数据，则<strong>左规</strong> ；尾数左移1位，阶码减１，直至数值位最高位与符号位相反。</li></ul><h4 id="结果的舍入处理">结果的舍入处理</h4><p>在对阶或右规操作时，会使加数或结果的尾数低若干位移出， 影响精度，常用两种舍入处理方法：</p><ul><li><p>方法1：0舍1入法</p><blockquote><p>保留右移时的移出位，若最高位为１，则尾数加１；否则舍去；</p><p>特点：精度较高，但需要记录所有的移出位。</p></blockquote></li><li><p>方法2：恒置1法</p><blockquote><p>若之前步骤有右移操作，则直接将结果的最低位置1;</p><p>特点：精度较0舍1入法较低，但应用简单。</p></blockquote></li></ul><h4 id="结果的溢出判断">结果的溢出判断</h4><ul><li>尾数溢出<ul><li>在规格化处理时，通过完成右规完成；</li></ul></li><li>阶码溢出<ul><li>上溢(结果绝对值太大)——置上溢标志，结束；</li><li>下溢(结果绝对值太小)——置机器零；</li><li>正常——运算结束；</li></ul></li></ul><h3 id="浮点乘除法运算">浮点乘除法运算</h3><p>浮点数乘除运算的步骤</p><ul><li>0操作数检查；</li><li>阶码加/减操作；</li><li>尾数乘/除操作；</li><li>结果规格化、舍入和溢出处理；</li></ul><h2 id="内部存储器">内部存储器</h2><ul><li><p>存储容量：存储单元个数×存储字长</p></li><li><p>存储速度：</p><ul><li>存取时间(访问时间)：从启动一次访问操作到完成该操作为止所经历的时间；以ns为单位，存取时间又分读出时间、写入时间两种。</li><li>存取周期：存储器<strong>连续启动两次独立的访问操作</strong>所需的最小间隔时间。以ns为单位，<strong>存取周期=存取时间+复原时间</strong></li><li>存储器带宽：每秒从存储器进出信息的最大数量；单位为位/秒或者字节/秒。</li></ul></li></ul><blockquote><p>只读存储器又分为掩膜 ROM、一次可编程 ROM(PROM)和可擦除PROM(EPROM)，后者又分为紫外线擦除EPROM(UV-EPROM)、电擦除EPROM(EEPROM或 E2PROM)和闪速(Flash)只读存储器。</p></blockquote><blockquote><p>当一个存储字的字长高于八位时，就存在一个存储字内部的多字节的排列顺序问题，其排列方式称为<strong>端模式</strong>。<strong>大端</strong>(big-endian)模式将一个字的高有效字节放在内存的低地址端，低有效字节放在内存的高地址端，而<strong>小端</strong>(little-endian)模式则将一个字的低有效字节放在内存的低地址端，高有效字节放在内存的高地址端。</p></blockquote><h3 id="sram">SRAM</h3><p>静态RAM（SRAM）：由MOS电路构成的双稳触发器保存二进制信息；</p><ul><li>优点：访问速度快，只要不掉电可以永久保存信息；</li><li>缺点：集成度低，功耗大，价格高；</li></ul><p>动态RAM（DRAM）：由MOS电路中的栅极电容保存二进制信息；</p><ul><li>优点：集成度高，功耗约为SRAM的1/6，价格低；</li><li>缺点：访问速度慢，电容的放电作用会使信息丢失，要长期保存数据必须定期刷新存储单元；主要种类有：SDRAM、DDR SDRAM</li></ul><h4 id="基本的静态存储元阵列">基本的静态存储元阵列</h4><p>芯片封装后，3种外部信号线：</p><ul><li>地址线：2n个单元，对应有n根地址线； 地址信号经过译码电路，产生每个单元的字线选通信号；</li><li>数据线：每个单元m位，对应有m根数据线；</li><li>控制线：读写控制信号：R/W =1，为读操作； R/W=0，为写操作；</li></ul><p>地址：单译码和双译码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201707854.png" alt="image-20220620170725756" title="">                </div>                <div class="image-caption">image-20220620170725756</div>            </figure><h3 id="dram">DRAM</h3><p>存储的信息 1 或 0 则是由电容器上的电荷量来体现——当电容器充满电荷时，代表存储了 1，当电容器放电没有电荷时，代表存储了 0。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201708216.png" alt="image-20220620170816151" title="">                </div>                <div class="image-caption">image-20220620170816151</div>            </figure><p>1M×4 位 DRAM 芯片的外部引脚图。</p><p>与 SRAM 不同的是，图中增加了行地址锁存器和列地址锁存器。由于 DRAM 容量很大，地址线的数目相当多，为减少芯片引脚的数量，将地址分为行、列两部分<strong>分时传送</strong>。存储容量为 1M 字，共需 20 位地址线。此芯片地址引脚的数量为 10 位，先传送行地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器；然后传送列地址码 A10～A19，由列选通信号CAS 打入到列地址锁存器。片选信号的功能也由增加的 RAS 和 CAS 信号实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201709257.png" alt="image-20220620170905183" title="">                </div>                <div class="image-caption">image-20220620170905183</div>            </figure><h4 id="与sram对比">与SRAM对比</h4><ul><li>外部地址引脚比SRAM减少一半：送地址信息时，分行地址和列地址分别传送；</li><li>内部结构：比SRAM复杂<ul><li>刷新电路：用于存储元的信息刷新；</li><li>行、列地址锁存器：用于保存完整的地址信息：行选通信号 （Row Address Strobe）、列选通信号 （Columns Address Strobe）</li></ul></li><li>DRAM的读写周期：与SRAM的读写周期相似，只是地址总线上的信号有所不同；在同一个读写周期内发生变化，分别为行地址、列地址；</li></ul><h4 id="刷新">刷新</h4><p>DRAM 存储位元是基于电容器上的电荷量存储信息的，DRAM 的读操作是破坏性的，读操作会使电容器上的电荷流失，因而读出后必须刷新。而未读写的存储元也要定期刷新，因为电荷量会逐渐泄漏而减少。</p><p>在固定时间内对所有存储单元，通过“读出(不输出)—写入” 的方式恢复信息的操作过程；</p><p>当前主流的 DRAM 器件的刷新间隔时间(<strong>刷新周期</strong>)为 64ms</p><p>自动刷新：刷新计数器的宽度等于行地址锁存器的宽度。由于自动刷新不需要给出列地址，而行地址由片内刷新计数器自动生成，故可利用 CAS 信号先于 RAS 信号有效来启动一次刷新操作，此时地址线上的地址无效。</p><blockquote><p>刷新过程中存储 器不能进行正常的读写访问</p></blockquote><p><strong>集中式刷新策略</strong>中，每一个刷新周期中集中一段时间对 DRAM 的所有行进行刷新。由于刷新操作的优先级高，刷新操作时正常的读/写操作被暂停，数据线输出被封锁。等所有行刷新结束后，又开始正常的读/写周期。由于在刷新的过程中不允许读/写操作，集中式刷新策略存在“死时间”。</p><p><strong>分散式刷新策略</strong>中，每一行的刷新操作被均匀地分配到刷新周期时间内。将每个系统工作周期分为两部分，前半部分用于DRAM读/写/ 保持，后半部分用于刷新存储器的一行；</p><h3 id="存储扩展">存储扩展</h3><h4 id="位扩展">位扩展</h4><p>例如：由1K×4的存储芯片构成1K×8的存储器</p><p>存储芯片与CPU的引脚连接方法：</p><ul><li>地址线：各芯片的地址线<strong>直接</strong>与CPU地址线连接；</li><li>数据线：各芯片的数据线<strong>分别与CPU数据线的不同位连接</strong>；</li><li>片选及读写线：各芯片的片选及读写信号<strong>直接</strong>与CPU的访存及读写信号连接；</li></ul><h4 id="字扩展">字扩展</h4><p>字扩展：每个单元位数不变，总的单元个数增加。例如：用1K×8的存储芯片构成2K×8的存储器</p><p>存储芯片与CPU的引脚连接方法：</p><ul><li>地址线：各芯片的地址线与CPU的<strong>低位地址线直接连接</strong>；</li><li>数据线：各芯片的数据线<strong>直接</strong>与CPU数据线连接；</li><li>读写线：各芯片的读写信号直接与CPU的读写信号连接；</li><li>片选信号：各芯片的片选信号<strong>由CPU的高位地址和访存信号产生</strong>；</li></ul><h4 id="计算字位扩展所需的存储芯片的数目">计算字位扩展所需的存储芯片的数目</h4><p>用L×K的芯片构成M×N的存储系统：所需芯片总数为<br /><span class="math display">\[M/L \times N/K\]</span><br />扩展的时候可以使用74LS138等选择器</p><h3 id="rom">ROM</h3><p>其访问速度比 RAM 稍低，可以按地址随机访问并在线执行程序，因而在计算机中用于储存固件、引导加载程序、监控程序及不变或很少改变的数据。“只读”的意思是在其工作时只能读出，不能写入。</p><ul><li>掩模式ROM<ul><li>定义：数据在芯片制造过程中写入，不能更改；</li><li>优点：可靠性、集成度高，价格便宜；</li><li>缺点：通用性差，不能改写内容；</li></ul></li><li>一次编程ROM（PROM）<ul><li>定义：用户第一次使用时写入确定内容；</li><li>优点：用户可根据需要对ROM编程；</li><li>缺点：只能写入一次，不能更改；</li></ul></li><li>多次编程ROM<ul><li>定义：可用紫外光照射（EPROM）或电擦除（E2PROM） 多次改写其中内容；</li><li>优点：通用性较好，可反复使用；</li></ul></li><li>闪速存储器（Flash Memory）<ul><li>定义：一种高密度、非易失性的读/写半导体存储器，它突破了 传统的存储器体系，改善了现有存储器的特性。</li><li>在EPROM功能基础上，增加了电路的电擦除 和重新编程能力；也叫快擦型存储器。</li></ul></li></ul><h4 id="有关存储器选择">有关存储器选择</h4><p>系统程序区默认为写死的，因此使用ROM，用户程序需要修改因此使用RAM。</p><h4 id="存储器设计的连接要点">存储器设计的连接要点</h4><p>参考<a href="#存储扩展">存储扩展</a></p><ul><li>片选线的连接<ul><li>一般使用CPU的高位地址线的和CPU的访存允许控制信号 线/MREQ，经译码器译码后产生各芯片的片选信号。</li><li>关键点，也是最容易出错的地方。</li></ul></li></ul><h3 id="并行存储器">并行存储器</h3><h4 id="双端口存储器">双端口存储器</h4><p>双端口存储器采用空间并行技术：同一个存储体使用两组相互独立的读写控制线路，可并行操作。</p><p>显卡上的存储器一般都是双端口存储器。</p><p>读写特点</p><ul><li>无冲突读写：访问的存储单元不同，可并行读写存储体；</li><li>有冲突读写：访问同一存储单元，可使用/BUSY信号控制读写优先顺序；</li></ul><h4 id="多模块交叉存储器">多模块交叉存储器</h4><h5 id="顺序方式">顺序方式</h5><p>访问地址按顺序分配给一个模块后，接着又按顺序为下一个模块分配访问地址。这样，存储器的 32个字可由 5 位地址寄存器指示，其中高 2 位选择 4 个模块中的一个，低 3 位选择每个模块中的 8 个字。</p><p>在顺序方式中某个模块进行存取时，其他模块不工作。而某一模块出现故障时，其他模块可以照常工作。另外通过增添模块来扩充存储器容量也比较方便。但顺序方式的缺点是各模块一个接一个<strong>串行工作</strong>，因此存储器的带宽受到了限制。</p><h5 id="交叉方式">交叉方式</h5><p>每个模块的单元地址是 不连续的；连续地址分 布在相邻的不同模块内。</p><blockquote><p>对于数据的成块传送， 各模块可以实现多模块 流水式并行存取；</p></blockquote><p>当存储器寻址时，用地址寄存器的低 2 位选择 4 个模块中的一个，而用高 3 位选择模块中的 8 个字。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201751840.png" alt="image-20220620175154754" title="">                </div>                <div class="image-caption">image-20220620175154754</div>            </figure><h3 id="cache">Cache</h3><p>Cache的作用：</p><ul><li>在CPU和主存之间加一块高速的SRAM（Cache）；</li><li>主存中将要被访问的数据提前送到Cache中；</li><li>CPU访存时，先访问Cache，若没有再进行数据调度。</li></ul><p>使用Cache的依据：在一段时间内，CPU所执行的程序和访问的数据大部分都在 某一段地址范围内，而该段范围外的地址访问很少；（程序访问的局部性原理）</p><p>CPU 与 cache 之间的数据交换是以字为单位，而 cache 与主存之间的数据交换是以块为单位。一个块由若干字组成，是定长的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201802839.png" alt="image-20220620180201780" title="">                </div>                <div class="image-caption">image-20220620180201780</div>            </figure><p>当 CPU 读取内存中一个字时，便发出此字的内存地址到 cache 和主存。此时 cache 控制逻辑依据地址判断此字当前是否在 cache 中：若是，则 <strong>cache 命中</strong>，此字立即传送给 CPU；若非，则 <strong>cache 缺失(未命中)</strong>，用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到cache 中。</p><h4 id="读操作">读操作</h4><p>CPU发出有效的主存地址：</p><ol type="1"><li>经地址变换机构，变换为可能的Cache地址；</li><li>查找块表，判断所要访问的信息是否在Cache中；<ol type="1"><li>若在，则CPU直接读取Cache获取数据；</li><li>若不在，则CPU访问主存，并判断Cache是否已满；<ol type="1"><li>若Cache未满，将该数据所在块从主存中调入Cache；</li><li>若Cache已满，使用某种替换机制，使用当前数据块替换 掉Cache中的某些块。</li></ol></li></ol></li></ol><h4 id="写操作">写操作</h4><p>CPU发出有效的主存地址：</p><ol type="1"><li>经地址变换机构，变换为可能的Cache地址；</li><li>找对应的相联存储器，判断所要访问的信息是否在Cache中；<ol type="1"><li>若不在，则使CPU直接写主存数据；</li><li>若在，则使用某种写策略将数据写入Cache。</li></ol></li></ol><h4 id="cache的命中率">cache的命中率</h4><p>命中率 = 访问信息在Cache中的次数 / 访问总次数</p><p>影响命中率的主要因素</p><ul><li>Cache 容量：<ul><li>过小时，局部信息装不完，命中率低。</li><li>过大时，对提高效率不明显，且成本高。</li></ul></li><li>Cache中块的大小： 一般用一个主存周期所能调出的单元数（字或字节）作 为一个块大小。</li></ul><p>Cache/主存系统的平均访问时间<span class="math inline">\(t_a\)</span>为<br /><span class="math display">\[t_a = ht_c + (1-h)t_m\]</span></p><ul><li><p>tc ——命中时的cache访问时间</p></li><li><p>tm ——未命中时的主存访问时间</p></li><li><p>h ——命中率</p></li></ul><p>设 <span class="math inline">\(r = t_m/t_c\)</span> 访问效率为<br /><span class="math display">\[e = \frac{t_c}{t_a} = \frac{t_c}{ht_c + (1-h)t_m} = \frac{1}{h + (1-h)r} = \frac{1}{r + (1-r)h}\]</span><br />平均访问时间同样也可以计算为<br /><span class="math display">\[t_a = t_c/e\]</span></p><h4 id="地址映射">地址映射</h4><p>cache 与主存的数据交换是以块为单位。为了把主存块放到 cache 中，必须应用某种方法把主存地址定位到 cache 中，称为<strong>地址映射</strong>。“映射”一词的物理含义是确定位置的对应关系，并用硬件来实现。这样当 CPU 访问存储器时，它所给出的一个字的内存地址会自动变换成 cache 的地址，即 <strong>cache 地址变换</strong>。</p><h5 id="全相联映射方式">全相联映射方式</h5><p>cache 的数据块大小称为行，用 <span class="math inline">\(L_i\)</span> 表示，其中 <span class="math inline">\(i=0,1,2,…,m–1\)</span>，共有 $m=2^r $行。主存的数据块大小称为块，用 $B_j <span class="math inline">\(表示，其中\)</span> j=0,1,2,…,n–1$，共有 $n=2^s $块。行与块是等长的，每个块(行)由 <span class="math inline">\(k=2^w\)</span> 个连续的字组成，字是 CPU 每次访问存储器时可存取的最小单位。</p><p>主存中的任意字块可调进cache的任一行中；</p><p>当主存的数据块调入Cache中时，该块的块号（主存标记） 保存于调入Cache行的对应标记位（即块表中）</p><blockquote><p>块表的大小应为<span class="math inline">\(2^c×m\)</span>位，c为行地址长度，m为块地址长度</p></blockquote><p>在全相联映射中，将主存中一个块的地址(块号)与块的内容(字)一起存于 cache 的行<br />中，其中块地址存于 cache 行的标记(tag)部分中。这种带全部块地址一起保存的方法，可使主存的一个块直接复制到 cache 中的任意一行上，非常灵活。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201817114.png" alt="image-20220620181718030" title="">                </div>                <div class="image-caption">image-20220620181718030</div>            </figure><p>特点：</p><ul><li>优点：<ul><li>灵活性好(最理想)，Cache中只要有空行，就可以调入所需要的主存数据块；</li></ul></li><li>缺点：<ul><li>成本高：标记位为m位，使cache标记容量变大；</li><li>速度太慢：访问cache时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在cache中；</li></ul></li><li>一般较少使用。</li></ul><h5 id="直接映射">直接映射</h5><p>主存中的每一块数据只能调入Cache的特定行中；</p><p>地址映射函数为<br /><span class="math display">\[i = j\mod 2^c\]</span><br /><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201844159.png" alt="image-20220620184431080" title="">                </div>                <div class="image-caption">image-20220620184431080</div>            </figure></p><p>地址格式：</p><ul><li>主存共<span class="math inline">\(2^n\)</span>个单元，分成<span class="math inline">\(2^m\)</span>个块，每块单元数为<span class="math inline">\(2^b\)</span>个：主存地址为m+b位；</li><li>Cache空间分成<span class="math inline">\(2^c\)</span>行，每行大小也应为<span class="math inline">\(2^b\)</span>单元：Cache地址为c+b位；</li><li>直接映射中主存块与Cache行的关系：<ul><li>主存的<span class="math inline">\((2^m/ 2^c)= 2^{m-c}\)</span>个块映射于Cache的同一行；</li><li>主存地址中的c位决定该主存块对应的Cache行，m-c位为 主存标记；</li><li>块表的大小应为<span class="math inline">\(2^c×(m-c)\)</span>位；</li><li>主存的地址格式为：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201849021.png" alt="image-20220620184925945" title="">                </div>                <div class="image-caption">image-20220620184925945</div>            </figure></li></ul></li></ul><p><strong>特点</strong>：</p><ul><li>一个主存块只能调入cache的一个特定行中 。</li><li>优点：该映射函数实现简单，查找速度快；<ul><li>主存地址的中间c位即为Cache的行地址；</li><li>在对应的块表中使用高t位地址进行比较，决定是否命中；</li></ul></li><li>缺点：灵活性差；<ul><li>主存的2t个字块只能对应唯一的Cache字块，即使Cache 中别的字块空着也不能占用。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201857079.png" alt="image-20220620185701996" title="">                </div>                <div class="image-caption">image-20220620185701996</div>            </figure><p>若CPU发出的主存地址为0000 01 001；</p><ol type="1"><li>先取高4位地址（主存标记0000）送往比较器的一端；</li><li>再用中间的2位地址（Cache行号01），在块表中取出该单 元中保存的主存标记送往比较器的另一端；</li><li>若二者相等，则为命中，直接访问Cache的第01行中地址 为001的单元，读取数据；</li><li>若二者不相等，则为未命中；</li></ol><h5 id="组相联映射">组相联映射</h5><p>组相联映射是直接映射和全相联映射的一种折中方案。</p><p>映射关系：将Cache中的行等分为若干组，主存中的每一块只能映射 到Cache的特定组中，但是可调入到该组的任一行中；</p><p>组间为直接映射，组内为全相联映射。</p><p>设Cache共u组，每组v行，则映射函数如下<br /><span class="math display">\[q = j \mod u\]</span><br />当Cache的一组包含r行时，通常称为<strong>r路组相联映射</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201950729.png" alt="image-20220620195000670" title="">                </div>                <div class="image-caption">image-20220620195000670</div>            </figure><p>特点：</p><ul><li>灵活性：比直接映射灵活（主存可映射到组内任一块）；</li><li>快速性：比全相联比较次数少，只需组内全部比较；</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206201959278.png" alt="image-20220620195959199" title="">                </div>                <div class="image-caption">image-20220620195959199</div>            </figure><h4 id="替换策略">替换策略：</h4><h5 id="最不经常使用lfu算法">最不经常使用(LFU)算法</h5><ul><li>替换原则：将<strong>一段时间内</strong>被访问次数最少的那行数据替换出去；</li><li>使用方法<ul><li>每行设置一个计数器，从0开始计数;</li><li><strong>每访问一次， 被访行的计数器增1;</strong></li><li>当需要替换时，将计数值最小的行换出，同时将这些行的计数器都清零。</li></ul></li><li>特点：这种算法将计数周期限定在对这些特定行两次替换之间的间 隔时间内，<strong>不能严格反映近期访问情况。</strong></li></ul><h5 id="近期最少使用lru算法">近期最少使用(LRU)算法</h5><ul><li>替换原则：将近期内长久未被访问过的行替换出去。</li><li>使用方法<ul><li>每行也设置一个计数器;</li><li>每访问一次，被访行的计数器清零，其它各行计数值1；</li><li>当需要替换时，将计数值最大的行换出。</li></ul></li><li>特点：这种算法保护了刚拷贝到cache中的新数据行，使Cache的使用率较高。</li></ul><h5 id="随机替换算法">随机替换算法</h5><ul><li>替换原则：从特定的行位置中随机地选取一行换出。</li><li>特点：在硬件上容易实现，且速度也比前两种策略快。但降低了命中率和cache工作效率。</li></ul><h4 id="写策略">写策略</h4><h5 id="写回式">写回式</h5><ul><li>写入策略：只修改cache的内容，而不立即写入主存；只有当此行被换出时才写回主存。</li><li>优点：减少了访问主存的次数</li><li>缺点：存在Cache与主存不一致性的隐患。</li></ul><blockquote><p>实现该方法时，cache行必须配置一个修改位，以反映此行是否被CPU修改过。</p></blockquote><h5 id="全写式">全写式</h5><blockquote><p>这种策略又称写透式</p></blockquote><ul><li>写入策略：cache与主存同时发生写修改，因而较好地维护了cache与主存的内容的一致性。cache中每行无需设置一个修改位以及相应的判断逻辑。</li><li>缺点：降低了cache的功效。</li></ul><h5 id="写一次法">写一次法</h5><ul><li>写入策略：<ul><li>基于写回法，并结合全写法的写策略;</li><li>写命中与写未命中的处理方法与写回法基本相同， 只是第一次写命中时要同时写入主存。</li></ul></li></ul><blockquote><p>第一次写命中时，启动一个主存的写周期，其目的是 使其它Cache可以及时更新或废止该块内容，这便于 维护系统全部cache的一致性</p></blockquote><h2 id="指令系统">指令系统</h2><h3 id="操作码">操作码</h3><p>两地址指令的分类：</p><ul><li>SS（存储器-存储器）</li><li>RR 这种指令结构常用于<strong>算术逻辑运算</strong>类指令</li><li>RS</li></ul><h4 id="操作码扩展">操作码扩展</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202106203.png" alt="image-20220620210635102" title="">                </div>                <div class="image-caption">image-20220620210635102</div>            </figure><h4 id="指令字长度">指令字长度</h4><p><strong>机器字长</strong>：运算器一次能处理的二进制数的位数。机器指令的长度直接决定着CPU运算的精度和直接寻址能 力的大小；</p><p><strong>指令字长</strong>：一个指令字中包含二进制代码的位数； ¡指令字长由操作码长度、操作数长度和个数共同决定。指令有半<strong>字长、单字长、双字长、多字长</strong>等不同的长度类型；指令系统可分为等长指令字结构、变长指令字结构两种。</p><h3 id="寻址方式">寻址方式</h3><h4 id="指令寻址">指令寻址</h4><ul><li>顺序寻址方式：当程序按顺序执行时的指令寻址方式；<ul><li>必须用程序计数器记录所要执行指令的存放单元地址；</li><li>一般做顺序加1的操作；</li><li>程序计数器又称指令指针寄存器；</li></ul></li><li>跳跃寻址方式：当程序转移执行时的指令寻址方式；程序计数器的内容由本条指令给出，而不是顺序改变。</li></ul><h4 id="操作数的寻址方式">操作数的寻址方式</h4><ul><li>隐含寻址</li><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>偏移寻址</li><li>堆栈寻址；</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202111661.png" alt="image-20220620211148581" title="">                </div>                <div class="image-caption">image-20220620211148581</div>            </figure><h5 id="偏移寻址">偏移寻址</h5><p><strong>相对寻址</strong>： 隐含引用的专用寄存器是程序计数器(PC)，即 EA=A+(PC)，它是当前 PC<br />的内容加上指令地址字段中 A 的值。一般来说，地址字段的值在这种操作下被看成 2 的补码数的值。因此有效地址是对当前指令地址的一个上下范围的偏移，它基于程序的局部性原理。使用相对寻址可节省指令中的地址位数，也便于程序在内存中成块搬动。<br /><strong>基址寻址</strong> ：被引用的专用寄存器含有一个存储器地址，地址字段含有一个相对于该地<br />址的偏移量(通常是无符号整数)。寄存器的引用可以是显式的，也可以是隐式的。基址寻址也利用了存储器访问的局部性原理。后面讲到的段寻址方式中，就采用了段基址寄存器，它提供了一个范围很大的存储空间。</p><p><strong>变址寻址</strong> ：地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，<strong>与基址寻址刚好相反</strong>。但是二者有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如，主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时值 A 存入指令地址字段，再用一个变址寄存器(初始化为 0)。每次操作之后，变址寄存器内容增 1。此时，EA=A+(R)，R←(R+1)。</p><blockquote><p>基址寻址把 <strong>寄存器</strong>中的作为基础，指令中给出偏移量</p><p>变址寻址把 <strong>指令中的地址</strong>作为基础，寄存器给出偏移量</p></blockquote><h5 id="段寻址">段寻址</h5><p>微型机中采用了段寻址方式，例如，它们可以给定一个20 位的地址，从而有 220=1MB 存储空间的直接寻址能力。为此将整个 1MB 空间存储器按照最大长度 64KB 划分成若干段。在寻址一个内存具体单元时，由一个基地址再加上某些寄存器提供的 16 位偏移量来形成实际的 20 位物理地址。这个基地址就是 CPU 中的段寄存器。在形成 20 位物理地址时，段寄存器中的 16 位数会自动左移 4 位，然后与 16 位偏移量相加，即可形成所需的内存地址。<strong>这种寻址方式的实质还是基址寻址。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202117888.png" alt="image-20220620211746817" title="">                </div>                <div class="image-caption">image-20220620211746817</div>            </figure><h2 id="中央处理器">中央处理器</h2><h3 id="cpu的功能">CPU的功能</h3><p>CPU（中央处理器）：控制程序按设定方式执行；</p><p>CPU的主要功能：</p><ul><li>指令控制：控制程序的执行顺序；<em>顺序寻址、跳跃寻址</em></li><li>操作控制：产生和发送各操作信号；<em>对指令操作码译码后产生控制信号</em></li><li>时间控制：控制指令、或操作的实施时间；<em>维持各类操作的时序关系</em></li><li>数据加工：对数据进行算术逻辑运算；<em>由ALU完成具体的运算</em></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202123291.png" alt="image-20220620212327176" title="">                </div>                <div class="image-caption">image-20220620212327176</div>            </figure><h3 id="指令周期">指令周期</h3><ul><li>指令周期：CPU从内存中取出一条指令，并执行的时间总和</li><li>CPU周期：又称机器周期，一般为从内存读取一条指令字的最短时间；一个CPU周期可以完成CPU的一个基本操作。</li><li>时钟周期：也叫节拍脉冲或T周期，是计算机处理操作的基本时间单位。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202126098.png" alt="image-20220620212637023" title="">                </div>                <div class="image-caption">image-20220620212637023</div>            </figure><blockquote><p>不同指令的指令周期所包含的 时钟周期个数不一定相同。</p></blockquote><h4 id="mov-r1-r2">MOV R1, R2</h4><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202130085.png" alt="image-20220620212746096" style="zoom:100%" align="center"/></p><h4 id="lad-r1-addr">LAD R1, ADDR</h4><p>从数据存储器单元取出数据装入通用寄存器R</p><p>三个CPU周期：</p><ol type="1"><li><p>取指周期</p></li><li><p>间址周期：从IR的地址码字段获 取操作数地址；（或 者通过计算获得EA）</p></li><li><p>执行周期：访存获取操作数送入 通用寄存器R1；</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202133732.png" alt="image-20220620213324658" title="">                </div>                <div class="image-caption">image-20220620213324658</div>            </figure><h4 id="add-r1-r2">ADD R1 , R2</h4><p>取指周期（略）</p><p>执行周期</p><ul><li>从寄存器R1、R2中取出数据，作为源操作数；</li><li>将两数据送往ALU，并使ALU进行加运算；</li><li>结果保存到R1中</li></ul><h4 id="sto-r2-r3">STO R2 , (R3)</h4><p>STO指令是RS型指令，需要3个CPU周期。存数指令 R2 -&gt; [R3]</p><p>取指周期（略）</p><p>间址周期：根据R3中的地址寻址所要访问的存储单元；</p><p>执行周期：将寄存器R2中的数据送入指定的存储单元；</p><h4 id="jmp">JMP</h4><p>两个周期：</p><p>取指</p><p>执行：直接给PC赋值</p><h3 id="微指令和微程序">微指令和微程序</h3><ul><li><p>控制存储器（CM）：存放实现全部指令系统的微指令；由只读存储器构成，要求速度快，读出周期短。</p></li><li><p>微指令寄存器：存放由控制存储器读出的一条微指令信息；</p><ul><li>微地址寄存器：决定将要访问的下一条微指令的地址；</li><li>微命令寄存器：保存一条微指令的操作控制字段和判别测试字 段的信息。</li></ul></li><li><p>地址转移逻辑</p></li></ul><p>顺序控制部分的P1、P2为判别测试标志；</p><ul><li>若为00，则顺序寻址微指令；</li><li>若为01、10，则跳跃寻址微指令。</li></ul><p>微操作在执行部件中是最基本的操作。由于数据通路的结构关系，微操作可分为相容<br />性和相斥性两种。所谓<strong>相容性的微操作</strong>，是指在同时或同一个 CPU 周期内可以并行执行的微操作。所谓<strong>相斥性的微操作</strong>，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。</p><h5 id="cpu周期与微指令周期关系">CPU周期与微指令周期关系</h5><p><strong>微指令周期</strong>：读出微指令的时间加上执行该条微指令的时间；串行方式的微程序控制器中的概念；</p><p>一般来讲，一个微指令周期时间设计得<strong>恰好和CPU 周期时间相等</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202228777.png" alt="image-20220620222820709" title="">                </div>                <div class="image-caption">image-20220620222820709</div>            </figure><h5 id="机器指令与微指令的关系">机器指令与微指令的关系</h5><p>一条机器指令对应一个微程序，一个微程序由若干条微指 令序列组成的；一条机器指令所完成的操作划分成若干条微指令来完成， 由微指令进行解释和执行。</p><p>从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者与内存有关，后者与控制存储器有关。</p><p>每一个CPU周期对应一条微指令。</p><h4 id="微程序设计技术">微程序设计技术</h4><h5 id="微命令编码">微命令编码</h5><p><strong>直接表示法</strong>：操作控制字段中的每一位代表一个微命令；</p><ul><li><p>优点：简单直观，其输出可直接用于控制，执行速度快；</p></li><li><p>缺点：微指令字较长，因而使控制存储器容量较大。</p></li></ul><p><strong>编码表示法</strong>：将微指令操作控制字段划分为若干个子字段；每个子字段的所有微命令进行统一编码；每个子字段的不同编码表示不同的微命令；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202232668.png" alt="image-20220620223233590" title="">                </div>                <div class="image-caption">image-20220620223233590</div>            </figure><ul><li>遵循原则：<ul><li>把<strong>相斥的微命令</strong>划分在同一个字段中，相容的微命令划分 在不同字段；</li><li>字段的划分应与数据通路结构相适应；</li><li>每个子字段应留出一个<strong>空操作</strong>状态；</li><li>每个子字段所定义的微命令不宜太多；</li></ul></li><li>优点：可大大缩短微指令字长；</li><li>缺点：需要微命令译码，故微程序的执行速度稍稍减慢。</li></ul><h5 id="微地址的形成方法">微地址的形成方法</h5><p><strong>计数器方式</strong>：同CPU中程序计数器产生机器指令地址的方法相类似。</p><ul><li>优点：微指令的顺序控制字段较短，微地址产生机构简单。</li><li>缺点：多路并行转移功能较弱，速度较慢，灵活性较差。</li></ul><p><strong>多路转移方式</strong>：可根据“判别测试”标志和“状态条件”信息选定某 一个候选微地址的方法。</p><ul><li>特点：能以较短的顺序控制字段配合，实现多路并行转移， 灵活性好，速度较快；</li><li>但转移地址逻辑需要用组合逻辑方法设计</li></ul><h5 id="微指令格式">微指令格式</h5><p><strong>水平型微指令</strong>：一次能定义并执行多个并行操作微命令的微指令；一般由操作控制字段、判别测试字段、下地址字段三部分构成；根据控制字段编码方式的不同，可分为全水平型、字段译码法水平型、直接和译码相混合的水平型三种微指令。</p><p><strong>垂直型微指令</strong>：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能；垂直型微指令的结构类似于机器指令的结构。在一条微指令中只有 1～2 个微操作命令，每条微指令的功能简单，因此，实现一条机器指令的微程序要比水平型微指令编写的微程序长得多。它是采用较长的微程序结构去换取较短的微指令结构。</p><ol type="1"><li>水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。</li><li>水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。</li><li>由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反，微指令字较短而微程序长。</li><li>水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。</li></ol><h3 id="流水cpu">流水CPU</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202246529.png" alt="image-20220620224644452" title="">                </div>                <div class="image-caption">image-20220620224644452</div>            </figure><h2 id="总线系统">总线系统</h2><p>构成计算机系统的互联机构，是系统内各功能部件之间进行 信息传送的公共通路。</p><p><strong>总线宽度</strong>：一次总线操作中，最多可传送的数据位数。</p><p><strong>总线周期</strong>：一次总线操作所需要的最小间隔时间。总线周期与总线的时钟频率成反比，即T=1/f</p><p><strong>总线带宽</strong>：单位时间内通过总线的数据位数，总线的数据传输率；单位一般为MB/s。</p><p><strong>单总线结构</strong>：系统内的所有部件均由系统总线连接；</p><p><strong>双总线结构</strong>：系统内的所有部件均由系统总线连接；在CPU和主存之间再 专门设置了一组高速的存储总线。</p><p><strong>三总线结构</strong>：系统总线负责连接CPU、主存、I/O通道；存储总线负责连接 CPU与主存；I/O总线负责连接各I/O适配器。</p><h3 id="总线的仲裁">总线的仲裁</h3><ul><li><p>集中式：由中央仲裁器决定总线使用权的归属。</p></li><li><p>分布式：多个仲裁器竞争使用总线。</p></li></ul><h4 id="集中式">集中式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202248599.png" alt="image-20220620224812519" title="">                </div>                <div class="image-caption">image-20220620224812519</div>            </figure><blockquote><p>计数器定时查询方式：设备的优先权由计数值决定，计数值为0时同链式查询方式；</p><p>每次计数可以从“0”开始，也可以从中止点开始。如果从“0”开始，各设备的优先次序与链式查询法相同，优先级的顺序是固定的。如果从中止点开始，则每个设备使用总线的优先级相等。计数器的初值也可用程序来设置，这就可以方便地改变优先次序，显然这种灵活性是以增加线数为代价的。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202255904.png" alt="image-20220620225551800" title="">                </div>                <div class="image-caption">image-20220620225551800</div>            </figure><h4 id="分布式">分布式</h4><p>分布式仲裁不需要中央仲裁器，由分布在各部件中的多个仲裁 器竞争使用总线。</p><p>每个潜在的主模块都有自己的仲裁器和唯一的仲裁号，通过仲 裁总线上仲裁号的比较，决定可占用总线的部件。</p><ol type="1"><li>某部件有总线请求时，将其仲裁号发送到共享仲裁总线上；</li><li>每个仲裁器将仲裁总线上得到的号与自己的号进行比较；</li><li>如果仲裁总线上的号大，则它的总线请求不予响应，并撤 消它的仲裁号；</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ol><p>分布式仲裁是以<strong>优先级仲裁策略</strong>为基础。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206202252578.png" alt="image-20220620225243489" title="">                </div>                <div class="image-caption">image-20220620225243489</div>            </figure><h2 id="外围设备">外围设备</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成原理复习&quot;&gt;计算机组成原理复习&lt;/h1&gt;
&lt;h2 id=&quot;计算机系统概论&quot;&gt;计算机系统概论&lt;/h2&gt;
&lt;h3 id=&quot;数字计算机与模拟计算机&quot;&gt;数字计算机与模拟计算机&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header</summary>
      
    
    
    
    <category term="Review" scheme="https://xav1erw.github.io/categories/Review/"/>
    
    
    <category term="课内" scheme="https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"/>
    
    <category term="复习" scheme="https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="计算机组成原理" scheme="https://xav1erw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机复习</title>
    <link href="https://xav1erw.github.io/2022/06/18/Notes/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/"/>
    <id>https://xav1erw.github.io/2022/06/18/Notes/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-17T16:00:00.000Z</published>
    <updated>2022-06-20T12:25:44.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="形式语言与自动机">形式语言与自动机</h1><h2 id="字母表">字母表</h2><p><strong>注意区分<span class="math inline">\(\epsilon\)</span> 和 <span class="math inline">\(\varnothing\)</span></strong></p><ul><li><span class="math inline">\(\epsilon\)</span> 是一个长度为0的句子</li><li><span class="math inline">\(\varnothing\)</span> 是空集</li></ul><h2 id="乔姆斯基文法体系">乔姆斯基文法体系</h2><h3 id="型文法">0型文法</h3><p>即文法 $ G(V,T,P,S)$ 称为 <strong>短语结构文法(PSG)</strong></p><h3 id="型文法-1">1型文法</h3><p>对于0型文法G有<br /><span class="math display">\[\forall \alpha \to \beta \in P, \quad |\beta| \geq |\alpha|\]</span><br />称为1型文法或 <strong>上下文有关文法(CSG)</strong></p><h3 id="型文法-2">2型文法</h3><p>对于1型文法G有<br /><span class="math display">\[\forall \alpha \to \beta \in P, \quad |\beta| \geq |\alpha| 并且 \alpha \in V\]</span><br />称为2型文法或 <strong>上下文无关文法(CFG)</strong></p><h3 id="型文法-3">3型文法</h3><p>对于2型文法G<br /><span class="math display">\[\forall \alpha \to \beta \in P, \quad \alpha \to \beta 具有形式\\A \to w\\A \to wA\]</span><br />其中 <span class="math inline">\(w \in T^+\)</span></p><p>称为3型文法或 <strong>正则文法 (RG)</strong></p><table><thead><tr class="header"><th>文法类型</th><th><span class="math inline">\(\forall \alpha \to \beta\)</span></th></tr></thead><tbody><tr class="odd"><td>0（短语结构）</td><td>无限制</td></tr><tr class="even"><td>1（上下文有关）</td><td><span class="math inline">\(|\beta| \geq |\alpha|\)</span></td></tr><tr class="odd"><td>2（上下文无关）</td><td><span class="math inline">\(|\beta|\geq |\alpha|\)</span> 并且 <span class="math inline">\(\alpha \in V\)</span></td></tr><tr class="even"><td>3（正则）</td><td><span class="math inline">\(A \to w\\A \to wA\)</span></td></tr></tbody></table><p>从上到下是包含关系</p><h3 id="正则文法最简形式">正则文法最简形式</h3><p><strong>定理</strong>：L是RL<strong>充要条件</strong>是存在文法，其产生式要么形如 <span class="math inline">\(A \to a\)</span> 要么形如 <span class="math inline">\(A \to aB\)</span></p><h3 id="线性文法">线性文法</h3><p><span class="math inline">\(\forall \alpha \to \beta \in P\)</span> 均具有形式</p><ul><li><span class="math inline">\(A \to w\)</span></li><li><span class="math inline">\(A \to wBx\)</span></li></ul><p>其中 <span class="math inline">\(w, x \in T^*\)</span></p><h4 id="右线性文法">右线性文法</h4><p><span class="math inline">\(\forall \alpha \to \beta \in P\)</span> 均具有形式</p><ul><li><span class="math inline">\(A \to w\)</span></li><li><span class="math inline">\(A \to wB\)</span></li></ul><p>其中 <span class="math inline">\(w, x \in T^*\)</span></p><h4 id="左线性文法">左线性文法</h4><p><span class="math inline">\(\forall \alpha \to \beta \in P\)</span> 均具有形式</p><ul><li><span class="math inline">\(A \to w\)</span></li><li><span class="math inline">\(A \to Bw\)</span></li></ul><p>其中 <span class="math inline">\(w, x \in T^*\)</span></p><p><strong>定理</strong>：左线性文法充要条件：其产生式要么形如 <span class="math inline">\(A \to a\)</span> 要么形如 <span class="math inline">\(A \to Ba\)</span></p><p><strong>定理</strong>：左线性文法与右线性文法等价</p><h2 id="语言识别">语言识别</h2><h3 id="回溯">回溯</h3><p>遍历所有的推导</p><h3 id="有限自动机">有限自动机</h3><p><span class="math display">\[M = (Q, \Sigma, \delta, q_0, F)\]</span></p><ul><li><span class="math inline">\(Q\)</span> 状态集合</li><li><span class="math inline">\(\Sigma\)</span> 输入字母表</li><li><span class="math inline">\(\delta\)</span> 状态转移函数</li><li><span class="math inline">\(q_0\)</span> 开始状态</li><li><span class="math inline">\(F\)</span> 终止状态</li></ul><h4 id="dfa">DFA</h4><p>每个输入字符有确定的状态转移</p><h4 id="即时描述">即时描述</h4><p><span class="math inline">\(\delta (q_0, x) = q\)</span> 那么 <span class="math inline">\(xqy\)</span> 称为一个即时描述，表示 xy是正在处理的字符串，当前到达状态q，M正准备处理y的第一个字符</p><p><span class="math inline">\(\alpha \vdash_M^n \beta\)</span> 表示从即时描述 <span class="math inline">\(\alpha\)</span> 移动n次到达即时描述 <span class="math inline">\(\beta\)</span> ，上标同样可以使用 *、+</p><p>如果 xqay 是M的一个即时描述，且 <span class="math inline">\(\delta (q, a) = p\)</span> 那么 <span class="math inline">\(xqay \vdash_M xapy\)</span></p><p><strong>定义</strong> ：状态的字符串集合：从初始状态能引导状态机到达状态的字符串集合<br /><span class="math display">\[\text{set}(q) = \{x|x\in \Sigma^*, \delta(q_0, x)=q\}\]</span><br /><strong>定义</strong>：<span class="math inline">\(R_M\)</span> 等价关系：<br /><span class="math display">\[\forall x,y \in \Sigma^*, xR_My \Leftrightarrow \exists q \in Q \quad s.t.\\x \in \text{set}(q) \quad \text{and} \quad y \in \text{set}(q)\]</span><br />上述是等价关系，能够将 <span class="math inline">\(\Sigma^*\)</span> 分成不多于 <span class="math inline">\(|Q|\)</span> 个等价类</p><h4 id="nfa">NFA</h4><p>与DFA等价</p><h5 id="从nfa到dfa">从NFA到DFA</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/FLA/NFAtoDFA.png" alt="NFAtoDFA" title="">                </div>                <div class="image-caption">NFAtoDFA</div>            </figure><h4 id="带空移动的nfa">带空移动的NFA</h4><p><span class="math inline">\(\epsilon\)</span> 闭包<br /><span class="math display">\[\epsilon-\text{CLOSURE}(q) = \{p|从q到p有一条标记为\epsilon的路径\}\]</span><br />对状态集合同样也有闭包概念<br /><span class="math display">\[\hat \delta (q,a) = \hat \delta (a,\epsilon a) = \epsilon-\text{CLOSURE}(P)\\P =\{p|\exists r \in \hat\delta(q, \epsilon) s.t. p \in \delta(r,a\} \\= \bigcup_{r\in \hat \delta(q,\epsilon)} \delta(r,a)\]</span></p><h5 id="由带空移动的nfa构造等价nfa">由带空移动的NFA构造等价NFA</h5><p>取NFA <span class="math inline">\(M_2 = (Q, \Sigma, \delta_2, q_0, F_2)\)</span> 其中<br /><span class="math display">\[F_2 \left\{\begin{align}&amp;F \cup \{q_0\} \quad &amp;\text{如果} F\cap \epsilon-\text{CLOSURE}(q_0)\neq 0\\&amp;F \quad &amp;\text{如果} F\cap \epsilon-\text{CLOSURE}(q_0)= 0\end{align} \right.\]</span><br />对于 <span class="math inline">\(\forall (q,a) \in Q \times \Sigma\)</span> 使 <span class="math inline">\(\delta_2(q,a) = \hat \delta_1(q,a)\)</span></p><p>其实就是，写出 <span class="math inline">\(\hat \delta\)</span> 的表，把空移动去除，按照表中集合连线，再按照上述步骤判断一下终止状态都有哪些。</p><p>如</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/React/202206190945317.png" alt="image-20220619094518260" /></p><p><span class="math inline">\(q_0\)</span> 的 0移动有 <span class="math inline">\(q_0, q_1, q_2\)</span> ，那么局部的NFA有</p><pre class="mermaid">graph LRq0((q0))q1((q1))q2((q2))q0 --0-->q0q0 --0-->q1q0 --0-->q2</pre><p>其余状态同理。</p><h3 id="fa接收的语言是rg">FA接收的语言是RG</h3><h4 id="dfa转rg">DFA转RG</h4><p>构造方法<br /><span class="math display">\[P = \{q \to ap | \delta (q,a) = p\} \cup \{q \to a | \delta (q,a) = p\in F\}\]</span><br />例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191048403.png" alt="image-20220619104853348" title="">                </div>                <div class="image-caption">image-20220619104853348</div>            </figure><h4 id="rg转dfa">RG转DFA</h4><p>每个变量看成一个状态，</p><ul><li>如果派生为 <span class="math inline">\(A \to wB\)</span> 的形式，那么DFA就为 <code>A --w--&gt; B</code> 的形式。</li><li>如果派生为 <span class="math inline">\(A \to w\)</span> 的形式，那么DFA就为 <code>A --w--&gt; Z</code> 的形式，其中Z代表终止状态。</li></ul><p>可以用下式表示<br /><span class="math display">\[\delta(A,a) = \left\{\begin{align}&amp;\{B|A \to aB \in P\}\cup\{Z\} \quad &amp;\text{if } A \to a \in P \\ \\&amp;\{B|A \to aB \in P\} \quad &amp;\text{if } A \to a \notin P\end{align}\right.\]</span><br /><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191141847.png" alt="image-20220619114104790" title="">                </div>                <div class="image-caption">image-20220619114104790</div>            </figure></p><h4 id="左线性文法转dfa">左线性文法转DFA</h4><p>左线性文法 <span class="math inline">\(G(V,T,P,S)\)</span> 无空串</p><ul><li>FA为 <span class="math inline">\(M=(V\cup\{Z\}, T,\delta,Z,\{S\})\)</span> 此处Z为初始状态</li><li><span class="math inline">\(\forall (a,B) \in T\times V\)</span></li><li>如果 <span class="math inline">\(A \to Ba \in P\)</span> 那么 <span class="math inline">\(\delta (B,a)=A\)</span></li><li>如果 <span class="math inline">\(A \to a \in P\)</span> 那么 <span class="math inline">\(\delta (Z,a)=A\)</span></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191145068.png" alt="image-20220619114529002" title="">                </div>                <div class="image-caption">image-20220619114529002</div>            </figure><h4 id="dfa转左线性文法">DFA转左线性文法</h4><ol type="1"><li><p>预处理DFA</p><ol type="1"><li>删除陷阱状态</li><li>图中添加Z作为文法开始变量</li><li>复制一条原本到达终止状态的弧，使其从原本状态出发到Z</li></ol></li><li><p>构造文法</p><ul><li><p>如果 <span class="math inline">\(\delta (A,a) = B\)</span> 则有 <span class="math inline">\(B \to Aa\)</span></p></li><li><p>如果 <span class="math inline">\(\delta (A,a) = B\)</span> 且A是开始状态，则有 <span class="math inline">\(B \to a\)</span></p></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191205319.png" alt="image-20220619120539270" style="width:45%" /><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191206613.png" alt="image-20220619120602560" style="width:45%" /></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191207097.png" alt="image-20220619120727042" title="">                </div>                <div class="image-caption">image-20220619120727042</div>            </figure><h3 id="fa的变形">FA的变形</h3><h4 id="dfa-1">2DFA</h4><p><span class="math display">\[M = (Q,\Sigma,\delta,q_0,F)\]</span></p><ul><li><span class="math inline">\(\delta: \ Q\times \Sigma \to Q \times \{L,R,S\}\)</span></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191213677.png" alt="image-20220619121354622" title="">                </div>                <div class="image-caption">image-20220619121354622</div>            </figure><h4 id="nfa-1">2NFA</h4><p>类似2DFA</p><h4 id="moore机">Moore机</h4><p>六元组<br /><span class="math display">\[M = (Q,\Sigma,\Delta,\delta,\lambda,q_0)\]</span><br /><span class="math inline">\(\Delta\)</span> 输出字母表</p><p><span class="math inline">\(\lambda: Q \to \Delta\)</span> 输出函数 ，状态 <span class="math inline">\(q\)</span> 输出对应字符</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191243264.png" alt="image-20220619124315215" title="">                </div>                <div class="image-caption">image-20220619124315215</div>            </figure><h4 id="mealy机">Mealy机</h4><p>六元组<br /><span class="math display">\[M = (Q,\Sigma,\Delta,\delta,\lambda,q_0)\]</span><br /><span class="math inline">\(\Delta\)</span> 输出字母表</p><p><span class="math inline">\(\lambda: Q\times \Sigma \to \Delta\)</span> 输出函数 ，<span class="math inline">\(\lambda(q,a)=d\)</span> 表示在状态 q 读入字符 a，输出字符d</p><p><strong>Moore机和Mealy机等价</strong></p><h2 id="正则表达式">正则表达式</h2><p><strong>优先级</strong>：闭包&gt;乘&gt;加</p><h3 id="运算律">运算律</h3><ul><li>结合律</li><li>分配律：<span class="math inline">\(r(s+t) = rs+rt\)</span></li><li>交换律：<span class="math inline">\(r+s = s+r\)</span></li><li>幂等律：<span class="math inline">\(r+r=r\)</span></li><li>零元素与空元素<ul><li><span class="math inline">\(r+\varnothing = r\)</span></li><li><span class="math inline">\(r\epsilon = \epsilon r = r\)</span></li><li><span class="math inline">\(r\varnothing = \varnothing r = \varnothing\)</span>关于这点和上一点，看二者的<a href="#字母表">定义</a> ，结合<strong>分配律</strong>理解</li><li><span class="math inline">\(L(\varnothing) = \varnothing\)</span></li><li><span class="math inline">\(L(\epsilon) = \{\epsilon\}\)</span></li><li><span class="math inline">\(L(\varnothing^*) = \{\epsilon\}\)</span> 因为 <span class="math inline">\(L(\varnothing^0) = \{\epsilon\}\)</span></li><li><span class="math inline">\(L((r^*s^*)^* = L((r+s)^*)\)</span></li></ul></li></ul><h3 id="re与fa等价">RE与FA等价</h3><h4 id="re转nfa">RE转NFA</h4><p>基本的例子</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191548762.png" alt="image-20220619154853677" title="">                </div>                <div class="image-caption">image-20220619154853677</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191553081.png" alt="image-20220619155341031" title="">                </div>                <div class="image-caption">image-20220619155341031</div>            </figure><p>根据以上例子，给出 <span class="math inline">\(r=r_1+r_2;\quad r=r_1r_2;\quad r=r_1^*\)</span> 构造方法</p><h5 id="加法构造">加法构造</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191556754.png" alt="image-20220619155635676" title="">                </div>                <div class="image-caption">image-20220619155635676</div>            </figure><h5 id="乘法构造">乘法构造</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191557813.png" alt="image-20220619155707763" title="">                </div>                <div class="image-caption">image-20220619155707763</div>            </figure><h5 id="闭包构造">闭包构造</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191557317.png" alt="image-20220619155737263" title="">                </div>                <div class="image-caption">image-20220619155737263</div>            </figure><h4 id="dfa转re">DFA转RE</h4><ol type="1"><li><p>预处理</p><ul><li>给开始和终止加上X、Y状态</li><li>去掉所有不可达状态</li></ul></li><li><p>对图操作</p><ul><li><p>并弧：将从q到p的标记为<span class="math inline">\(r_1,r_2,\cdots,r_g\)</span>并⾏弧用从q到p的、标记为<span class="math inline">\(r_1+r_2+\cdots +r_g\)</span> 的弧取代这g个并⾏弧。</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191607805.png" alt="image-20220619160721744" /></p></li><li><p>去状态1：如果从q到p有⼀条标记为<span class="math inline">\(r_1\)</span>的弧，从p到t有⼀条标记为<span class="math inline">\(r_2\)</span>的弧，不存在从状态p到状态p的弧，将状态p和与之关联的这两条弧去掉，用⼀条从q到t 的标记为<span class="math inline">\(r_1r_2\)</span>的弧代替。</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191608932.png" alt="image-20220619160844877" /></p></li><li><p>去状态2：如果从q到p有⼀条标记为<span class="math inline">\(r_1\)</span>的弧，从p到t有⼀条标记为<span class="math inline">\(r_2\)</span>的弧，从状态p 到状态p标记为<span class="math inline">\(r_3\)</span>的弧，将状态p和与之关联的这三条弧去掉，用⼀条从q 到t的标记为<span class="math inline">\(r_1r_3^ *r_2\)</span>的弧代替。</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191609127.png" alt="image-20220619160959081" /></p></li><li><p>去状态3：如果图中只有三个状态，⽽且不存在从标记为X的状态到达标记为Y的状 态的路，则将除标记为X的状态和标记为Y的状态之外的第3个状态及其相 关的弧全部删除。</p></li></ul></li><li><p>从标记为X的状态到标记为Y的状态的弧的标记为所求的正则表 达式。如果此弧不存在，则所求的正则表达式为 <span class="math inline">\(\varnothing\)</span></p></li></ol><h3 id="正则语言表示方法转化">正则语言表示方法转化</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191613389.png" alt="image-20220619161300327" title="">                </div>                <div class="image-caption">image-20220619161300327</div>            </figure><h2 id="正则语言的性质">正则语言的性质</h2><h3 id="泵引理">泵引理</h3><p>由于DFA中状态个数是有穷的， 所以在处理⼀个<strong>足够长</strong>的句⼦的过程中，<strong>必定会重复</strong>地经过某⼀个状态。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191616831.png" alt="image-20220619161639784" title="">                </div>                <div class="image-caption">image-20220619161639784</div>            </figure><p>设L为RL，那么对应有DFA <span class="math inline">\(M = (Q,\Sigma,\delta,q_0,F)\)</span> 假设有N个状态。</p><p>那么 <span class="math inline">\(z = a_1a_2\cdots a_m\quad m \geq N\)</span> 由于一共N个状态，状态序列 <span class="math inline">\(q_0,q_2,\cdots ,q_N\)</span> 有N+1状态，会有两个状态重复。不妨假设 <span class="math inline">\(q_k = q_j\)</span><br />$$<br />(q_0, a_1a_2a_k)=q_k \<br />(q_k, a_{k+1}a_j)=q_j = q_k \<br />(q_j, a_{j+1}a_m)=q_m \</p><p>因此i \<br />(q_k, (a_{k+1}a_j)^i) = q_j=q_k<br />$$<br />因此可以理解为 <span class="math inline">\(a_1\cdots a_k (a_{k+1}\cdots a_j)^i a_{j+1}\cdots a_m \in L(M)\)</span></p><p>设<br /><span class="math display">\[u= a_1a_2\cdots a_k\\v = a_{k+1}\cdots a_j\\w = a_{j+1}\cdots a_m\]</span><br />那么 <span class="math inline">\(uv^iw \in L\)</span> 由于 <span class="math inline">\(k&lt;j\leq N\)</span> 所以 <span class="math inline">\(|uv| = j \leq N, \ |v|\geq 1\)</span></p><p><strong>引理(泵引理)</strong></p><p>L为RL，则存在<strong>仅依赖于L的正整数N</strong> <span class="math inline">\(\forall z \in L\)</span> 如果 <span class="math inline">\(|z|\geq N\)</span> 则存在u、v、w满足</p><ol type="1"><li>z = uvw</li><li><span class="math inline">\(|uv| \leq N\)</span></li><li><span class="math inline">\(|v|\geq 1\)</span></li><li>对于任意整数 <span class="math inline">\(i \geq 0 \quad uv^iw \in L\)</span></li><li>N不大于接受L的最小DFA的状态数。</li></ol><h4 id="利用泵引理证明一个语言不是rl">利用泵引理证明一个语言不是RL</h4><ol type="1"><li>首先假设该语言是RL，则其应该满足泵引理，选任意的N.</li><li>找到一个语言中的句子<span class="math inline">\(z=L(|z|\geq N)\)</span>.</li><li>任选满足z=uvw，其中<span class="math inline">\(|v| \geq 1\)</span>，且<span class="math inline">\(|uv|\leq N\)</span>的u,v,w</li><li>找到一个<span class="math inline">\(i\geq 0\)</span>，证明使<span class="math inline">\(uv^iw\notin L\)</span>.</li><li>推出矛盾说明该语言不满足泵引理，从而说明该语言不是RL。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191632886.png" alt="image-20220619163240817" title="">                </div>                <div class="image-caption">image-20220619163240817</div>            </figure><blockquote><p>泵引理用来证明一个语言不是RL</p><p>不能用泵引理去证明一个语言是RL</p></blockquote><h3 id="正则语言的封闭性">正则语言的封闭性</h3><p><strong>定理</strong>：RL在并、乘积、闭包运算下是封闭的</p><p><strong>定理</strong>：RL 在补运算下是封闭的。</p><p>DFA <span class="math inline">\(M&#39;=(Q,\Sigma, \delta, q_0, Q-F)\)</span> 对应着正则语言的补集</p><p><strong>定理</strong>：RL 在交运算下是封闭的。</p><h4 id="正则代换">正则代换</h4><p><span class="math inline">\(\Sigma\quad \Delta\)</span> 是两个字母表，映射 <span class="math inline">\(f:\Sigma \to 2^{\Delta^*}\)</span> 称为是代换，如果 <span class="math inline">\(\forall a \in \Sigma \quad f(a)\)</span>是<span class="math inline">\(\Delta\)</span> 上的RL，那么称为正则代换。</p><p>先将f定义域扩展到 <span class="math inline">\(\Sigma^*\)</span> 上</p><ul><li><span class="math inline">\(f(\epsilon) = \{\epsilon\}\)</span></li><li><span class="math inline">\(f(xa) = f(x)f(a)\)</span></li></ul><p>再扩展到 <span class="math inline">\(2^{\Sigma^*}\)</span></p><ul><li><span class="math inline">\(f(L) = \bigcup_{x\in L} f(x)\)</span></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191645184.png" alt="image-20220619164535126" title="">                </div>                <div class="image-caption">image-20220619164535126</div>            </figure><p><strong>定理</strong>：L是Σ上的RL，那么正则代换f满足 <span class="math inline">\(f(L)\)</span> 也是RL</p><p><strong>定义</strong>：对于字母表<span class="math inline">\(\Sigma\)</span>和<span class="math inline">\(\Delta\)</span>，<span class="math inline">\(f: \Sigma \to \Delta^*\)</span> 如果 <span class="math inline">\(\forall x, y \in\Sigma^*\quad f(xy) = f(x)f(y)\)</span> 则称为<strong>同态映射</strong></p><p>L的<strong>同态像</strong>：<br /><span class="math display">\[\forall L \subset \Sigma^*\quad f(L) = \bigcup_{x\in L}f(x)\]</span><br /><span class="math inline">\(\forall w \in \Delta^* \quad \forall L \subset \Delta^*\)</span> 同态原像是一个集合</p><p><strong>定义</strong>：商 <span class="math inline">\(L_1/L_2 = \{x|\exists y \in L_2 \quad s.t.\  xy\in L_1\}\)</span></p><p>主要用来考虑句子后缀</p><h3 id="myhill-nerode">Myhill-Nerode</h3><p><a href="#即时描述">等价关系</a> 同样表述为 <span class="math inline">\(xR_M y \Leftrightarrow \delta(q_0,x) = \delta(q_0,y)\)</span></p><p><strong>语言确定的等价关系</strong>： <span class="math inline">\(xR_L y \Leftrightarrow (\forall x \in \Sigma^*, xz\in L \Leftrightarrow yz \in L)\)</span>；x,y后不管接什么串z，要么都是L的句子，要么都不是</p><p><strong>右不变的等价关系</strong>：如果 <span class="math inline">\(x\ R\ y\)</span> 那么 <span class="math inline">\(\forall z \in \Sigma^*\)</span> 必有 <span class="math inline">\(xz\ R\ yz\)</span></p><p><span class="math inline">\(R_M\)</span> 和 <span class="math inline">\(R_L\)</span> 都是右不变的。</p><p>R是 <span class="math inline">\(\Sigma^*\)</span> 上的等价关系， <span class="math inline">\(\Sigma^* / R\)</span> 表示等价关系分开的集合数量，称为<span class="math inline">\(R\)</span>关于 <span class="math inline">\(\Sigma^*\)</span> 的<strong>指数</strong></p><p><span class="math inline">\(R_M\)</span> 的分割更细致，因此称 <span class="math inline">\(R_M\)</span> 是 <span class="math inline">\(R_{L(M)}\)</span> 的<strong>加细</strong></p><p><strong>Myhill-Nerode定理</strong>：如下三个命题等价</p><ol type="1"><li>L是RL</li><li>L是<span class="math inline">\(\Sigma^*\)</span> 上某一个具有有穷指数的右不变等价关系R的某些等价类的并</li><li><span class="math inline">\(R_L\)</span> 具有有穷指数</li></ol><p>证明该语言不是RL最方便的方法就是证明<span class="math inline">\(R_L\)</span>的指数是无穷的</p><p><strong>例</strong>：</p><p>证明 <span class="math inline">\(\{0^n1^n|n\geq 0\}\)</span>不是RL</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191718040.png" alt="image-20220619171833963" title="">                </div>                <div class="image-caption">image-20220619171833963</div>            </figure><h3 id="极小化dfa">极小化DFA</h3><p>算法步骤</p><ol type="1"><li><p>标记终止状态和其余非终止状态可区分</p></li><li><p>从第一个状态开始迭代标注它与其余状态是否可区分：</p><ol type="1"><li>如果状态对转移后的关联状态对可区分，那么该状态对可区分</li><li>如果关联状态对没有被标注，那么将该关联状态加入关联状态链表（基于一个双向链表实现）（对状态列表的保存有冗余设计，每次向前添加时，实际会新建链表，即如果有一链表 q0-&gt;q3-&gt;q2，那么 q3-&gt;q2，q0-&gt;q3-&gt;q2都会被保存）</li><li>如果迭代到的状态对被标记，那么寻找以该状态对开始关联列表，并将关联列表上之后的状态都标记上</li></ol></li><li><p>上述步骤会标记完成可区分状态表，接着合并不可区分状态，将不可区分的状态放入一个集合中：</p><ol type="1"><li>遍历可区分状态表中的所有状态对</li><li>如果两状态对不可区分，那么遍历最终的不可区分状态<ol type="1"><li>如果能在不可区分状态里找到某个集合包含状态对中的一个元素，那么将该状态对元素添加到这个集合中</li><li>如果不能，则从状态对元素新建一个集合，加入不可区分状态中。</li></ol></li></ol></li><li><p>对于上述得到的新的可区分状态（每个可区分状态可能包含多个不可区分状态），逐个遍历其中的不可区分状态，得到最终针对新可区分状态的状态转移函数。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191722743.png" alt="image-20220619172230661" title="">                </div>                <div class="image-caption">image-20220619172230661</div>            </figure><h3 id="正则语言判定定理">正则语言判定定理</h3><p><strong>定理</strong>：DFA <span class="math inline">\(M=(Q, \Sigma, \delta, q_0,F)\)</span> 对应语言为<strong>非空</strong>的充要条件是：<br /><span class="math display">\[\exists x \in \Sigma^*, \quad |x|&lt;|Q|, \delta(q_0,x) \in F\]</span><br /><strong>定理</strong>：DFA <span class="math inline">\(M=(Q, \Sigma, \delta, q_0,F)\)</span> 对应语言为<strong>无穷</strong>的充要条件是：<br /><span class="math display">\[\exists x \in \Sigma^*, \quad |Q|\leq|x|&lt;2|Q|, \delta(q_0,x) \in F\]</span><br /><em>可以联系<a href="#泵引理">泵引理</a></em></p><p><strong>定理</strong>：设DFA <span class="math inline">\(M_1=(Q_1,\Sigma,\delta_1,q_{01},F_1)\)</span>，DFA <span class="math inline">\(M_2=(Q_2,\Sigma,\delta_2,q_{02},F_2)\)</span>，则存在判定M1与M2是否<strong>等价</strong>的算法。</p><p><strong>定理</strong>：设L是字母表上的RL，对任意<span class="math inline">\(x\in \Sigma^*\)</span>，存在判定x是不是L的句子的算法。</p><h2 id="上下文无关语言">上下文无关语言</h2><p><a href="#2型文法">定义</a></p><p>派生树：</p><p>顶点的<strong>顺序</strong>：V1，V2是派生树T的两个不同顶点，如果存在顶点v，v至少有两个儿子，使得v，是v的较左儿子的后代，v，是v的较右儿子的后代，则顶点v在顶点v2的左边，顶点v2在顶点v，的右边。</p><p>派生树的<strong>结果</strong>：</p><ul><li>派生树T的所有叶子顶点从左到右依次标记为X1，X2，…，X，则称符号串X1X2.…Xn是T的结果。</li><li>句型a的派生树：“结果为a的派生树”。·派生树的结果可以是句子，也可以是句型</li><li>一个文法可以有多棵派生树，它们可以有不同的结果。</li></ul><p>设CFG <span class="math inline">\(G=(V，T，P，S)\)</span>，<span class="math inline">\(S\Rightarrow^* \alpha\)</span>的充分必要条件为G有一棵结果为$ $的派生树。</p><p>定义：</p><ul><li><strong>最左派生</strong>：<span class="math inline">\(\alpha\)</span>的派生过程中，每一步都是对当前句型的最左变量进行替换</li><li><strong>左句型</strong>：最左派生得到的句型可叫做左句型。</li><li><strong>最右归约</strong>：与最左派生相对的归约叫做最右归约。</li></ul><p>定义：</p><ul><li><strong>最右派生</strong>：<span class="math inline">\(\alpha\)</span>的派生过程中，每一步都是对当前句型的最右变量进行替换</li><li><strong>右句型</strong>：最右派生得到的句型可叫做右句型。</li><li><strong>最左归约</strong>：与最左派生相对的归约叫做最左归约。</li></ul><p>最右派生、右句型、最左归约又称为规范派生、规范句型、规范规约</p><h4 id="二义性">二义性</h4><p>字符串对应两个及以上派生树，则文法有二义性</p><p>如果语言L不存在非二义性文法，则称L是固有二义性的，又称L是先天二义性的。</p><h4 id="无用符号">无用符号</h4><p>能出现字符串的派生过程中的有用，否则无用。</p><h4 id="删除无用符号">删除无用符号</h4><h5 id="删除派生不出终极符号行的变量">删除派生不出终极符号行的变量</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191757253.png" alt="image-20220619175742158" title="">                </div>                <div class="image-caption">image-20220619175742158</div>            </figure><h5 id="删除不出现在任何句型中的语法符号">删除不出现在任何句型中的语法符号</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191759964.png" alt="image-20220619175910894" title="">                </div>                <div class="image-caption">image-20220619175910894</div>            </figure><p>依次使用上述算法(先删派生不出终极符号行的变量，再删不出现在任何句型中的语法符号)就可删除无用符号</p><h4 id="空产生式">空产生式</h4><p>形如 <span class="math inline">\(A\to \epsilon\)</span></p><h5 id="求cfg-g的可空变量集">求CFG G的可空变量集</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191801091.png" alt="image-20220619180121022" title="">                </div>                <div class="image-caption">image-20220619180121022</div>            </figure><h5 id="去除空产生式">去除空产生式</h5><ol type="1"><li>首先求可空变量集U</li><li>构造 <span class="math inline">\(P&#39;\)</span><ul><li><span class="math inline">\(\forall A \to X_1X_2\cdots X_m \in P\)</span> 将 <span class="math inline">\(A\to \alpha_1\alpha_2\cdots \alpha_m\)</span> 放入 <span class="math inline">\(P&#39;\)</span> ， 如果<span class="math inline">\(X_i \in U,\quad \alpha_i = X_i\text{ or }\epsilon\)</span> ；如果 <span class="math inline">\(X_i\notin U\quad \alpha_i = X_i\)</span></li></ul></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191806533.png" alt="image-20220619180650451" title="">                </div>                <div class="image-caption">image-20220619180650451</div>            </figure><h4 id="单一产生式">单一产生式</h4><p>形如 <span class="math inline">\(A \to B\)</span></p><p>消除：用<span class="math inline">\(B\)</span> 的表达式直接代替<span class="math inline">\(A \to B\)</span> 中的B</p><ul><li>如果 <span class="math inline">\(A \to \alpha\)</span> 不是单一产生式，就放入 <span class="math inline">\(P_2\)</span></li><li>如果 <span class="math inline">\(A \to_G^+ B\)</span> 且<span class="math inline">\(B \to \alpha\)</span> 不是 单一产生式，那么 <span class="math inline">\(A \to \alpha\)</span> 放<span class="math inline">\(P_2\)</span></li></ul><h4 id="cfg化简">CFG化简</h4><p>流程</p><ol type="1"><li>删除无用符号；</li><li>删除E-产生式；</li><li>删除单一产生式；</li><li>当删除单一产生式后，文法中再出现新的无用符号时，再次进行删除无用符号。</li></ol><h3 id="cnf-乔姆斯基范式">CNF 乔姆斯基范式</h3><p>形式都为 <span class="math inline">\(A \to BC\)</span> 或 <span class="math inline">\(A \to a\)</span></p><p>不允许有空产生式和单一产生式</p><h4 id="通过cfg构造cnf">通过CFG构造CNF</h4><ol type="1"><li><p>首先将化简后的CFG转化为都为 <span class="math inline">\(A \to B_1B_2\cdots B_n\)</span> 和 <span class="math inline">\(A\to a\)</span> 的形式</p><blockquote><p>对于 <span class="math inline">\(A \to aB\)</span> 这类转化为 <span class="math inline">\(A \to A_aB \quad A_a \to a\)</span></p></blockquote></li><li><p>将形如 <span class="math inline">\(A \to A_1A_2\cdots A_n\)</span> 都替换为<br /><span class="math display">\[A \to A_1B_1 \\B_1 \to A_2B_2\\\cdots\\B_{n-2} \to A_{n-1}A_n\]</span></p></li></ol><h3 id="gnf-格雷巴赫范式">GNF 格雷巴赫范式</h3><p>有如下两种形式</p><ul><li><span class="math inline">\(A\to a\)</span></li><li><span class="math inline">\(A\to a A_1A_2\cdots A_m\)</span></li></ul><p>首先 <span class="math inline">\(A \to \alpha B \beta\)</span> 又 <span class="math inline">\(B \to \gamma_1|\gamma_2|\cdots\)</span> 那么可以将B替换为<span class="math inline">\(\gamma\)</span></p><h4 id="递归">递归</h4><p>如果存在 <span class="math inline">\(A \Rightarrow^n \alpha A \beta\)</span> 则称为递归派生；n&gt;2 称为间接递归；<span class="math inline">\(\alpha = \epsilon\)</span> 称为左递归，反之为右递归</p><p><strong>引理</strong>：对于<br /><span class="math display">\[\left\{\begin{align}A &amp;\to A\alpha_1|A\alpha_2|A\alpha_3\cdots\\A &amp;\to \beta_1|\beta_2|\beta_3|\cdots\end{align}\right.\]</span><br />可以替换为<br /><span class="math display">\[\left\{\begin{align}A &amp;\to \beta_1|\beta_2|\beta_3|\cdots\\A &amp;\to \beta_1B|\beta_2B|\beta_3B|\cdots\\B &amp;\to \alpha_1|\alpha_2|\alpha_3|\cdots\\B &amp;\to \alpha_1B|\alpha_2B|\alpha_3B|\cdots\end{align}\right.\]</span></p><h4 id="cfg转gnf">CFG转GNF</h4><ol type="1"><li><p>首先将产生式化成形式（通过引入变量替换终极符）<br /><span class="math display">\[A \to A_1A_2\ldots A_m\\A\to a A_1A_2\ldots A_{m-1} \\A \to a\]</span></p></li><li><p>将产生式都转化为形式<br /><span class="math display">\[A_i \to A_j \alpha\quad i &lt; j\\A_i \to a \alpha\\B_i \to \alpha\]</span><br /><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191917286.png" alt="image-20220619191745180" /></p><p>当出现j &lt; i 的情况，就用 <span class="math inline">\(A_i\)</span> 的表达式替换，直到出现左递归:</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191922597.png" alt="image-20220619192251491" /><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191923469.png" alt="image-20220619192316374"  /></p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191934334.png" alt="image-20220619193420234" title="">                </div>                <div class="image-caption">image-20220619193420234</div>            </figure><ol start="3" type="1"><li>具有最大下标的A已经满足GNF的要求，将这些产生式带入还不满足要求的<span class="math inline">\(A_2\)</span>产生式，使得<span class="math inline">\(A_2\)</span>产生式都满足GNF的要求；之后递归的带入 <span class="math inline">\(A_1\)</span></li></ol><h2 id="下推自动机">下推自动机</h2><p>CFG都可以化为GNF，最左派生是，句型中变量都以后缀形式出现。</p><p>使用下推自动机识别CFG<br /><span class="math display">\[M = (Q,\Sigma, \Gamma, \delta,q_0,Z_0, F)\]</span></p><ul><li>Q状态集合</li><li><span class="math inline">\(\Sigma\)</span> 输入字母表</li><li><span class="math inline">\(\Gamma\)</span> 栈顶符号表</li><li><span class="math inline">\(Z_0\in \Gamma\)</span> 开始符号，启动时栈内唯一的符号</li><li><span class="math inline">\(q_0\)</span> 开始状态</li><li>F终止状态</li><li><span class="math inline">\(\delta\)</span> 转移函数，<span class="math inline">\(\delta: Q \times (\Sigma\cup \{\epsilon\} \times \Gamma) \to 2^{Q\times \Gamma^*}\)</span></li></ul><p><span class="math display">\[\delta(q,a,Z) = \{(p_1, \gamma_1), (p_2, \gamma_2), \cdots\}\]</span></p><p>表示状态q下，栈顶为Z，读入a，状态可以转移为<span class="math inline">\(q_i\)</span> 并且<strong>弹出Z并将 <span class="math inline">\(\gamma_i\)</span> 从右至左压入栈</strong>，读头移动，准备读入下一个字符。</p><p>特别的如果<span class="math inline">\(a = \epsilon\)</span> 那么读头不移动。</p><p>同样有 <strong>即时描述</strong>：<span class="math inline">\((q,w,\gamma)\)</span> 当前状态q，未处理字符串w，栈内符号串<span class="math inline">\(\gamma\)</span> （最左侧为栈顶）</p><h3 id="接收语言">接收语言</h3><p>两种接受方法：</p><ul><li>转移到特定终态接收 记作<span class="math inline">\(L(M)\)</span></li><li>空栈接收（栈为空时接收）记作<span class="math inline">\(N(M)\)</span></li></ul><h3 id="gnf转pda">GNF转PDA</h3><p>模拟最左派生，对于 <span class="math inline">\(A \to b \alpha\)</span>，就是读入b，压栈<span class="math inline">\(\alpha\)</span><br /><span class="math display">\[\forall A \in V,\ a\in T,\ \gamma \in V^*\\\delta(q,a,A) = \{(q,\gamma)|A\to a\gamma \in P\}\]</span><br />对于含有空串的语言，再加入识别空串的 <span class="math inline">\(\delta_1(q_0,\epsilon, Z) = \{(q_0, \epsilon), (q,S)\}\)</span></p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191953653.png" alt="image-20220619195325566" /></p><p>类似的还可以终态接受</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191954001.png" alt="image-20220619195359916" title="">                </div>                <div class="image-caption">image-20220619195359916</div>            </figure><p>还可以直接<strong>观察语言结构</strong>来设计自动机，常用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206191955898.png" alt="image-20220619195513815" title="">                </div>                <div class="image-caption">image-20220619195513815</div>            </figure><h3 id="终态接受的pda转空栈接受pda">终态接受的PDA转空栈接受PDA</h3><p>状态加入初始状态和清栈状态，栈顶符号加入一个用于放在栈底的符号。</p><p>初始状态空移动转移到原PDA初始状态，并将新加的栈符号连同原PDA栈底符号压入栈底</p><p>之后所有的转移都模拟原PDA，直到原终止状态</p><p>原终止状态转移到请栈状态，开始通过空移动清栈。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192005210.png" alt="image-20220619200515110" title="">                </div>                <div class="image-caption">image-20220619200515110</div>            </figure><h3 id="空栈接受pda转终态接受的pda">空栈接受PDA转终态接受的PDA</h3><p>加入终止状态和标志栈底的元素，等看到栈底元素后就进入终止状态。</p><h3 id="pda转cfg">PDA转CFG</h3><p>使用三元组 <span class="math inline">\([q,A,q_{next}]\)</span> 表示CFG中变量，其中A是栈顶符号。</p><p>对于 <span class="math inline">\(\delta(q,a,A) = (q_1,A_1A_2\cdots A_n)\)</span> 我们不确定处理完<span class="math inline">\(A_1\)</span> 到 <span class="math inline">\(A_n\)</span> 后状态是什么，那么就遍历</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192013264.png" alt="image-20220619201358182" title="">                </div>                <div class="image-caption">image-20220619201358182</div>            </figure><p>流程：</p><p>以该题为例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192016426.png" alt="image-20220619201604339" title="">                </div>                <div class="image-caption">image-20220619201604339</div>            </figure><ol type="1"><li><p>首先构造S的产生式 <span class="math inline">\(S\to [q_0,Z,q_0]|[q_0,Z,q_1]|[q_0,Z,q_2]\)</span></p></li><li><p>对每个转移函数构造产生式</p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192017873.png" alt="image-20220619201742778" /></p><p><img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192018803.png" alt="image-20220619201828717" /></p></li></ol><p>对于空串的处理 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192021709.png" alt="image-20220619202110627" title="">                </div>                <div class="image-caption">image-20220619202110627</div>            </figure></p><h2 id="上下文无关语言-1">上下文无关语言</h2><h3 id="cfl的泵引理">CFL的泵引理</h3><p>$z L $ 当 <span class="math inline">\(|z| \geq N\)</span> 存在u,v,w,x,y，使得 <span class="math inline">\(z = u\ vwx\ y\)</span> 同时满足</p><ul><li><span class="math inline">\(|vwx| \leq N\)</span></li><li><span class="math inline">\(|vx| \geq 1\)</span></li><li><span class="math inline">\(\forall i \in N^+,\quad uv^i wx^i \in L\)</span></li></ul><h4 id="利用cfl泵引理证明一个语言不是cfl的步骤">利用CFL泵引理证明一个语言不是CFL的步骤：</h4><ol type="1"><li>首先假设该语言是CFL，则其应该满足泵引理，选任意的N.</li><li>找到某一个语言中的句子<span class="math inline">\(z\in L(|z|\geq N)\)</span>.</li><li>分析各种v、x取值，当满足z=uvwxy，且<span class="math inline">\(|vwxl\leq N\)</span>，<span class="math inline">\(|vx|\geq 1\)</span>时，均能找到一个<span class="math inline">\(i&gt;0\)</span>，使<span class="math inline">\(uv^iwx^iy \notin L\)</span>.</li><li>推出矛盾说明假设不成立，即该语言不是CFL。</li></ol><p>需要讨论所有uvwxy的取值</p><h3 id="ogden引理">Ogden引理</h3><p>$z L $ 当z中至少含有N个特异点时， 存在u,v,w,x,y，使得 <span class="math inline">\(z = u\ vwx\ y\)</span> 同时满足</p><ul><li><span class="math inline">\(|vwx|中特异点个数 \leq N\)</span></li><li><span class="math inline">\(|vx|中特异点个数 \geq 1\)</span></li><li><span class="math inline">\(\forall i \in N^+,\quad uv^i wx^i \in L\)</span></li></ul><p>同样反证的时候利用该定理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192053002.png" alt="image-20220619205350903" title="">                </div>                <div class="image-caption">image-20220619205350903</div>            </figure><h3 id="封闭性">封闭性</h3><p>在并、乘积、闭包运算下封闭</p><p>在交、补运算下<strong>不封闭</strong></p><p><strong>定理</strong>：CFL与RL交是CFL</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192103145.png" alt="image-20220619210308056" title="">                </div>                <div class="image-caption">image-20220619210308056</div>            </figure><blockquote><p>当构造多个语言相关的识别器时可以通过原来的控制器构造，如 <span class="math inline">\(M=(Q_1\times Q_2\times \cdots, \Sigma, \delta, [q_{10}, q_{20}, \cdots], F_1\times F_2\times \cdots)\)</span></p></blockquote><p><strong>代换运算</strong> 封闭，参考<a href="#正则代换">正则代换</a> 有CFG G=(V,T,P,S) <span class="math inline">\(\Sigma\)</span> 是另外的字母表，那么映射 <span class="math inline">\(f:T\to 2^{\Sigma^*}\)</span> 称为代换，<span class="math inline">\(f(a) , \forall a \in T\)</span> 也是CFL</p><p><strong>同态运算</strong>、<strong>逆同态运算</strong>封闭</p><h3 id="判定算法">判定算法</h3><h4 id="判断是否非空">判断是否非空</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192119884.png" alt="image-20220619211942800" title="">                </div>                <div class="image-caption">image-20220619211942800</div>            </figure><h4 id="判断是否有穷">判断是否有穷</h4><h5 id="可派生性图">可派生性图</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192121969.png" alt="image-20220619212145887" title="">                </div>                <div class="image-caption">image-20220619212145887</div>            </figure><p>那么对于派生 <span class="math inline">\(A \Rightarrow^+ \alpha A \beta\)</span> 存在的充要条件是：G的可派生性图表示中<strong>存在</strong>一条从标记为A的顶点到标记为A的顶点的长度非0的<strong>有向回路</strong>。且回路中的顶点要从S顶点“可达”。</p><p><strong>定理</strong>：G=(V,T,P,S) 不含无用符号，那么L(G) 为无穷语言的充要条件是：<strong>G的可派生性图表示中存在一条有向回路</strong></p><h5 id="简化可派生性图">简化可派生性图</h5><p>从可派生性图删除终极符号</p><p>同样可以判断是否为无穷语言</p><h3 id="cfl成员判定问题">CFL成员判定问题</h3><p>x是否为L(G)的句子的判定</p><h4 id="cyk算法">CYK算法</h4><p>基本思想：设给定的文法为CNF文法，对于任意字符串x，如果x的第k个字符a可以由B派生出，并且x的第k+1个字符b可以由C派生出，当<span class="math inline">\(A\to BC\in P\)</span>时，ab可以由A派生出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192129409.png" alt="image-20220619212937326" title="">                </div>                <div class="image-caption">image-20220619212937326</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192130435.png" alt="image-20220619213027351" title="">                </div>                <div class="image-caption">image-20220619213027351</div>            </figure><p>算法具体步骤</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192131786.png" alt="image-20220619213109687" title="">                </div>                <div class="image-caption">image-20220619213109687</div>            </figure><p>k控制字串长度，i控制字串开始位置，j控制将字串切分成两端</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192145061.png" alt="image-20220619214550968" title="">                </div>                <div class="image-caption">image-20220619214550968</div>            </figure><h2 id="图灵机">图灵机</h2><p>TM基本模型包括：</p><ul><li>一个有穷控制器。</li><li>一条含有无穷多个带方格的输入带。</li><li>一个读写头。</li></ul><p>TM的每次移动与所读符号、所处状态有关。一个移动将完成以下三个动作：</p><ol type="1"><li>改变有穷控制器的状态；</li><li>在当前所读符号所在的带方格中印刷一个符号；</li><li><strong>将读写头向右或者向左移一格。</strong></li></ol><p>基本的图灵机<br /><span class="math display">\[M = (Q,\Sigma,\Gamma, q_0, B, F)\]</span></p><ul><li>Q 状态集合</li><li><span class="math inline">\(q_0\)</span> 初始状态</li><li>F，终止状态集</li><li><span class="math inline">\(\Gamma\)</span> 带符号表，可以出现在纸带上的符号集合</li><li><span class="math inline">\(B \in \Gamma\)</span>，空白符，含有空白符的带方格被认为是空的</li><li><span class="math inline">\(\Sigma \subset \Gamma-{B}\)</span> 输入字母表，只有 <span class="math inline">\(\Sigma\)</span> 中的符号才能在M<strong>启动时</strong> 出现在输入带上</li><li><span class="math inline">\(\delta:Q\times \Gamma \to Q \times \Gamma \times \{R,L\}\)</span> ，RL表示向右向左移动，先改变状态，再将所在的方格中印刷字符Y，最后再移动</li></ul><p>特别的，如果遇到转移函数没有定义的情况，图灵机就停机</p><p><span class="math inline">\(\alpha_1 q \alpha_2\)</span> 称为<strong>即时描述</strong> (ID)，即时描述移动使用 <span class="math inline">\(\vdash_M\)</span></p><p>接受的语言叫做 <strong>递归可枚举语言</strong></p><p>如果TM对于每个输入串都停机，接受的语言叫做 <strong>递归语言</strong></p><p>递归语言是递归可枚举语言的子类，而上下文有关文法是递归语言的子类</p><h3 id="相关概念">相关概念</h3><p>只要一个问题能够表达成一个有穷字母表上的字符串编码，就可将此问题变成<strong>判定一个语言是否是递归语言的问题。</strong></p><p><strong>可判定的</strong>（decidable）问题，对应于“递归语言”</p><ul><li>以问题的实例为输入，并能给出相应的“是”与“否”的判定。</li></ul><p><strong>不可判定的</strong>（undccidablc）问题没有上述算法，例如，</p><ul><li>对于任意给定的上下文无关文法G，判断它的语言L（G）是否二义性</li><li>对于任意给定的图灵机的描述M和输入w，判断M是否会停机</li></ul><p><strong>P类问题</strong>（class of P）：P表示确定的TM在多项式时间（步数）内可判定的问题。这些语言对应的问题称为是P类问题，这种语言称为多项式可判定的。</p><p><strong>NP类问题</strong>（class of NP）：NP表示不确定的TM在多项式时间（步数）内可计算的问题。对于NP问题，在给定答案时，确定的TM在多项式时间内可验证答案的正确性。（例如，数独问题）</p><p><strong>NP完全的</strong>（NPcomplete problem）：NP类中的一些问题能代表整个NP类的最高复杂性。<br />如果能找到这些问题中的任何一个的多项式时间判定算法，那么，所有的NP问题都是多项式时间可以判定的。<br />所有NP问题都可以在多项式时间内转换为NP完全的。</p><h2 id="上下文有关文法csg">上下文有关文法CSG</h2><p>0型文法：短语结构文法PSG，也叫递归可枚举集</p><p>1型文法：上下文有关文法</p><p>具体见<a href="#乔姆斯基文法体系">乔姆斯基文法体系</a></p><p><strong>图灵机与PSG等价</strong></p><h3 id="线性有界自动机">线性有界自动机</h3><p>线性有界自动机（linear bounded automaton，LBA）</p><ul><li>非确定的TM。</li><li>输入字母表包含两个特殊的符号C和$，其中，C作为输入符号串的左端标志，$作为输入符号串的右端标志。</li><li>LBA的读头只能在C和$之间移动，它不能在端点符号C和$上面打印另外一个符号。</li></ul><p><strong>LBA与CSG等价</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/imgs/202206192251891.png" alt="image-20220619225114676" title="">                </div>                <div class="image-caption">image-20220619225114676</div>            </figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;形式语言与自动机&quot;&gt;形式语言与自动机&lt;/h1&gt;
&lt;h2 id=&quot;字母表&quot;&gt;字母表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意区分&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 和 &lt;span class=&quot;math inl</summary>
      
    
    
    
    <category term="Review" scheme="https://xav1erw.github.io/categories/Review/"/>
    
    
    <category term="形式语言与自动机" scheme="https://xav1erw.github.io/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="课内" scheme="https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"/>
    
    <category term="复习" scheme="https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络期末复习</title>
    <link href="https://xav1erw.github.io/2022/06/16/Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://xav1erw.github.io/2022/06/16/Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-15T16:00:00.000Z</published>
    <updated>2022-06-20T12:25:44.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络期末复习">计算机网络期末复习</h1><h2 id="计算机网络">计算机网络</h2><h3 id="网络协议栈各层作用">网络协议栈各层作用</h3><ol type="1"><li><p>应用层：通过应用进程间交互完成特定的互联网应用，定义应用进程之间通信和交互的规则。</p></li><li><p>传输层：进程之间通信的通用数据传输服务。</p></li><li><p>网络层：网络中不同主机提供通信服务</p></li><li><p>链路层：两个相邻网络结点之间传送数据</p></li><li><p>物理层：如何在传输媒介中传输比特流</p></li></ol><h2 id="应用层">应用层</h2><h4 id="c-s和p2p工作特点">C-S和P2P工作特点</h4><p>客户-服务器是需要服务器打开，客户连接通信；P2P各方之间是对等的。</p><h4 id="优缺点">优缺点</h4><h5 id="客户-服务器">客户-服务器</h5><ul><li><p>优点：客户、服务器分离，允许网络分布操作；一个服务器可以服务于多个客户端；</p></li><li><p>缺点：客户机会比较依赖于服务器工作。</p></li></ul><h5 id="p2p">P2P</h5><ul><li>优点：可扩展性强，传播速度优化；</li><li>缺点：用户直连，没有确保安全性，管理困难。</li></ul><h4 id="为什么引入域名dns缓存作用">为什么引入域名，DNS缓存作用</h4><p>方便人们记住主机名标识，同时适应路由器需要定长有层次的IP地址，需要一种从主机名到IP地址的转换服务，因此DNS系统产生了；缓存就是对重复的访问，省去一些重复的解析，节省时间。</p><h2 id="传输层">传输层</h2><h3 id="tcp">TCP</h3><p><strong>最大报文段长度</strong>( Maximum Segment Size,MSS) 。MSS 通常根据最初确定的由本地发送主机发送的最大链路层 帧 长度（ 即所谓的最大传输单元(Maximum Transmission Unit, MTU))<br />来设置 。 设置该 MSS 要保证一个 TCP报文段（当封装在一个 IP 数据报中）加上 TCP/ IP 首部长度（通常 40 字节） 将适合单个链路层帧 。</p><p><strong>注意到 MSS 是指在报文段里应用层数据的最大长度，而不是指包括首部的 TCP 报文段的最大长度 。</strong></p><p>当 TCP 发送一个大文件 ，例如 某 Web 页面上的一个图像时，TCP 通常是将该文件划分成长度为 MSS 的 若干块（最后一块除外，它通常小于 MSS)</p><h4 id="拥塞控制">拥塞控制</h4><p>运行在发送方的 TCP 拥塞控制机制跟踪 一 个额外的变量，即拥塞窗口(congestion window) 。 拥塞窗口表示为 cwnd它对一个 TCP 发送方能向网络中发送流量的速率进行了限制 。<br /><span class="math display">\[LastByteSent - LastByteAcked\leq \min \{cwnd,rwnd\}\]</span></p><h2 id="网络层">网络层</h2><p>因特网的地址分配策略被称为 无类别域间路由选择(Classless Interdomain Routing,<strong>CIDR</strong>) [ RFC 4632 ] CIDR 将 子网寻址的概念 一般化了）当使用子网寻址时，32 比特的IP 地址被划分为两部分，并且也具有点分十进制数形式 $ a. b. c. d/x$, 其中x指示了地址的第一部分中的比特数</p><h3 id="best-effort-service-model-为尽力而为服务">Best effort service model 为尽力而为服务。</h3><ul><li><p><strong>工作特点</strong>：尽最大的可能性发送报文，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。</p></li><li><p><strong>优点</strong>：适用于绝大多数网络应用。尽力而为服务模型与适当带宽供给相结合已被证明超过“足够好”，能够用于大量的应用，包括语音、视频等流式视 频服务以及实时会议应用。</p></li><li><p><strong>不足</strong>：对时延、可靠性不提供任何保证。</p></li></ul><h3 id="距离向量路由选择算法">距离向量路由选择算法</h3><p>令 <span class="math inline">\(d_x (y)\)</span> 是从节点 x 到节点 y 的最低开销路径的开销 。 则该最低开销与著名的Bellman- Ford 方程相关，即<br /><span class="math display">\[d_x (y) = \min_v \{c(x,v) + d_v(v)\}\]</span><br />v为x的临近节点， <span class="math inline">\(c(x,v)\)</span> 意为cost</p><h3 id="总结常见的传统路由协议并指出其使用的是什么路由算法传统路由协议有什么弊端">总结常见的传统路由协议，并指出其使用的是什么路由算法。传统路由协议有什么弊端？</h3><p>OSPF：Dijkstra RIP：距离向量路由算法</p><p>弊端：拓扑维护，影响路由器性能和效率；流量路径缺乏灵活调整能力；网络协议实现复杂，运维难度大等。</p><h3 id="什么是sdn它有哪些特点">什么是SDN，它有哪些特点？</h3><p>软件定义网络，是在数据平面和控制平面作明确分割的网络设计理念</p><p>特点：基于流的转发；数据平面与控制平面分离；网络控制功能位于数据平面交换外部；可编程网络</p><h3 id="相较于传统路由协议sdn的优势是什么">相较于传统路由协议，SDN的优势是什么？</h3><ul><li>数据控制解耦合，将控制器，交换机分离，开放生态；</li><li>基于流的转发更加灵活</li><li>可编程网络便于开发</li><li>控制逻辑中心化，集中式便于管理</li></ul><h2 id="链路层">链路层</h2><h3 id="crc纠错">CRC纠错</h3><p>所有计算（加减乘除）都是模2运算，没有进位借位，<strong>相当于直接异或</strong></p><p>发送方需要选择长度为r的bits附加到数据D后，然后会构造一个长度为r+1的生成多项式G（同样是二进制数）</p><p>发送的数据为<br /><span class="math display">\[D\cdot 2^r \ \text{XOR} \ R\]</span><br />并且要求该数据能够正好被G整除<br /><span class="math display">\[D\cdot 2^r \ \text{XOR} \ R = nG\]</span><br />可以推导<br /><span class="math display">\[D\cdot 2^r =nG \text{XOR} \ R \\R = \text{remainder} \frac{D\cdot 2^r}{G}\]</span></p><p>每个 CRC 标准都能检测小于 r + 1 比特的 突发差错 。此外，在适当的假设下，长度大于 r + 1 比特的突发<br />差错 以概率 $1 -0. 5^r $ 被检测到。每个 CRC 标准也都能检测任何奇数个比特差错 。</p><h3 id="随机接入协议">随机接入协议</h3><h4 id="时隙-aloha">时隙 ALOHA</h4><p>分为一个个时隙，每个时隙为 <span class="math inline">\(L/R\)</span> 秒，其中L为帧的长度，则每个时隙够发一帧。</p><p>如果没碰撞，正常，有碰撞，则节点在之后的每个时隙中按照 <span class="math inline">\(p\)</span> 的概率重传直至成功。</p><p>一 个给定节点传输的概率是 p; 剩余节点不传输的概率是<span class="math inline">\((1 -p)^{N-1}\)</span> 。因此，一个给定节点成功传送的概率是 <span class="math inline">\(p(1 -p)^{N-1}\)</span> 因为有 N 个节点 ，任意一个节点成功传送的概率是<br /><span class="math display">\[Np(1 -p)^{N-1}\]</span><br />找到最大化的<span class="math inline">\(p^*\)</span> 可以计算当 <span class="math inline">\(N \to \infty\)</span> 时，效率为 <span class="math inline">\(1/e = 0.37\)</span></p><h4 id="aloha">ALOHA</h4><p>纯ALOHA，不分割时隙，任何时间都能传，没碰撞正常，有碰撞就在碰撞传输完后每帧时间按照p概率重传，各个节点时间都不同步，最大效率 <span class="math inline">\(1/(2e)\)</span></p><h4 id="载波侦听多路访问csma">载波侦听多路访问(CSMA)</h4><p><strong>载波侦听(carrier sensing)</strong> ，即一个节点在传输前先听信道 。 如果来自另 一个节点的帧正向信道上发送，节点则等待直到检测到 一 小段时间没有传输，然后开始传输 。</p><p><strong>碰撞检测(collision detection )</strong> , 即当 一个传输节点在传输时 一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧， 它就停止传输，在重复“侦听-当 空 闲时传输”循环之前等待一段随机时间 。</p><p>中止传输后，适配器等待一个随机时间量，之后传输。</p><p>随机时间量执行二进制指数后退(binary exponenlial backoff )算法 ：在该帧经历了 一连串的 n 次碰撞后，节点随机地从 <span class="math inline">\(\{0,1,2,\cdots, 2^n-1\}\)</span> 中选择一个 K 值 。对于以太网，一个节点等待的实际时间量是 $ K $ 比特时间，即发送 512 比特进入以 网所需时间的K倍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络期末复习&quot;&gt;计算机网络期末复习&lt;/h1&gt;
&lt;h2 id=&quot;计算机网络&quot;&gt;计算机网络&lt;/h2&gt;
&lt;h3 id=&quot;网络协议栈各层作用&quot;&gt;网络协议栈各层作用&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;应用层：通过应用进程间交互完成特定的互联网</summary>
      
    
    
    
    <category term="Review" scheme="https://xav1erw.github.io/categories/Review/"/>
    
    
    <category term="课内" scheme="https://xav1erw.github.io/tags/%E8%AF%BE%E5%86%85/"/>
    
    <category term="复习" scheme="https://xav1erw.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://xav1erw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记</title>
    <link href="https://xav1erw.github.io/2022/03/25/Notes/React/"/>
    <id>https://xav1erw.github.io/2022/03/25/Notes/React/</id>
    <published>2022-03-24T16:00:00.000Z</published>
    <updated>2022-06-20T12:25:44.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react">React</h1><h2 id="组件类型和定义">组件类型和定义</h2><ul><li>react组件首字母应当大写，因为使用时以标签形式使用，如果首字母小写会认为是html的内置标签，报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// props是传入的参数</span></span><br><span class="line">    <span class="comment">// 如果使用时不传参，也可以没有参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&#x27;wx&#x27;</span>/&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类式组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 继承 React.Component</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//   必须要有render函数，返回需要渲染的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件三大属性">组件三大属性</h2><h3 id="state">state</h3><ul><li><p>箭头函数<code>()=&gt;&#123;&#125;</code> 和<code>function</code> 区别：箭头函数没有<code>this</code>，其中出现<code>this</code>会去找外侧的<code>this</code>，<code>function</code>自身有<code>this</code>。可以利用该点在类中使用箭头函数，其中用<code>this</code>改变类中的属性.</p></li><li><p>react自定义方法一般用复制加箭头函数的方法</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    myMethod = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/*TODO*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件对象有<code>state</code>属性用于表示组件状态，同时在不同事件后使用<code>setState</code>改变state的值实现不同状态的转化。注意<code>setState</code>会把相同的键合并，不同的键保留，不会覆盖</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">time</span>:<span class="number">111</span>&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">myMethod</span> = <span class="variable language_">this</span>.<span class="property">myMethod</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="comment">// 由于在调用myMethod 的时候，没用通过实例调用，是直接传入的函数</span></span><br><span class="line">        <span class="comment">// 函数在类的原型对象上，因此其中的this指向不正确</span></span><br><span class="line">        <span class="comment">// 因此使用bind在实例中加入属性myMethod</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">myMethod</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">time</span>:time+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.myMethod&#125;</span>&gt;</span>现在的时间是&#123;this.state.time&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同时上述代码可以不需要构造器，简写如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state = &#123;<span class="attr">time</span>:<span class="number">111</span>&#125;</span><br><span class="line">    myMethod = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">time</span>:time+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.myMethod&#125;</span>&gt;</span>现在的时间是&#123;this.state.time&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相当于直接在类中追加state和myMethod的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="props">props</h3><h4 id="类组件中的props">类组件中的props</h4><ul><li>react 的props：我们在创建组件对象时不想用constructor，如何给组件传参？利用props属性，在使用对象标签时给标签参数就可以反映到props属性上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#x27;wx&#x27;</span> <span class="attr">age</span>=<span class="string">&#x27;18&#x27;</span> <span class="attr">gender</span>=<span class="string">&#x27;M&#x27;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;xxx&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>react批量传props：使用对象传参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> infos = &#123;<span class="attr">name</span>:<span class="string">&#x27;wx&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>:<span class="string">&#x27;M&#x27;</span>&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...infos</span>&#125;/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;xxx&#x27;</span>))</span><br><span class="line"><span class="comment">// 注意此处不是对象的展开，因为外层的&#123;&#125;是表示这是一个js表达式</span></span><br><span class="line"><span class="comment">// 这是Babel+react的特性，不是原生js语法</span></span><br><span class="line"><span class="comment">// 直接console.log(...infos) 不会输出内容</span></span><br><span class="line"><span class="comment">// 仅适用于传标签属性</span></span><br></pre></td></tr></table></figure><ul><li>拷贝时可以修改其中的某项参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;wx&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>, <span class="attr">gender</span>:<span class="string">&#x27;M&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> copy = &#123;...a, <span class="attr">name</span>:<span class="string">&#x27;wx2&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy)</span><br><span class="line"><span class="comment">// 结果为 &#123;name:&#x27;wx2&#x27;, age:18, gender:&#x27;M&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>当直接使用标签属性的形式传递props时，形式为<code>key=value</code>此时value只能时字符串，如果想传递其它类型需要加<code>&#123;&#125;</code>表示这是js表达式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Person</span> name=<span class="string">&#x27;wx&#x27;</span> age=<span class="string">&#x27;19&#x27;</span> gender=<span class="string">&#x27;M&#x27;</span>/&gt;</span><br><span class="line"><span class="comment">// 此处的age为字符串，但我们想传入数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;Person name=&#x27;wx&#x27; age=19 gender=&#x27;M&#x27;/&gt;</span></span><br><span class="line"><span class="comment">// 这样会报错，19仅当为js变量时才具有意义，因此改用</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#x27;wx&#x27;</span> <span class="attr">age</span>=<span class="string">&#123;19&#125;</span> <span class="attr">gender</span>=<span class="string">&#x27;M&#x27;</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接使用对象传入参数</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;wx&#x27;</span>, <span class="attr">age</span>:<span class="number">19</span>, <span class="attr">gender</span>:<span class="string">&#x27;M&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="title class_">Person</span> &#123;...a&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>接上述内容，传入标签有不同类型，我们对不同类型标签需要有不同的操作，需要对不同标签的数据类型做限制。同时某些参数不传的时候，也需要参数的默认值。（参考函数传参需要限制参数类型和参数默认值）。组件类中使用属性<code>propTypes</code> 指定各个属性的限制，使用<code>defaultProps</code>指定默认值。具体使用如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="comment">// 15.5之前PropTypes在React核心库中，使用React.PropTypes，之后单独写在prop-types.js中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型和必要性限制</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="comment">// 使用React内置的规则PropTypes，限制name为string，同时是必须的参数</span></span><br><span class="line">    <span class="attr">gender</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">    <span class="attr">action</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">    <span class="comment">// string、number开头小写是为了不和内部的String、Number冲突</span></span><br><span class="line">    <span class="comment">// 同样的，指定函数类型为了不和function冲突使用func</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值的指定</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">gender</span>:<span class="string">&quot;未知&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给类加入属性，可以在类内定义static属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型和必要性限制</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">        <span class="comment">// 使用React内置的规则PropTypes，限制name为string，同时是必须的参数</span></span><br><span class="line">        <span class="attr">gender</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">        <span class="attr">action</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">        <span class="comment">// string、number开头小写是为了不和内部的String、Number冲突</span></span><br><span class="line">        <span class="comment">// 同样的，指定函数类型为了不和function冲突使用func</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认值的指定</span></span><br><span class="line">   <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        <span class="attr">gender</span>:<span class="string">&quot;未知&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个人是&#123;this.props.age&#125;，&#123;this.props.gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;this.props.age&#125;岁<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>props是只读的，不能修改</li></ul><h4 id="函数组件中的props">函数组件中的props</h4><ul><li>函数式组件通过参数的形式可以有<code>props</code>，但没有<code>state</code> 和<code>refs</code>，除非使用最新的hooks</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name, age, gender&#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这个人是&#123;name&#125;，&#123;gender===&#x27;M&#x27;?&#x27;他&#x27;:&#x27;她&#x27;&#125;的年龄是&#123;age&#125;岁<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于没有了类，只能在外部指定限制和默认值</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">        <span class="comment">// 使用React内置的规则PropTypes，限制name为string，同时是必须的参数</span></span><br><span class="line">        <span class="attr">gender</span>:<span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">        <span class="attr">action</span>:<span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">        <span class="comment">// string、number开头小写是为了不和内部的String、Number冲突</span></span><br><span class="line">        <span class="comment">// 同样的，指定函数类型为了不和function冲突使用func</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值的指定</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">        <span class="attr">gender</span>:<span class="string">&quot;未知&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#x27;wx&#x27;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;xxx&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="refs">refs</h3><h4 id="字符串形式的ref不推荐">字符串形式的ref(不推荐)</h4><ul><li>组件内的标签可以通过<code>ref</code> 来标识自己，组件会把<code>ref</code>和标签组成一对key-value放入属性<code>refs</code>中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    showData= <span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接通过this.refs获取到&lt;input&gt;标签</span></span><br><span class="line">        <span class="comment">// 注意此时获取到的是真实DOM标签，不是虚拟DOM</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input1</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#x27;input1&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;点击按钮显示内容&#x27;</span>/&gt;</span> </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span> 点击显示内容 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;点击按钮显示内容&#x27;</span>/&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调函数形式的ref">回调函数形式的ref</h4><ul><li>当<code>ref</code>为函数时，该函数作为回调函数使用，将<code>ref</code>所在节点作为参数传入函数中。一般会利用回调函数，把当前节点赋值给组件属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    showData1= <span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 直接通过this.refs获取到&lt;input&gt;标签</span></span><br><span class="line">        <span class="comment">// 注意此时获取到的是真实DOM标签，不是虚拟DOM</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input1</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    showData2= <span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input2</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(currentNode)</span>=&gt;</span>&#123;this.input1 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span> 点击显示内容 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">onBlur</span>=<span class="string">&#123;this.showData2&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;(currentNode)</span>=&gt;</span>&#123;this.input2 = currentNode&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27; /&gt; </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 由于回调函数简单，只有1个参数和一句，还可简写为 </span></span><br><span class="line">        <span class="comment">// ref = currentNode =&gt; this.input1 = currentNode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有关内联函数(函数体直接定义在<code>ref</code>后面的函数)的问题：<ul><li>当组件更新的时候（<code>state</code>改变，react重新调用<code>render</code>函数，重新渲染），会调用两次<code>ref</code>回调函数，第一次传入参数<code>null</code> 第二次才真正传入当前节点</li><li>原因：每次重新调用<code>render</code> 都会重新生成回调函数，不确定之前调用的回调函数有什么影响，为了消除影响，第一次先传入null消除之前可能的效果，之后再次调用，传入当前节点。</li><li>只是细节，基本不会产生影响</li><li>如果想改，可以把回调函数改为类中定义的函数</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state = &#123;<span class="attr">s</span>:<span class="title class_">True</span>&#125;</span><br><span class="line">    showData1= <span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input1</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    change= <span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;s&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">s</span>:!s&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    refCallback=<span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">input1</span> = currentNode;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;@&#x27;</span>, currentNode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果使用这个，控制台就只会出现 @ &lt;input ...&gt;</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(currentNode)</span>=&gt;</span>&#123;this.input1 = currentNode;console.log(&#x27;@&#x27;, currentNode)&#125;&#125; type=&#x27;text&#x27; placeholder=&#x27;点击按钮显示内容&#x27;/&gt; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData1&#125;</span>&gt;</span> 点击显示内容 <span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change&#125;</span>&gt;</span> 点击改变状态 <span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当点击change后，可以看到控制台上输出</span></span><br><span class="line">    <span class="comment">// @ null</span></span><br><span class="line">    <span class="comment">// @ &lt;input ...&gt;</span></span><br><span class="line">    <span class="comment">// 两个结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createref">createRef</h4><ul><li>可以使用react内部的<code>createRef</code>来定义一个<code>ref</code>，<code>createRef</code>相当于创建一个容器，装ref对应的标签，每个<code>createRef</code>对应一个标签，<code>createRef</code>创建的ref是一个对象，其中有一个key为<code>currrent</code> 通过<code>myRef.current</code>获取到对应的标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state = &#123;<span class="attr">s</span>:<span class="title class_">True</span>&#125;</span><br><span class="line">    myRef1 = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef1&#125;</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;点击按钮显示内容&#x27;</span>/&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="react事件处理">React事件处理</h2><ul><li>React中的事件都被封装了一层</li></ul><ol type="1"><li>通过 <code>onXxx</code> 指定事件处理函数，如<code>onClick</code>、<code>onBlur</code>等<ol type="1"><li>使用的是React自定义事件，而不是原生DOM事件 （为了更好的兼容性）</li><li>事件都是通过事件委托的方式处理的（委托给组件最外层元素） （为了高效）</li></ol></li><li>通过<code>event.target</code>得到发生事件的DOM元素对象 （减少ref使用）</li></ol><ul><li>避免过度使用ref：<ul><li>发生事件的元素正好是需要操作的元素，可以不用ref</li><li>利用事件的回调函数传入的<code>event</code>参数直接获取DOM元素对象</li></ul></li></ul><p>例：<br /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    showOnBlur=<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 回调该函数时会传入event参数，使用event.target获得该事件的DOM对象</span></span><br><span class="line">        <span class="comment">// 这样可以避免ref的频繁使用</span></span><br><span class="line">        <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">onBlur</span>=<span class="string">&#123;this.showOnBlur&#125;</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;失去焦点显示内容&#x27;</span>/&gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="react-受控和非受控组件">React 受控和非受控组件</h2><h3 id="非受控组件">非受控组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;   </span><br><span class="line">    subCallback=<span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>()</span><br><span class="line">        <span class="keyword">const</span> &#123;username, passwd&#125; = <span class="variable language_">this</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">`用户名：<span class="subst">$&#123;username.value&#125;</span>  密码：<span class="subst">$&#123;passwd.value&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.subCallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span>=&gt;</span>this.username=c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">                密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span>=&gt;</span>this.passwd=c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// form中action表示提交表单数据的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>form表单不提供参数时，默认发起GET请求同时带有query参数</li><li>原生js中表单具有事件 <code>onsubmit</code>， React中为 <code>onSubmit</code></li><li>避免表单提交刷新页面，可以使用 <code>event.preventDefault()</code> 阻止默认事件不提交表单</li><li>非受控组件：页面中所有输入类DOM的值现用现取（点击登录后，回调函数获取表单值）属于非受控组件</li></ul><h3 id="受控组件">受控组件</h3><ul><li>原生js 有事件<code>onchange</code> 在改变时调用<code>onchange</code> 的回调函数，React中同样有 <code>onChange</code></li><li>使用<code>onChange</code> 回调函数将输入内容直接存入状态中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;   </span><br><span class="line">    state = &#123;<span class="attr">username</span>:<span class="string">&quot;NoName&quot;</span>, <span class="attr">passwd</span>:<span class="string">&quot;NoPasswd&quot;</span>&#125;</span><br><span class="line">    readUserName = <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">username</span>:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    readPasswd = <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">passwd</span>:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    subCallback=<span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>()</span><br><span class="line">        <span class="keyword">const</span> &#123;username, passwd&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">`用户名：<span class="subst">$&#123;username&#125;</span>  密码：<span class="subst">$&#123;passwd&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.subCallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.readUserName&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.readPasswd&#125;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>关于受控和非受控：<ul><li>非受控可以理解为拿到数据的行为不受程序控制，而受用户控制，只有用户进行提交等行为，组件才能最终拿到数据；</li><li>受控可以理解为拿数据的行为受程序控制，用户只要输入，不用提交，随着输入组件就能就拿到数据</li><li>更建议使用受控组件，因为非受控组件有几个输入，就有几个<code>ref</code>，受控组件可以减少<code>ref</code> 的使用</li></ul></li><li>上述代码有重复实现的功能，可以改善，<a id="柯里化代码">代码如下</a>，具体使用了函数的柯里化</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;   </span><br><span class="line">    state = &#123;<span class="attr">username</span>:<span class="string">&quot;&quot;</span>, <span class="attr">passwd</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    changeFormData=<span class="function">(<span class="params">dataType</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;[dataType]:event.<span class="property">target</span>.<span class="property">value</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将函数作为返回值供回调使用，同时利用传入参数实现不同功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    subCallback=<span class="function">(<span class="params">event</span>)=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>()</span><br><span class="line">        <span class="keyword">const</span> &#123;username, passwd&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">`用户名：<span class="subst">$&#123;username&#125;</span>  密码：<span class="subst">$&#123;passwd&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.subCallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.changeFormData(</span>&quot;<span class="attr">username</span>&quot;)&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.changeFormData(</span>&quot;<span class="attr">passwd</span>&quot;)&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Login</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>不用柯里化函数，也可以实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改changeFormData，接受dataType和需要的参数</span></span><br><span class="line">changeFormData=<span class="function">(<span class="params">dataType, value</span>)=&gt;</span>&#123;<span class="comment">/*do something*/</span>&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.subCallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(event)</span>=&gt;</span>&#123;this.changeFormData(&quot;username&quot;, event.target.value)&#125;&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>直接利用回调函数给<code>changeFormData</code>传入不同的参数实现代码复用</p><h2 id="组件生命周期重要">组件生命周期（重要）</h2><h3 id="旧版本">旧版本</h3><ul><li><p>组件第一次被渲染到页面上时，React中称之为<strong>挂载 (mount)</strong> ，从页面移除时称之为 <strong>卸载 (unmount)</strong></p></li><li><p>挂载组件使用<code>render()</code> ，卸载使用<code>ReactDOM.unmountComponentAtNode()</code></p></li><li><p>希望在组件挂载到页面上时执行一些操作，比如设置定时器等。可以使用 <code>componentDidMount()</code>进行操作，该函数在组件挂载时调用，并仅调用这一次。</p></li><li><p>例：希望组件中的文本周期性的透明度减小，到0时恢复为1。点击按钮使组件消失</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state=&#123;<span class="attr">opacity</span>:<span class="number">1</span>&#125;</span><br><span class="line">    delEle=<span class="function">()=&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">        <span class="comment">// 删除组件</span></span><br><span class="line">        <span class="comment">// 测试中发现只能删除该组件外部的容器，而不能删除组件内部的标签</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// componentDidMoun调用：只在挂载时调用</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(</span><br><span class="line">            <span class="function">()=&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> &#123;opacity&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">                opacity -= <span class="number">0.1</span></span><br><span class="line">                <span class="keyword">if</span> (opacity&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    opacity = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">opacity</span>:opacity&#125;)</span><br><span class="line">            &#125;,<span class="number">200</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 设置定时器，每200ms透明度减小0.1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render调用：初始化渲染，更新调用</span></span><br><span class="line">    <span class="comment">// 如果定时器设置在render中，每次更新都会创建新的定时器，造成混乱</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&#123;&#123;opacity:this.state.opacity&#125;&#125;</span>&gt;</span>测试文本<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.delEle&#125;</span>&gt;</span>点我消失<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码会出现新的问题，在点击删除节点后，控制台报错：不能更新一个未挂载的组件(unmounted component)的状态</li><li>解决以上问题：<ol type="1"><li>先把定时器绑定到<code>this</code> 上，即初始定义为<code>this.timer = setInterval()</code> ，之后在删除组件时加上删除定时器<code>clearInterval(this.timer)</code> 使状态停止更新</li><li>直接使用<code>componentWillUnmount</code> 做这项工作，在组件将要被卸载时执行的操作</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">delEle=<span class="function">()=&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)</span><br><span class="line">    <span class="comment">// 提前清除定时器</span></span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timer</span>=<span class="built_in">setInterval</span>(</span><br><span class="line">        <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">/*TODO*/</span></span><br><span class="line">        &#125;,<span class="number">200</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件的生命周期实际就是组件从创建、挂载到卸载，其中重要的函数（如<code>render</code>、<code>componentDidMount</code>、<code>componentWillUnmount</code> 等）被称为：生命周期钩子函数、生命周期函数等<ul><li>组件从创建到死亡有一些特定的阶段</li><li>组件包含一系列钩子函数会在特定阶段调用</li><li>定义组件时会在特定的生命周期回调函数中，做特定的工作。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/React/生命周期流程.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>对于上图：左侧好理解，不做赘述</li><li>右侧：<ol type="1"><li><code>setState</code> 流程<ol type="1"><li>调用后，首先会通过<code>shouldComponentUpdate</code> 阀门，检查是否应当更新当前组件，若返回true则能够进行下去，反之会被阻拦，无法调用后面的函数。如果该函数未定义，永远返回true</li><li>检查返回true后会依次调用<code>componentWillUpdate</code> 、 <code>render</code> 、<code>componentDidUpdate</code> 表示组件更新前、更新、更新后的操作</li></ol></li><li><code>forceUpdate</code> 流程<ul><li>跳过<code>shouldComponentUpdate</code> 强制更新</li><li>直接调用<code>componentWillUpdate</code> 、 <code>render</code> 、<code>componentDidUpdate</code></li><li>一般用做不更改状态数据，强制更新一下</li><li>通过<code>this.forceUpdate</code> 调用</li></ul></li><li>父组件调用 <code>render</code><ul><li>首先组件要形成父子关系：在A组件中调用B组件，则A为B的父组件</li><li>父组件状态改变，重新render后，调用子组件钩子 <code>componentWillReceiveProps</code> （组件将要接收props）</li><li><strong>注意！</strong> 上述钩子在第一次传入props 时不会调用！只有更新传入新的props时才会调用（可以认为父组件重新render后调用）</li></ul></li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件调用render展示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state = &#123;<span class="attr">s</span>:<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    changeState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;s&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">s</span>:!s&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;s&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">let</span> st = s? <span class="string">&quot;状态1&quot;</span>:<span class="string">&quot;状态2&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是A组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeState&#125;</span>&gt;</span>改变状态<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">B</span> <span class="attr">show</span>=<span class="string">&#123;st&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillReceiveProps</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;B---componentWillReceiveProps&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是B组件，展示状态：&#123;this.props.show&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面初始时，控制台不会显示B---componentWillReceiveProps</span></span><br><span class="line"><span class="comment">// 之后每点击一次button，控制台就多显示一个B---componentWillReceiveProps</span></span><br></pre></td></tr></table></figure><ul><li>以上都为旧版本的生命周期，做如下总结</li></ul><ol type="1"><li>初始化阶段，由<code>ReactDOM.render()</code> 触发 （初次渲染）<ol type="1"><li><code>constructor</code></li><li><code>componentWillMount</code></li><li><code>render</code></li><li><code>componentDidMount</code> <strong>常用</strong>，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息</li></ol></li><li>更新阶段，由<code>this.setState</code> 或父组件 <code>render</code> 触发<ol type="1"><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ol></li><li>卸载组件，通常由 <code>ReactDOM.unmountComponentAtNode</code> 触发<ol type="1"><li><code>componentWillUnmount</code> <strong>常用</strong>，通常做一些收尾工作，例：关闭定时器、取消订阅</li></ol></li></ol><h3 id="新版本">新版本</h3><ul><li><p><code>componentWillMount</code> 、<code>componentWillReceiveProps</code> 、 <code>componentWillUpdate</code> 前都需要加上<code>UNSAFE_</code></p></li><li><p>记忆：除了 <code>componentWillUnmount</code>，所有带will 的钩子都需要加<code>UNSAFE_</code></p></li><li><p>unsafe：未来版本后加入异步渲染后，这三个钩子可能带来一些bug（现在不会），因此加入UNSAFE标志，同时提醒减少这三个钩子的使用</p></li><li><p>新生命周期如<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">下图</a><br /><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Xav1erW/blog-imgs/master/React/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B0.jpg" alt="生命周期新" title="">                </div>                <div class="image-caption">生命周期新</div>            </figure></p></li><li><p>对于新生命周期，可以理解为：</p><ol type="1"><li>废弃<code>componentWillMount</code> 、<code>componentWillReceiveProps</code> 、 <code>componentWillUpdate</code>三个旧的钩子</li><li>提出 <code>getDerivedStateFromProps</code> 、 <code>getSnapshotBeforeUpdate</code> 两个新的钩子</li><li>注：实际使用中，两个新的钩子使用情况极其罕见</li></ol></li><li><p>对于<code>getDerivedStateFromProps</code>：</p><ul><li>定义在类上，因此需要是静态方法 <code>static getDerivedStateFromProps</code> ；同时返回值也必须是状态对象或<code>null</code></li><li>接受参数<code>props</code>和<code>state</code> ，得到标签参数</li><li>当返回<code>null</code>时，不会产生影响</li><li>当返回状态对象，会将返回的对象设置为当前的state</li><li><strong>理解</strong>：从props中得到派生的状态，即通过props的值得到状态，state的值在任何时候都取决于props，修改就没作用了</li><li><strong>注意</strong>：容易造成代码冗余并且难以维护</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state = &#123;<span class="attr">s</span>:<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">        <span class="comment">// return null</span></span><br><span class="line">        <span class="comment">// 返回null不会有任何影响</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(nextProps, prevState);</span><br><span class="line">        <span class="comment">// 第一次输出 &#123;s:100&#125;  &#123;s:0&#125;</span></span><br><span class="line">        <span class="comment">// 之后输出 &#123;s:100&#125;  &#123;s:101&#125;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">s</span>:nextProps.<span class="property">s</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从props中得到数据，并强行指定state值</span></span><br><span class="line"></span><br><span class="line">    changeState = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;s&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">s</span>:s+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="comment">// 每次点击+1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;s&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是A组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeState&#125;</span>&gt;</span>改变状态<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前状态值为&#123;s&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">A</span> <span class="attr">s</span>=<span class="string">&#123;100&#125;/</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>对于<code>getSnapshotBeforeUpdate</code>：<ul><li>在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</li><li><strong>说明</strong>： <code>componentDidUpdate</code> 实际有三个参数 <code>componentDidUpdate(preProps, preState, snapshot)</code> 接收更新前的props、更新前的state和<code>getSnapshotBeforeUpdate</code> 传递进来的快照 snapshot</li></ul></li><li>案例说明：<ul><li>需求：有一新闻列表，长度固定；不断有新的新闻刷新，新的新闻在列表最上方；超出列表长度，使用滚动条。</li><li>问题：当内容不断刷新出现时，滚动条相对于最高点位置是固定的，反映到内容上，旧的内容会被新的内容挤到下方</li><li>解决：需要固定内容相对不动，即每次更新内容时，需要滚动条相对顶部的高度加上新内容的高度</li></ul></li></ul><p>提前定义好列表和新闻样式为<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.newsList</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background</span>:skyblue;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><a id="indexAsKey">代码</a> 为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewsList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state = &#123;<span class="attr">newsArr</span>:[]&#125;</span><br><span class="line">    <span class="comment">// state中保存新闻列表</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原状态</span></span><br><span class="line">            <span class="keyword">const</span> &#123;newsArr&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">            <span class="comment">// 模拟生成新闻消息</span></span><br><span class="line">            <span class="keyword">const</span> news = <span class="string">&quot;新闻&quot;</span> + (newsArr.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 更新状态，把新的新闻信息放到第一个</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">newsArr</span>:[news,...newsArr]&#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">NewsList</span>.<span class="property">scrollHeight</span></span><br><span class="line">        <span class="comment">// 拿到更新之前内容区的高度，以和更新后比较，计算更新前后差值</span></span><br><span class="line">        <span class="comment">// 将高度留下快照</span></span><br><span class="line">        <span class="comment">// 快照传给componentDidUpdate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, heightSnapshot</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取更新后的高度</span></span><br><span class="line">        <span class="keyword">let</span> currentHeight = <span class="variable language_">this</span>.<span class="property">NewsList</span>.<span class="property">scrollHeight</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// scrollTop即规定滚动条到顶部的距离</span></span><br><span class="line">        <span class="comment">// 每次距离要加上增加的内容长度</span></span><br><span class="line">        <span class="comment">// 注意不要=，直接=相当于固定滚动条高度，内容还是会被挤下去</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">NewsList</span>.<span class="property">scrollTop</span> += currentHeight-heightSnapshot</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;newsList&#x27;</span> <span class="attr">ref</span>=<span class="string">&#123;(cNode)</span>=&gt;</span>&#123;this.NewsList = cNode&#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    this.state.newsArr.map(</span></span><br><span class="line"><span class="language-xml">                        (n,index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;news&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;n&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;</span></span><br><span class="line"><span class="language-xml">                    )</span></span><br><span class="line"><span class="language-xml">                    // 回想：react会自动展开可迭代的一系列标签</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 注：中间有key属性是因为要求列表中每一个子节点都有一个unique key</span></span><br><span class="line">        <span class="comment">// 为简单因此将index作为key</span></span><br><span class="line">        <span class="comment">// 实际这样使用会出现一些问题，之后再做探讨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>新版本生命周期总结如下</li></ul><ol type="1"><li>初始化阶段，由<code>ReactDOM.render()</code> 触发 （初次渲染）<ol type="1"><li><code>constructor</code></li><li><code>getDerivedStateFromProps</code></li><li><code>render</code></li><li><code>componentDidMount</code> <strong>常用</strong>，经常在该钩子中进行初始化，如：开启定时器、发起请求、订阅消息</li></ol></li><li>更新阶段，由<code>this.setState</code> 或父组件 <code>render</code> 触发<ol type="1"><li><code>getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidUpdate</code></li></ol></li><li>卸载组件，通常由 <code>ReactDOM.unmountComponentAtNode</code> 触发<ol type="1"><li><code>componentWillUnmount</code> <strong>常用</strong>，通常做一些收尾工作，例：关闭定时器、取消订阅</li></ol></li></ol><h2 id="diffing算法">Diffing算法</h2><ul><li><p>React每次更新不是直接更新真实DOM，而是修改虚拟DOM，比较修改前后的虚拟DOM，只找不同的地方在真实DOM修改，不用真实DOM每次都全部更新，效率高</p></li><li><p>Diffing算法最小更新粒度是标签，但是会比较多层，比如<br /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">    现在的时间是：&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>&#125;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><br />其中<code>this.state.time</code> 一秒钟更新一次，表示当前时间，<code>span</code> 标签内容改变，但是内部的<code>input</code>标签并没有改变，react只更新改变的内容，内部的 <code>input</code> 不会更新。</p></li><li><p>虚拟DOM中<code>key</code>的作用</p><ul><li>简单：<code>key</code>是虚拟DOM对象的标识，更新显示时<code>key</code>起着极其重要的作用</li><li>详细：</li></ul><ol type="1"><li>当状态数据发生变化时，react会根据新数据生成新的虚拟DOM，随后React将【新虚拟DOM】与【旧虚拟DOM】的diff比较，规则如下：<ul><li>旧DOM找到了与新DOM相同的<code>key</code>，：<ul><li>若虚拟DOM内容不变，则仍用原本的真实DOM</li><li>若虚拟DOM内容改变了，则根据改变的虚拟DOM生成真实DOM，替换页面内容</li></ul></li><li>未找到相同的<code>key</code>：根据数据创建真实DOM并渲染到页面</li></ul></li></ol></li></ul><p><a href="#indexAsKey">之前的代码</a> 提到用<code>index</code>作为<code>key</code> 会产生一些问题，下分析其低效原因<br />代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="string">&quot;小王&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小李&quot;</span>, <span class="attr">age</span>:<span class="number">19</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;persons&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">const</span> p = &#123;<span class="attr">id</span>:persons.<span class="property">length</span>+<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小张&quot;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">persons</span>:[p,...persons]&#125;)</span><br><span class="line">        <span class="comment">// 注意此处将信息系加入到了前面</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>信息展示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>添加小张<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;</span></span><br><span class="line"><span class="language-xml">                        this.state.persons.map((personObj, index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;personObj.name&#125;---&#123;personObj.age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;)</span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析其中的更新步骤：<br />1. 初始化创建， <code>state</code> 内为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小王&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>:<span class="string">&quot;小李&quot;</span>, <span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么虚拟DOM中标签为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">0</span>&gt;</span>小王---18<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">1</span>&gt;</span>小李---19<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>更新后，数据变为</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>, <span class="attr">name</span>:<span class="string">&quot;小张&quot;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小王&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>:<span class="string">&quot;小李&quot;</span>, <span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>新生成的虚拟DOM标签为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">0</span>&gt;</span>小张---20<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">1</span>&gt;</span>小王---18<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">2</span>&gt;</span>小李---19<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照之前的diffing比较步骤：<br />1. 首先取 <code>key=0</code> 旧虚拟和新虚拟比较：有该<code>key</code>，但内容不同，则重新渲染到真实DOM中<br />2. 再取 <code>key=1</code> 旧虚拟和新虚拟比较：有该<code>key</code>，但内容不同，则重新渲染到真实DOM中<br />3. 取 <code>key=2</code> 旧虚拟和新虚拟比较：无该<code>key</code>，直接渲染到真实DOM中</p><p>可以发现，实际将三个标签全部重新渲染，但是我们可以看出，两个标签是重复的，不必要再次渲染，这样冗余的渲染造成了效率低下</p><p>进一步看造成冗余的原因：使用<code>index</code>作为<code>key</code>，在数据列表等顺序改变时，会直接改变已有数据的<code>key</code>，导致新加入数据后，原本数据对应标签的<code>key</code> 也发生变化，造成多余的真实DOM渲染，没有复用之前的标签</p><p><strong>最好不要使用<code>index</code>，而是用数据的唯一标识，如<code>id</code>等作为<code>key</code>的值</strong></p><p>以上的问题，不只会带来效率降低，当有输入框等嵌套结构时，还会造成数据错位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">0</span>, <span class="attr">name</span>:<span class="string">&quot;小王&quot;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小李&quot;</span>, <span class="attr">age</span>:<span class="number">19</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;persons&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">const</span> p = &#123;<span class="attr">id</span>:persons.<span class="property">length</span>+<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&quot;小张&quot;</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">persons</span>:[p,...persons]&#125;)</span><br><span class="line">        <span class="comment">// 注意此处将信息系加入到了前面</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>信息展示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用index为key<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.add&#125;</span>&gt;</span>添加小张<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;</span></span><br><span class="line"><span class="language-xml">                        this.state.persons.map((personObj, index)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;personObj.name&#125;---&#123;personObj.age&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;)</span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用id为key<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;</span></span><br><span class="line"><span class="language-xml">                        this.state.persons.map((personObj)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">                            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;personObj.id&#125;</span>&gt;</span>&#123;personObj.name&#125;---&#123;personObj.age&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#125;)</span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，上半部分在输入后点击“添加小张” 会造成输入框数据的错位；下半部分则不会</p><p>原因：<br />* 在用index作为key的部分，由于相同的key内部值不同，节点都做了更新，但因为虚拟DOM中 <code>input</code> 没有 <code>value</code> 属性，直接比较内部 <code>input</code> 标签都一样，因此没有更新 <code>input</code> 标签，这样相当于保留输入但改变前面内容，造成了最终的错位<br />* 使用<code>id</code>为<code>key</code>，比较后id相同不做更新，直接在最前方加入 <code>li</code> 标签，输入框和文本信息统一后移，不会有错位</p><p>总结：用<code>index</code>作为<code>key</code>可能的问题<br />1. 若对数据进行排序、逆序、删除、插入等操作破坏原本顺序：会造成不必要的真实DOM更新，降低效率<br />2. 如果结构中还包含输入类DOM：会产生错误的DOM更新造成信息的错误显示<br />3. 如果不对数据进行排序、逆序、删除、插入等操作，仅用于渲染展示信息，可以使用<code>index</code>作为<code>key</code></p><h2 id="react脚手架">React脚手架</h2><h3 id="文件介绍">文件介绍</h3><ul><li><code>punlic/index.html</code></li></ul><p>head部分内容解释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以链接形式指定图标，%PUBLIC_URL%为public文件夹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启理想视口，适配移动端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定地址栏和标签页的主题颜色（仅针对安卓手机） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000000&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>punlic/manifest.json</code></li></ul><p>如果网页用作应用加壳，使用的配置文件（即，直接使用网页套壳作为安卓、iOS应用等）</p><ul><li><code>src/App.js</code></li></ul><p>存放最外层App组件，用脚手架开发之后，所有小组件都作为App的子组件，最后只加载App组件到页面</p><ul><li><code>src/App.test.js</code></li></ul><p>对App组件做测试的脚本，几乎不用</p><ul><li><code>src/index.js</code></li></ul><p>webpack的入口文件<br />其中加载App组件，用<code>&lt;React.StrictMode&gt;</code> 包裹：这样会检查App组件中不合理的部分（比如使用字符串形式的ref会弹出警告等）</p><ul><li><code>src/reportWebVital.js</code></li></ul><p>用于分析、记录、显示页面性能</p><ul><li><code>src/setupTests.js</code></li></ul><p>用于模块的整体测试</p><h3 id="编写方式">编写方式</h3><ul><li>不同组件放到 <code>src</code> 统一的文件夹下，文件夹内部，一个组件一个文件夹，用于存放组件使用的外部js和样式等</li><li>将不同组件在App中进行组合</li><li>区分组件和业务逻辑文件：<ul><li>组件文件名大写</li><li>组件文件后缀可以使用 <code>jsx</code></li></ul></li><li>多层文件引入麻烦，可以不同组件文件夹不同，但定义组件的文件都叫 <code>index.jsx</code> ，这样只要引入文件夹即可</li></ul><h3 id="样式模块化">样式模块化</h3><ul><li><p>避免不同模块之间样式冲突（不同模块指定相同名字的class不同样式，后引入的会覆盖之前引入的），要使用样式的模块化</p></li><li><p>模块化css：文件名改为 <code>xxx.module.css</code> 这样引入时可以将样式作为模块引入，使用时按照模块使用（<code>xxx.class</code> 等形式）</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* xxx.module.css */</span></span><br><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">&#x27;./xxx.module.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#123;xxx.title&#125;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用案例-todolist">应用案例 TodoList</h3><ul><li>上方Header组件为一个输入框，接受用户输入需要完成的任务，将任务加入到列表中</li><li>中间List展示已经有的任务，并且每个任务可以标志是否完成、可以删除</li><li>下方Footer展示已完成可全部任务数量，可以删除所有已完成任务，可以给所有任务打勾</li></ul><p><strong>困难</strong>：Header和List之间为兄弟，Header的数据无法传给List，也就无法新加入任务</p><p><strong>解决</strong>：Header用某种方式将数据传给父组件App，再由App用props的形式将数据传给List</p><h4 id="子组件向父组件传递数据">子组件向父组件传递数据</h4><p>将父组件类内部的处理、显示数据的函数传给子组件，子组件将数据作为函数参数传入并调用，相当于给父组件传入了参数，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span></span><br><span class="line">&#123;</span><br><span class="line">    state=&#123;<span class="attr">todos</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>:<span class="string">&quot;aaa&quot;</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>, <span class="attr">name</span>:<span class="string">&quot;bbb&quot;</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>, <span class="attr">name</span>:<span class="string">&quot;ccc&quot;</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">    ]&#125;;</span><br><span class="line">    <span class="comment">// 添加todo，接受一个todo对象（包含id、name、done等参数）</span></span><br><span class="line">    addTodo = <span class="function">(<span class="params">todoObj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;todos&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="comment">// 追加todo</span></span><br><span class="line">        <span class="keyword">const</span> newTodos=[todoObj,...todos];</span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">todos</span>:newTodos&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">             <span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> <span class="attr">addTodo</span>=<span class="string">&#123;this.addTodo&#125;/</span>&gt;</span></span></span><br><span class="line">             <span class="language-xml"><span class="tag">&lt;<span class="name">List</span>/&gt;</span></span></span><br><span class="line">             <span class="language-xml"><span class="tag">&lt;<span class="name">Footer</span>/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =======================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Header</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    </span><br><span class="line">    handleKeyUp = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// onKeyUp: 只要键盘按下就调用该事件</span></span><br><span class="line">        <span class="keyword">const</span> &#123;keyCode, target&#125; = event;</span><br><span class="line">        <span class="comment">// keyCode 为按下去的按键编码，value为输入框内容</span></span><br><span class="line">        <span class="keyword">if</span> (keyCode!== <span class="number">13</span>) <span class="keyword">return</span> <span class="comment">// 当按下的键不是回车直接返回，不处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造todo对象</span></span><br><span class="line">        <span class="comment">// id需要不同，可以用库构造uuid，uuid库过大，可以使用nanoid</span></span><br><span class="line">        <span class="comment">// 每次调用都生成唯一的id</span></span><br><span class="line">        <span class="comment">// npm i nanoid</span></span><br><span class="line">        <span class="keyword">const</span> todoObj=&#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(), <span class="attr">name</span>:target.<span class="property">value</span>, <span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用addTodo函数 加入新的任务</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">addTodo</span>(todoObj)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">onKeyUp</span>=<span class="string">&#123;this.handleKeyUp&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入任务名，按回车确认&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现见：<code>Todo_src</code></p><h2 id="react-和-axios">React 和 axios</h2><h3 id="跨域请求和代理配置">跨域请求和代理配置</h3><ul><li>当出现以下情况，都属于跨域访问</li></ul><table><thead><tr class="header"><th>跨域原因</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>域名不同</td><td>www.jd.com 与 www.taobao.com</td></tr><tr class="even"><td>域名相同，端口不同</td><td>www.jd.com:8080 与 www.jd.com:8081</td></tr><tr class="odd"><td>二级域名不同</td><td>item.jd.com 与 miaosha.jd.com</td></tr></tbody></table><ul><li><p>我们在测试请求数据时：在不同端口实现前端(3000)和后端服务器(5000)，造成跨域访问，导致数据获取失败。</p></li><li><p>Ajax 对于跨域请求：请求可以发出，后端服务器能够接收到，但是后端服务器发往前端的数据会被ajax阻止</p></li><li><p>对于跨域，我们可以设置代理：</p><ul><li>代理将前端请求转发给后端，将后端响应返回给前端</li><li>代理与前端端口和域名一致：前端仅与代理通信，不会造成跨域，请求不会被阻拦</li><li>代理访问后端实际为跨域，但是由于没有ajax阻拦所以可以实现</li></ul></li><li><p>做法：在package.json 中最后加入 <code>"proxy":"后端服务器地址"</code></p></li><li><p>发送数据时就直接给前端端口（不会产生跨域）发送数据，代理自动将数据转发</p></li><li><p>注意：请求会首先在真正的前端端口下寻找资源，如果找到是不会转发给后端服务器的</p></li></ul><h1 id="附">附</h1><h2 id="原生js基础">原生js基础</h2><ul><li>展开运算符：<code>...</code>用于展开可迭代的变量，如数组等，但字面量对象(可以理解为字典)无法直接展开</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...a)</span><br><span class="line"><span class="comment">// 输出1 2 3 4</span></span><br><span class="line"><span class="keyword">let</span> c = [...a,...b]</span><br><span class="line"><span class="comment">// 用于拼接数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let b = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;&#125;</span></span><br><span class="line"><span class="comment">// console.log(...b)    // 会报错</span></span><br></pre></td></tr></table></figure><h3 id="对象相关">对象相关</h3><ul><li>对象的复制：形式类似于展开运算符，但需要在外层加上<code>&#123;&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;ccc&#x27;</span>, <span class="attr">age</span>:<span class="string">&#x27;3&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="attr">age</span>:<span class="string">&#x27;2&#x27;</span>, <span class="attr">nigger</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = &#123;...a&#125;</span><br><span class="line"><span class="comment">// 复制a到c</span></span><br><span class="line"><span class="comment">// 注意，直接赋值 c=a 相当于直接返回a的指针，修改a，c也改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> merged = &#123;...a, ...b&#125;</span><br><span class="line"><span class="comment">// 合并a、b，其中相同的key被后者覆盖，不同的key加上</span></span><br><span class="line"><span class="comment">// merged = &#123;name:&#x27;xxx&#x27;, age:&#x27;2&#x27;, nigger: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>所有对象中<code>key:value</code> 表达式，默认<code>key</code> 为字符串，<code>name:"wx"</code> 等价于 <code>"name":"wx"</code>。如果想使变量作为<code>key</code> 可以使用方括号<code>[]</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataType = <span class="string">&quot;username&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">dataType</span>:<span class="string">&quot;wx&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 输出结果为&#123;dataType:&quot;wx&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;[dataType]:<span class="string">&quot;wx&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 输出结果为&#123;username:&quot;wx&quot;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>当对象key和value相同时，有简写形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opacity = <span class="number">0.5</span></span><br><span class="line">style1 = &#123;<span class="attr">opacity</span>:opacity&#125;</span><br><span class="line">style2 = &#123;opacity&#125;</span><br><span class="line"><span class="comment">// 两种写法效果相同</span></span><br><span class="line"><span class="comment">// 都会得到 &#123;opacity:0.5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="常用">常用</h3><ul><li><code>setInterval</code> 定时器，两个参数，第一个参数为函数，为执行的操作；第二个参数为执行函数间隔的时间</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time = <span class="number">200</span>    <span class="comment">//ms</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;&#125;, time)</span><br></pre></td></tr></table></figure><h3 id="特殊概念">特殊概念</h3><ul><li>高阶函数<ol type="1"><li>如果一个函数接受一个函数作为参数，那么就是高阶函数</li><li>如果一个函数将一个函数作为返回值，也是高阶函数</li></ol></li><li>函数的柯里化：通过函数调用最终返回函数的方式，实现多次接收参数，最后统一处理的函数编码形式。如受控和非受控组件中的<a href="#柯里化代码">代码</a></li></ul><h2 id="资源">资源</h2><ul><li>库的js可以通过官网找到，下载</li><li>还可以在<a href="https://www.bootcdn.cn/">BootCDN</a> 找到，该网站提供了常用js库的加速访问</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;react&quot;&gt;React&lt;/h1&gt;
&lt;h2 id=&quot;组件类型和定义&quot;&gt;组件类型和定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;react组件首字母应当大写，因为使用时以标签形式使用，如果首字母小写会认为是html的内置标签，报错&lt;/li&gt;
&lt;/ul&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Tech" scheme="https://xav1erw.github.io/categories/Tech/"/>
    
    <category term="前端" scheme="https://xav1erw.github.io/categories/Tech/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://xav1erw.github.io/tags/React/"/>
    
    <category term="javascript" scheme="https://xav1erw.github.io/tags/javascript/"/>
    
    <category term="前端" scheme="https://xav1erw.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
